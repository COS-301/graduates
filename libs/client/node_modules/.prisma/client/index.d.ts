
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  email: string
  password: string | null
  passwordSalt: string | null
  name: string | null
  dateOfBirth: Date | null
  companyId: string | null
  created: Date
  suspended: boolean
  validated: boolean
}

/**
 * Model UserScouted
 * 
 */
export type UserScouted = {
  userIdScout: string
  userId: string
  date: Date | null
}

/**
 * Model UserRole
 * 
 */
export type UserRole = {
  userId: string
  role: Role
}

/**
 * Model UserPermissions
 * 
 */
export type UserPermissions = {
  userId: string
  permissionType: PermissionType
  permissionCategory: PermissionCategory
  permissionTenant: PermissionTenant
}

/**
 * Model RolePermissions
 * 
 */
export type RolePermissions = {
  role: Role
  permissionType: PermissionType
  permissionCategory: PermissionCategory
  permissionTenant: PermissionTenant
}

/**
 * Model UserProfile
 * 
 */
export type UserProfile = {
  userId: string
  profilePicture: string | null
  bio: string | null
  employmentStatus: boolean
  openToOffers: boolean
}

/**
 * Model UserTag
 * 
 */
export type UserTag = {
  userId: string
  tag: string
}

/**
 * Model UserSocialMedia
 * 
 */
export type UserSocialMedia = {
  userId: string
  type: SocialMedia
  link: string
}

/**
 * Model UserLocation
 * 
 */
export type UserLocation = {
  userId: string
  location: string
}

/**
 * Model UserEmail
 * 
 */
export type UserEmail = {
  userId: string
  email: string
}

/**
 * Model UserProfileFile
 * 
 */
export type UserProfileFile = {
  fileId: string
  userId: string
  filePath: string
  fileCategory: FileCategory | null
  fileExtension: string | null
}

/**
 * Model UserDegree
 * 
 */
export type UserDegree = {
  userID: string
  degreeType: string
  degreeName: string
}

/**
 * Model Short
 * 
 */
export type Short = {
  id: string
  userId: string
  description: string | null
  link: string | null
  thumbnail: string | null
  datePosted: Date
  archived: boolean
}

/**
 * Model ShortTag
 * 
 */
export type ShortTag = {
  shortId: string
  tag: string
}

/**
 * Model ShortReport
 * 
 */
export type ShortReport = {
  shortId: string
  userId: string
  reason: string
}

/**
 * Model Notification
 * 
 */
export type Notification = {
  id: string
  userIdFrom: string | null
  userIdTo: string
  data: Prisma.JsonValue
  date: Date
  seen: boolean
}

/**
 * Model Blog
 * 
 */
export type Blog = {
  id: string
  userId: string
  title: string
  content: string | null
  date: Date
  archived: boolean
}

/**
 * Model BlogComment
 * 
 */
export type BlogComment = {
  id: string
  blogId: string
  userId: string
  content: string
  date: Date
}

/**
 * Model BlogMedia
 * 
 */
export type BlogMedia = {
  blogId: string
  media: string
}

/**
 * Model UserToken
 * 
 */
export type UserToken = {
  userId: string
  userToken: string
  userTokenType: number
  userTokenExpiration: number
}

/**
 * Model Test
 * 
 */
export type Test = {
  id: number
  test1: string
  test2: string | null
}

/**
 * Model UserContactNumber
 * 
 */
export type UserContactNumber = {
  userId: string
  number: string
}

/**
 * Model UserExperience
 * 
 */
export type UserExperience = {
  userId: string
  experience: string
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  USER: 'USER',
  STUDENT: 'STUDENT',
  COMPANY: 'COMPANY',
  REPRESENTATIVE: 'REPRESENTATIVE',
  ADMIN: 'ADMIN',
  SUSPENDED: 'SUSPENDED'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PermissionType: {
  CREATE: 'CREATE',
  EDIT: 'EDIT',
  REMOVE: 'REMOVE',
  VIEW: 'VIEW',
  ARCHIVE: 'ARCHIVE',
  SUSPEND: 'SUSPEND',
  ALL: 'ALL'
};

export type PermissionType = (typeof PermissionType)[keyof typeof PermissionType]


export const PermissionCategory: {
  USER: 'USER',
  STUDENT: 'STUDENT',
  COMPANY: 'COMPANY',
  PROFILE: 'PROFILE',
  STORY: 'STORY',
  PERMISSIONS: 'PERMISSIONS',
  ROLE: 'ROLE',
  ALL: 'ALL'
};

export type PermissionCategory = (typeof PermissionCategory)[keyof typeof PermissionCategory]


export const PermissionTenant: {
  USER: 'USER',
  STUDENT: 'STUDENT',
  COMPANY: 'COMPANY',
  COUNT: 'COUNT',
  VIEWERS: 'VIEWERS',
  NONE: 'NONE',
  ALL: 'ALL'
};

export type PermissionTenant = (typeof PermissionTenant)[keyof typeof PermissionTenant]


export const SocialMedia: {
  TWITTER: 'TWITTER',
  INSTAGRAM: 'INSTAGRAM',
  LINKEDIN: 'LINKEDIN',
  FACEBOOK: 'FACEBOOK',
  SNAPCHAT: 'SNAPCHAT',
  GITHUB: 'GITHUB'
};

export type SocialMedia = (typeof SocialMedia)[keyof typeof SocialMedia]


export const FileCategory: {
  ACADEMIC_RECORD: 'ACADEMIC_RECORD',
  DEGREE: 'DEGREE',
  MISC: 'MISC',
  CV: 'CV',
  PROFILE_PHOTO: 'PROFILE_PHOTO',
  VIDEO: 'VIDEO'
};

export type FileCategory = (typeof FileCategory)[keyof typeof FileCategory]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userScouted`: Exposes CRUD operations for the **UserScouted** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserScouteds
    * const userScouteds = await prisma.userScouted.findMany()
    * ```
    */
  get userScouted(): Prisma.UserScoutedDelegate<GlobalReject>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<GlobalReject>;

  /**
   * `prisma.userPermissions`: Exposes CRUD operations for the **UserPermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPermissions
    * const userPermissions = await prisma.userPermissions.findMany()
    * ```
    */
  get userPermissions(): Prisma.UserPermissionsDelegate<GlobalReject>;

  /**
   * `prisma.rolePermissions`: Exposes CRUD operations for the **RolePermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermissions.findMany()
    * ```
    */
  get rolePermissions(): Prisma.RolePermissionsDelegate<GlobalReject>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<GlobalReject>;

  /**
   * `prisma.userTag`: Exposes CRUD operations for the **UserTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTag.findMany()
    * ```
    */
  get userTag(): Prisma.UserTagDelegate<GlobalReject>;

  /**
   * `prisma.userSocialMedia`: Exposes CRUD operations for the **UserSocialMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSocialMedias
    * const userSocialMedias = await prisma.userSocialMedia.findMany()
    * ```
    */
  get userSocialMedia(): Prisma.UserSocialMediaDelegate<GlobalReject>;

  /**
   * `prisma.userLocation`: Exposes CRUD operations for the **UserLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLocations
    * const userLocations = await prisma.userLocation.findMany()
    * ```
    */
  get userLocation(): Prisma.UserLocationDelegate<GlobalReject>;

  /**
   * `prisma.userEmail`: Exposes CRUD operations for the **UserEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEmails
    * const userEmails = await prisma.userEmail.findMany()
    * ```
    */
  get userEmail(): Prisma.UserEmailDelegate<GlobalReject>;

  /**
   * `prisma.userProfileFile`: Exposes CRUD operations for the **UserProfileFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfileFiles
    * const userProfileFiles = await prisma.userProfileFile.findMany()
    * ```
    */
  get userProfileFile(): Prisma.UserProfileFileDelegate<GlobalReject>;

  /**
   * `prisma.userDegree`: Exposes CRUD operations for the **UserDegree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDegrees
    * const userDegrees = await prisma.userDegree.findMany()
    * ```
    */
  get userDegree(): Prisma.UserDegreeDelegate<GlobalReject>;

  /**
   * `prisma.short`: Exposes CRUD operations for the **Short** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shorts
    * const shorts = await prisma.short.findMany()
    * ```
    */
  get short(): Prisma.ShortDelegate<GlobalReject>;

  /**
   * `prisma.shortTag`: Exposes CRUD operations for the **ShortTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShortTags
    * const shortTags = await prisma.shortTag.findMany()
    * ```
    */
  get shortTag(): Prisma.ShortTagDelegate<GlobalReject>;

  /**
   * `prisma.shortReport`: Exposes CRUD operations for the **ShortReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShortReports
    * const shortReports = await prisma.shortReport.findMany()
    * ```
    */
  get shortReport(): Prisma.ShortReportDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<GlobalReject>;

  /**
   * `prisma.blogComment`: Exposes CRUD operations for the **BlogComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogComments
    * const blogComments = await prisma.blogComment.findMany()
    * ```
    */
  get blogComment(): Prisma.BlogCommentDelegate<GlobalReject>;

  /**
   * `prisma.blogMedia`: Exposes CRUD operations for the **BlogMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogMedias
    * const blogMedias = await prisma.blogMedia.findMany()
    * ```
    */
  get blogMedia(): Prisma.BlogMediaDelegate<GlobalReject>;

  /**
   * `prisma.userToken`: Exposes CRUD operations for the **UserToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTokens
    * const userTokens = await prisma.userToken.findMany()
    * ```
    */
  get userToken(): Prisma.UserTokenDelegate<GlobalReject>;

  /**
   * `prisma.test`: Exposes CRUD operations for the **Test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.test.findMany()
    * ```
    */
  get test(): Prisma.TestDelegate<GlobalReject>;

  /**
   * `prisma.userContactNumber`: Exposes CRUD operations for the **UserContactNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContactNumbers
    * const userContactNumbers = await prisma.userContactNumber.findMany()
    * ```
    */
  get userContactNumber(): Prisma.UserContactNumberDelegate<GlobalReject>;

  /**
   * `prisma.userExperience`: Exposes CRUD operations for the **UserExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserExperiences
    * const userExperiences = await prisma.userExperience.findMany()
    * ```
    */
  get userExperience(): Prisma.UserExperienceDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.11.0
   * Query Engine version: b371888aaf8f51357c7457d836b86d12da91658b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    UserScouted: 'UserScouted',
    UserRole: 'UserRole',
    UserPermissions: 'UserPermissions',
    RolePermissions: 'RolePermissions',
    UserProfile: 'UserProfile',
    UserTag: 'UserTag',
    UserSocialMedia: 'UserSocialMedia',
    UserLocation: 'UserLocation',
    UserEmail: 'UserEmail',
    UserProfileFile: 'UserProfileFile',
    UserDegree: 'UserDegree',
    Short: 'Short',
    ShortTag: 'ShortTag',
    ShortReport: 'ShortReport',
    Notification: 'Notification',
    Blog: 'Blog',
    BlogComment: 'BlogComment',
    BlogMedia: 'BlogMedia',
    UserToken: 'UserToken',
    Test: 'Test',
    UserContactNumber: 'UserContactNumber',
    UserExperience: 'UserExperience'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    User: number
    userScout: number
    userScouted: number
    UserRole: number
    UserPermissions: number
    UserProfile: number
    UserTag: number
    UserContactNumber: number
    UserDegree: number
    UserExperience: number
    UserSocialMedia: number
    UserLocation: number
    UserEmail: number
    UserProfileFile: number
    Short: number
    ShortReport: number
    notificationFrom: number
    notificationTo: number
    Blog: number
    BlogComment: number
    UserToken: number
  }

  export type UserCountOutputTypeSelect = {
    User?: boolean
    userScout?: boolean
    userScouted?: boolean
    UserRole?: boolean
    UserPermissions?: boolean
    UserProfile?: boolean
    UserTag?: boolean
    UserContactNumber?: boolean
    UserDegree?: boolean
    UserExperience?: boolean
    UserSocialMedia?: boolean
    UserLocation?: boolean
    UserEmail?: boolean
    UserProfileFile?: boolean
    Short?: boolean
    ShortReport?: boolean
    notificationFrom?: boolean
    notificationTo?: boolean
    Blog?: boolean
    BlogComment?: boolean
    UserToken?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type ShortCountOutputType
   */


  export type ShortCountOutputType = {
    shortTag: number
    shortReport: number
  }

  export type ShortCountOutputTypeSelect = {
    shortTag?: boolean
    shortReport?: boolean
  }

  export type ShortCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ShortCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ShortCountOutputType
    : S extends undefined
    ? never
    : S extends ShortCountOutputTypeArgs
    ?'include' extends U
    ? ShortCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ShortCountOutputType ? ShortCountOutputType[P] : never
  } 
    : ShortCountOutputType
  : ShortCountOutputType




  // Custom InputTypes

  /**
   * ShortCountOutputType without action
   */
  export type ShortCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShortCountOutputType
     * 
    **/
    select?: ShortCountOutputTypeSelect | null
  }



  /**
   * Count Type BlogCountOutputType
   */


  export type BlogCountOutputType = {
    blogComment: number
    blogMedia: number
  }

  export type BlogCountOutputTypeSelect = {
    blogComment?: boolean
    blogMedia?: boolean
  }

  export type BlogCountOutputTypeGetPayload<
    S extends boolean | null | undefined | BlogCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? BlogCountOutputType
    : S extends undefined
    ? never
    : S extends BlogCountOutputTypeArgs
    ?'include' extends U
    ? BlogCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BlogCountOutputType ? BlogCountOutputType[P] : never
  } 
    : BlogCountOutputType
  : BlogCountOutputType




  // Custom InputTypes

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BlogCountOutputType
     * 
    **/
    select?: BlogCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    passwordSalt: string | null
    name: string | null
    dateOfBirth: Date | null
    companyId: string | null
    created: Date | null
    suspended: boolean | null
    validated: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    passwordSalt: string | null
    name: string | null
    dateOfBirth: Date | null
    companyId: string | null
    created: Date | null
    suspended: boolean | null
    validated: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    passwordSalt: number
    name: number
    dateOfBirth: number
    companyId: number
    created: number
    suspended: number
    validated: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    passwordSalt?: true
    name?: true
    dateOfBirth?: true
    companyId?: true
    created?: true
    suspended?: true
    validated?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    passwordSalt?: true
    name?: true
    dateOfBirth?: true
    companyId?: true
    created?: true
    suspended?: true
    validated?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    passwordSalt?: true
    name?: true
    dateOfBirth?: true
    companyId?: true
    created?: true
    suspended?: true
    validated?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    passwordSalt: string | null
    name: string | null
    dateOfBirth: Date | null
    companyId: string | null
    created: Date
    suspended: boolean
    validated: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    password?: boolean
    passwordSalt?: boolean
    name?: boolean
    dateOfBirth?: boolean
    companyId?: boolean
    created?: boolean
    suspended?: boolean
    validated?: boolean
    company?: boolean | UserArgs
    User?: boolean | UserFindManyArgs
    userScout?: boolean | UserScoutedFindManyArgs
    userScouted?: boolean | UserScoutedFindManyArgs
    UserRole?: boolean | UserRoleFindManyArgs
    UserPermissions?: boolean | UserPermissionsFindManyArgs
    UserProfile?: boolean | UserProfileFindManyArgs
    UserTag?: boolean | UserTagFindManyArgs
    UserContactNumber?: boolean | UserContactNumberFindManyArgs
    UserDegree?: boolean | UserDegreeFindManyArgs
    UserExperience?: boolean | UserExperienceFindManyArgs
    UserSocialMedia?: boolean | UserSocialMediaFindManyArgs
    UserLocation?: boolean | UserLocationFindManyArgs
    UserEmail?: boolean | UserEmailFindManyArgs
    UserProfileFile?: boolean | UserProfileFileFindManyArgs
    Short?: boolean | ShortFindManyArgs
    ShortReport?: boolean | ShortReportFindManyArgs
    notificationFrom?: boolean | NotificationFindManyArgs
    notificationTo?: boolean | NotificationFindManyArgs
    Blog?: boolean | BlogFindManyArgs
    BlogComment?: boolean | BlogCommentFindManyArgs
    UserToken?: boolean | UserTokenFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    company?: boolean | UserArgs
    User?: boolean | UserFindManyArgs
    userScout?: boolean | UserScoutedFindManyArgs
    userScouted?: boolean | UserScoutedFindManyArgs
    UserRole?: boolean | UserRoleFindManyArgs
    UserPermissions?: boolean | UserPermissionsFindManyArgs
    UserProfile?: boolean | UserProfileFindManyArgs
    UserTag?: boolean | UserTagFindManyArgs
    UserContactNumber?: boolean | UserContactNumberFindManyArgs
    UserDegree?: boolean | UserDegreeFindManyArgs
    UserExperience?: boolean | UserExperienceFindManyArgs
    UserSocialMedia?: boolean | UserSocialMediaFindManyArgs
    UserLocation?: boolean | UserLocationFindManyArgs
    UserEmail?: boolean | UserEmailFindManyArgs
    UserProfileFile?: boolean | UserProfileFileFindManyArgs
    Short?: boolean | ShortFindManyArgs
    ShortReport?: boolean | ShortReportFindManyArgs
    notificationFrom?: boolean | NotificationFindManyArgs
    notificationTo?: boolean | NotificationFindManyArgs
    Blog?: boolean | BlogFindManyArgs
    BlogComment?: boolean | BlogCommentFindManyArgs
    UserToken?: boolean | UserTokenFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]:
        P extends 'company' ? UserGetPayload<S['include'][P]> | null :
        P extends 'User' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'userScout' ? Array < UserScoutedGetPayload<S['include'][P]>>  :
        P extends 'userScouted' ? Array < UserScoutedGetPayload<S['include'][P]>>  :
        P extends 'UserRole' ? Array < UserRoleGetPayload<S['include'][P]>>  :
        P extends 'UserPermissions' ? Array < UserPermissionsGetPayload<S['include'][P]>>  :
        P extends 'UserProfile' ? Array < UserProfileGetPayload<S['include'][P]>>  :
        P extends 'UserTag' ? Array < UserTagGetPayload<S['include'][P]>>  :
        P extends 'UserContactNumber' ? Array < UserContactNumberGetPayload<S['include'][P]>>  :
        P extends 'UserDegree' ? Array < UserDegreeGetPayload<S['include'][P]>>  :
        P extends 'UserExperience' ? Array < UserExperienceGetPayload<S['include'][P]>>  :
        P extends 'UserSocialMedia' ? Array < UserSocialMediaGetPayload<S['include'][P]>>  :
        P extends 'UserLocation' ? Array < UserLocationGetPayload<S['include'][P]>>  :
        P extends 'UserEmail' ? Array < UserEmailGetPayload<S['include'][P]>>  :
        P extends 'UserProfileFile' ? Array < UserProfileFileGetPayload<S['include'][P]>>  :
        P extends 'Short' ? Array < ShortGetPayload<S['include'][P]>>  :
        P extends 'ShortReport' ? Array < ShortReportGetPayload<S['include'][P]>>  :
        P extends 'notificationFrom' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'notificationTo' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'Blog' ? Array < BlogGetPayload<S['include'][P]>>  :
        P extends 'BlogComment' ? Array < BlogCommentGetPayload<S['include'][P]>>  :
        P extends 'UserToken' ? Array < UserTokenGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'company' ? UserGetPayload<S['select'][P]> | null :
        P extends 'User' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'userScout' ? Array < UserScoutedGetPayload<S['select'][P]>>  :
        P extends 'userScouted' ? Array < UserScoutedGetPayload<S['select'][P]>>  :
        P extends 'UserRole' ? Array < UserRoleGetPayload<S['select'][P]>>  :
        P extends 'UserPermissions' ? Array < UserPermissionsGetPayload<S['select'][P]>>  :
        P extends 'UserProfile' ? Array < UserProfileGetPayload<S['select'][P]>>  :
        P extends 'UserTag' ? Array < UserTagGetPayload<S['select'][P]>>  :
        P extends 'UserContactNumber' ? Array < UserContactNumberGetPayload<S['select'][P]>>  :
        P extends 'UserDegree' ? Array < UserDegreeGetPayload<S['select'][P]>>  :
        P extends 'UserExperience' ? Array < UserExperienceGetPayload<S['select'][P]>>  :
        P extends 'UserSocialMedia' ? Array < UserSocialMediaGetPayload<S['select'][P]>>  :
        P extends 'UserLocation' ? Array < UserLocationGetPayload<S['select'][P]>>  :
        P extends 'UserEmail' ? Array < UserEmailGetPayload<S['select'][P]>>  :
        P extends 'UserProfileFile' ? Array < UserProfileFileGetPayload<S['select'][P]>>  :
        P extends 'Short' ? Array < ShortGetPayload<S['select'][P]>>  :
        P extends 'ShortReport' ? Array < ShortReportGetPayload<S['select'][P]>>  :
        P extends 'notificationFrom' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'notificationTo' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'Blog' ? Array < BlogGetPayload<S['select'][P]>>  :
        P extends 'BlogComment' ? Array < BlogCommentGetPayload<S['select'][P]>>  :
        P extends 'UserToken' ? Array < UserTokenGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    company<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    User<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    userScout<T extends UserScoutedFindManyArgs = {}>(args?: Subset<T, UserScoutedFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserScouted>>, PrismaPromise<Array<UserScoutedGetPayload<T>>>>;

    userScouted<T extends UserScoutedFindManyArgs = {}>(args?: Subset<T, UserScoutedFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserScouted>>, PrismaPromise<Array<UserScoutedGetPayload<T>>>>;

    UserRole<T extends UserRoleFindManyArgs = {}>(args?: Subset<T, UserRoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserRole>>, PrismaPromise<Array<UserRoleGetPayload<T>>>>;

    UserPermissions<T extends UserPermissionsFindManyArgs = {}>(args?: Subset<T, UserPermissionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserPermissions>>, PrismaPromise<Array<UserPermissionsGetPayload<T>>>>;

    UserProfile<T extends UserProfileFindManyArgs = {}>(args?: Subset<T, UserProfileFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserProfile>>, PrismaPromise<Array<UserProfileGetPayload<T>>>>;

    UserTag<T extends UserTagFindManyArgs = {}>(args?: Subset<T, UserTagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserTag>>, PrismaPromise<Array<UserTagGetPayload<T>>>>;

    UserContactNumber<T extends UserContactNumberFindManyArgs = {}>(args?: Subset<T, UserContactNumberFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserContactNumber>>, PrismaPromise<Array<UserContactNumberGetPayload<T>>>>;

    UserDegree<T extends UserDegreeFindManyArgs = {}>(args?: Subset<T, UserDegreeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserDegree>>, PrismaPromise<Array<UserDegreeGetPayload<T>>>>;

    UserExperience<T extends UserExperienceFindManyArgs = {}>(args?: Subset<T, UserExperienceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserExperience>>, PrismaPromise<Array<UserExperienceGetPayload<T>>>>;

    UserSocialMedia<T extends UserSocialMediaFindManyArgs = {}>(args?: Subset<T, UserSocialMediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSocialMedia>>, PrismaPromise<Array<UserSocialMediaGetPayload<T>>>>;

    UserLocation<T extends UserLocationFindManyArgs = {}>(args?: Subset<T, UserLocationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserLocation>>, PrismaPromise<Array<UserLocationGetPayload<T>>>>;

    UserEmail<T extends UserEmailFindManyArgs = {}>(args?: Subset<T, UserEmailFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserEmail>>, PrismaPromise<Array<UserEmailGetPayload<T>>>>;

    UserProfileFile<T extends UserProfileFileFindManyArgs = {}>(args?: Subset<T, UserProfileFileFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserProfileFile>>, PrismaPromise<Array<UserProfileFileGetPayload<T>>>>;

    Short<T extends ShortFindManyArgs = {}>(args?: Subset<T, ShortFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Short>>, PrismaPromise<Array<ShortGetPayload<T>>>>;

    ShortReport<T extends ShortReportFindManyArgs = {}>(args?: Subset<T, ShortReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShortReport>>, PrismaPromise<Array<ShortReportGetPayload<T>>>>;

    notificationFrom<T extends NotificationFindManyArgs = {}>(args?: Subset<T, NotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>;

    notificationTo<T extends NotificationFindManyArgs = {}>(args?: Subset<T, NotificationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>;

    Blog<T extends BlogFindManyArgs = {}>(args?: Subset<T, BlogFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Blog>>, PrismaPromise<Array<BlogGetPayload<T>>>>;

    BlogComment<T extends BlogCommentFindManyArgs = {}>(args?: Subset<T, BlogCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BlogComment>>, PrismaPromise<Array<BlogCommentGetPayload<T>>>>;

    UserToken<T extends UserTokenFindManyArgs = {}>(args?: Subset<T, UserTokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserToken>>, PrismaPromise<Array<UserTokenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model UserScouted
   */


  export type AggregateUserScouted = {
    _count: UserScoutedCountAggregateOutputType | null
    _min: UserScoutedMinAggregateOutputType | null
    _max: UserScoutedMaxAggregateOutputType | null
  }

  export type UserScoutedMinAggregateOutputType = {
    userIdScout: string | null
    userId: string | null
    date: Date | null
  }

  export type UserScoutedMaxAggregateOutputType = {
    userIdScout: string | null
    userId: string | null
    date: Date | null
  }

  export type UserScoutedCountAggregateOutputType = {
    userIdScout: number
    userId: number
    date: number
    _all: number
  }


  export type UserScoutedMinAggregateInputType = {
    userIdScout?: true
    userId?: true
    date?: true
  }

  export type UserScoutedMaxAggregateInputType = {
    userIdScout?: true
    userId?: true
    date?: true
  }

  export type UserScoutedCountAggregateInputType = {
    userIdScout?: true
    userId?: true
    date?: true
    _all?: true
  }

  export type UserScoutedAggregateArgs = {
    /**
     * Filter which UserScouted to aggregate.
     * 
    **/
    where?: UserScoutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserScouteds to fetch.
     * 
    **/
    orderBy?: Enumerable<UserScoutedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserScoutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserScouteds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserScouteds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserScouteds
    **/
    _count?: true | UserScoutedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserScoutedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserScoutedMaxAggregateInputType
  }

  export type GetUserScoutedAggregateType<T extends UserScoutedAggregateArgs> = {
        [P in keyof T & keyof AggregateUserScouted]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserScouted[P]>
      : GetScalarType<T[P], AggregateUserScouted[P]>
  }




  export type UserScoutedGroupByArgs = {
    where?: UserScoutedWhereInput
    orderBy?: Enumerable<UserScoutedOrderByWithAggregationInput>
    by: Array<UserScoutedScalarFieldEnum>
    having?: UserScoutedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserScoutedCountAggregateInputType | true
    _min?: UserScoutedMinAggregateInputType
    _max?: UserScoutedMaxAggregateInputType
  }


  export type UserScoutedGroupByOutputType = {
    userIdScout: string
    userId: string
    date: Date | null
    _count: UserScoutedCountAggregateOutputType | null
    _min: UserScoutedMinAggregateOutputType | null
    _max: UserScoutedMaxAggregateOutputType | null
  }

  type GetUserScoutedGroupByPayload<T extends UserScoutedGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserScoutedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserScoutedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserScoutedGroupByOutputType[P]>
            : GetScalarType<T[P], UserScoutedGroupByOutputType[P]>
        }
      >
    >


  export type UserScoutedSelect = {
    userIdScout?: boolean
    userId?: boolean
    date?: boolean
    userScout?: boolean | UserArgs
    user?: boolean | UserArgs
  }

  export type UserScoutedInclude = {
    userScout?: boolean | UserArgs
    user?: boolean | UserArgs
  }

  export type UserScoutedGetPayload<
    S extends boolean | null | undefined | UserScoutedArgs,
    U = keyof S
      > = S extends true
        ? UserScouted
    : S extends undefined
    ? never
    : S extends UserScoutedArgs | UserScoutedFindManyArgs
    ?'include' extends U
    ? UserScouted  & {
    [P in TrueKeys<S['include']>]:
        P extends 'userScout' ? UserGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'userScout' ? UserGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserScouted ? UserScouted[P] : never
  } 
    : UserScouted
  : UserScouted


  type UserScoutedCountArgs = Merge<
    Omit<UserScoutedFindManyArgs, 'select' | 'include'> & {
      select?: UserScoutedCountAggregateInputType | true
    }
  >

  export interface UserScoutedDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserScouted that matches the filter.
     * @param {UserScoutedFindUniqueArgs} args - Arguments to find a UserScouted
     * @example
     * // Get one UserScouted
     * const userScouted = await prisma.userScouted.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserScoutedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserScoutedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserScouted'> extends True ? CheckSelect<T, Prisma__UserScoutedClient<UserScouted>, Prisma__UserScoutedClient<UserScoutedGetPayload<T>>> : CheckSelect<T, Prisma__UserScoutedClient<UserScouted | null >, Prisma__UserScoutedClient<UserScoutedGetPayload<T> | null >>

    /**
     * Find the first UserScouted that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScoutedFindFirstArgs} args - Arguments to find a UserScouted
     * @example
     * // Get one UserScouted
     * const userScouted = await prisma.userScouted.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserScoutedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserScoutedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserScouted'> extends True ? CheckSelect<T, Prisma__UserScoutedClient<UserScouted>, Prisma__UserScoutedClient<UserScoutedGetPayload<T>>> : CheckSelect<T, Prisma__UserScoutedClient<UserScouted | null >, Prisma__UserScoutedClient<UserScoutedGetPayload<T> | null >>

    /**
     * Find zero or more UserScouteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScoutedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserScouteds
     * const userScouteds = await prisma.userScouted.findMany()
     * 
     * // Get first 10 UserScouteds
     * const userScouteds = await prisma.userScouted.findMany({ take: 10 })
     * 
     * // Only select the `userIdScout`
     * const userScoutedWithUserIdScoutOnly = await prisma.userScouted.findMany({ select: { userIdScout: true } })
     * 
    **/
    findMany<T extends UserScoutedFindManyArgs>(
      args?: SelectSubset<T, UserScoutedFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserScouted>>, PrismaPromise<Array<UserScoutedGetPayload<T>>>>

    /**
     * Create a UserScouted.
     * @param {UserScoutedCreateArgs} args - Arguments to create a UserScouted.
     * @example
     * // Create one UserScouted
     * const UserScouted = await prisma.userScouted.create({
     *   data: {
     *     // ... data to create a UserScouted
     *   }
     * })
     * 
    **/
    create<T extends UserScoutedCreateArgs>(
      args: SelectSubset<T, UserScoutedCreateArgs>
    ): CheckSelect<T, Prisma__UserScoutedClient<UserScouted>, Prisma__UserScoutedClient<UserScoutedGetPayload<T>>>

    /**
     * Create many UserScouteds.
     *     @param {UserScoutedCreateManyArgs} args - Arguments to create many UserScouteds.
     *     @example
     *     // Create many UserScouteds
     *     const userScouted = await prisma.userScouted.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserScoutedCreateManyArgs>(
      args?: SelectSubset<T, UserScoutedCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserScouted.
     * @param {UserScoutedDeleteArgs} args - Arguments to delete one UserScouted.
     * @example
     * // Delete one UserScouted
     * const UserScouted = await prisma.userScouted.delete({
     *   where: {
     *     // ... filter to delete one UserScouted
     *   }
     * })
     * 
    **/
    delete<T extends UserScoutedDeleteArgs>(
      args: SelectSubset<T, UserScoutedDeleteArgs>
    ): CheckSelect<T, Prisma__UserScoutedClient<UserScouted>, Prisma__UserScoutedClient<UserScoutedGetPayload<T>>>

    /**
     * Update one UserScouted.
     * @param {UserScoutedUpdateArgs} args - Arguments to update one UserScouted.
     * @example
     * // Update one UserScouted
     * const userScouted = await prisma.userScouted.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserScoutedUpdateArgs>(
      args: SelectSubset<T, UserScoutedUpdateArgs>
    ): CheckSelect<T, Prisma__UserScoutedClient<UserScouted>, Prisma__UserScoutedClient<UserScoutedGetPayload<T>>>

    /**
     * Delete zero or more UserScouteds.
     * @param {UserScoutedDeleteManyArgs} args - Arguments to filter UserScouteds to delete.
     * @example
     * // Delete a few UserScouteds
     * const { count } = await prisma.userScouted.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserScoutedDeleteManyArgs>(
      args?: SelectSubset<T, UserScoutedDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserScouteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScoutedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserScouteds
     * const userScouted = await prisma.userScouted.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserScoutedUpdateManyArgs>(
      args: SelectSubset<T, UserScoutedUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserScouted.
     * @param {UserScoutedUpsertArgs} args - Arguments to update or create a UserScouted.
     * @example
     * // Update or create a UserScouted
     * const userScouted = await prisma.userScouted.upsert({
     *   create: {
     *     // ... data to create a UserScouted
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserScouted we want to update
     *   }
     * })
    **/
    upsert<T extends UserScoutedUpsertArgs>(
      args: SelectSubset<T, UserScoutedUpsertArgs>
    ): CheckSelect<T, Prisma__UserScoutedClient<UserScouted>, Prisma__UserScoutedClient<UserScoutedGetPayload<T>>>

    /**
     * Count the number of UserScouteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScoutedCountArgs} args - Arguments to filter UserScouteds to count.
     * @example
     * // Count the number of UserScouteds
     * const count = await prisma.userScouted.count({
     *   where: {
     *     // ... the filter for the UserScouteds we want to count
     *   }
     * })
    **/
    count<T extends UserScoutedCountArgs>(
      args?: Subset<T, UserScoutedCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserScoutedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserScouted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScoutedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserScoutedAggregateArgs>(args: Subset<T, UserScoutedAggregateArgs>): PrismaPromise<GetUserScoutedAggregateType<T>>

    /**
     * Group by UserScouted.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserScoutedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserScoutedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserScoutedGroupByArgs['orderBy'] }
        : { orderBy?: UserScoutedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserScoutedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserScoutedGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserScouted.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserScoutedClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    userScout<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserScouted findUnique
   */
  export type UserScoutedFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * Throw an Error if a UserScouted can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserScouted to fetch.
     * 
    **/
    where: UserScoutedWhereUniqueInput
  }


  /**
   * UserScouted findFirst
   */
  export type UserScoutedFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * Throw an Error if a UserScouted can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserScouted to fetch.
     * 
    **/
    where?: UserScoutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserScouteds to fetch.
     * 
    **/
    orderBy?: Enumerable<UserScoutedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserScouteds.
     * 
    **/
    cursor?: UserScoutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserScouteds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserScouteds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserScouteds.
     * 
    **/
    distinct?: Enumerable<UserScoutedScalarFieldEnum>
  }


  /**
   * UserScouted findMany
   */
  export type UserScoutedFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * Filter, which UserScouteds to fetch.
     * 
    **/
    where?: UserScoutedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserScouteds to fetch.
     * 
    **/
    orderBy?: Enumerable<UserScoutedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserScouteds.
     * 
    **/
    cursor?: UserScoutedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserScouteds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserScouteds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScoutedScalarFieldEnum>
  }


  /**
   * UserScouted create
   */
  export type UserScoutedCreateArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * The data needed to create a UserScouted.
     * 
    **/
    data: XOR<UserScoutedCreateInput, UserScoutedUncheckedCreateInput>
  }


  /**
   * UserScouted createMany
   */
  export type UserScoutedCreateManyArgs = {
    /**
     * The data used to create many UserScouteds.
     * 
    **/
    data: Enumerable<UserScoutedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserScouted update
   */
  export type UserScoutedUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * The data needed to update a UserScouted.
     * 
    **/
    data: XOR<UserScoutedUpdateInput, UserScoutedUncheckedUpdateInput>
    /**
     * Choose, which UserScouted to update.
     * 
    **/
    where: UserScoutedWhereUniqueInput
  }


  /**
   * UserScouted updateMany
   */
  export type UserScoutedUpdateManyArgs = {
    /**
     * The data used to update UserScouteds.
     * 
    **/
    data: XOR<UserScoutedUpdateManyMutationInput, UserScoutedUncheckedUpdateManyInput>
    /**
     * Filter which UserScouteds to update
     * 
    **/
    where?: UserScoutedWhereInput
  }


  /**
   * UserScouted upsert
   */
  export type UserScoutedUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * The filter to search for the UserScouted to update in case it exists.
     * 
    **/
    where: UserScoutedWhereUniqueInput
    /**
     * In case the UserScouted found by the `where` argument doesn't exist, create a new UserScouted with this data.
     * 
    **/
    create: XOR<UserScoutedCreateInput, UserScoutedUncheckedCreateInput>
    /**
     * In case the UserScouted was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserScoutedUpdateInput, UserScoutedUncheckedUpdateInput>
  }


  /**
   * UserScouted delete
   */
  export type UserScoutedDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
    /**
     * Filter which UserScouted to delete.
     * 
    **/
    where: UserScoutedWhereUniqueInput
  }


  /**
   * UserScouted deleteMany
   */
  export type UserScoutedDeleteManyArgs = {
    /**
     * Filter which UserScouteds to delete
     * 
    **/
    where?: UserScoutedWhereInput
  }


  /**
   * UserScouted without action
   */
  export type UserScoutedArgs = {
    /**
     * Select specific fields to fetch from the UserScouted
     * 
    **/
    select?: UserScoutedSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserScoutedInclude | null
  }



  /**
   * Model UserRole
   */


  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    role: Role | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    role: Role | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    role: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    role?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    role?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    role?: true
    _all?: true
  }

  export type UserRoleAggregateArgs = {
    /**
     * Filter which UserRole to aggregate.
     * 
    **/
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs = {
    where?: UserRoleWhereInput
    orderBy?: Enumerable<UserRoleOrderByWithAggregationInput>
    by: Array<UserRoleScalarFieldEnum>
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }


  export type UserRoleGroupByOutputType = {
    userId: string
    role: Role
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect = {
    userId?: boolean
    role?: boolean
    user?: boolean | UserArgs
  }

  export type UserRoleInclude = {
    user?: boolean | UserArgs
  }

  export type UserRoleGetPayload<
    S extends boolean | null | undefined | UserRoleArgs,
    U = keyof S
      > = S extends true
        ? UserRole
    : S extends undefined
    ? never
    : S extends UserRoleArgs | UserRoleFindManyArgs
    ?'include' extends U
    ? UserRole  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserRole ? UserRole[P] : never
  } 
    : UserRole
  : UserRole


  type UserRoleCountArgs = Merge<
    Omit<UserRoleFindManyArgs, 'select' | 'include'> & {
      select?: UserRoleCountAggregateInputType | true
    }
  >

  export interface UserRoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserRoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserRoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserRole'> extends True ? CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>> : CheckSelect<T, Prisma__UserRoleClient<UserRole | null >, Prisma__UserRoleClient<UserRoleGetPayload<T> | null >>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserRoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserRoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserRole'> extends True ? CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>> : CheckSelect<T, Prisma__UserRoleClient<UserRole | null >, Prisma__UserRoleClient<UserRoleGetPayload<T> | null >>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserRoleFindManyArgs>(
      args?: SelectSubset<T, UserRoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserRole>>, PrismaPromise<Array<UserRoleGetPayload<T>>>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
    **/
    create<T extends UserRoleCreateArgs>(
      args: SelectSubset<T, UserRoleCreateArgs>
    ): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

    /**
     * Create many UserRoles.
     *     @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     *     @example
     *     // Create many UserRoles
     *     const userRole = await prisma.userRole.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserRoleCreateManyArgs>(
      args?: SelectSubset<T, UserRoleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
    **/
    delete<T extends UserRoleDeleteArgs>(
      args: SelectSubset<T, UserRoleDeleteArgs>
    ): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserRoleUpdateArgs>(
      args: SelectSubset<T, UserRoleUpdateArgs>
    ): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserRoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserRoleUpdateManyArgs>(
      args: SelectSubset<T, UserRoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
    **/
    upsert<T extends UserRoleUpsertArgs>(
      args: SelectSubset<T, UserRoleUpsertArgs>
    ): CheckSelect<T, Prisma__UserRoleClient<UserRole>, Prisma__UserRoleClient<UserRoleGetPayload<T>>>

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserRoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * Throw an Error if a UserRole can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserRole to fetch.
     * 
    **/
    where: UserRoleWhereUniqueInput
  }


  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * Throw an Error if a UserRole can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserRole to fetch.
     * 
    **/
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     * 
    **/
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     * 
    **/
    distinct?: Enumerable<UserRoleScalarFieldEnum>
  }


  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * Filter, which UserRoles to fetch.
     * 
    **/
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserRoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     * 
    **/
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserRoleScalarFieldEnum>
  }


  /**
   * UserRole create
   */
  export type UserRoleCreateArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * The data needed to create a UserRole.
     * 
    **/
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }


  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs = {
    /**
     * The data used to create many UserRoles.
     * 
    **/
    data: Enumerable<UserRoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * The data needed to update a UserRole.
     * 
    **/
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     * 
    **/
    where: UserRoleWhereUniqueInput
  }


  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs = {
    /**
     * The data used to update UserRoles.
     * 
    **/
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     * 
    **/
    where?: UserRoleWhereInput
  }


  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     * 
    **/
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     * 
    **/
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }


  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
    /**
     * Filter which UserRole to delete.
     * 
    **/
    where: UserRoleWhereUniqueInput
  }


  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs = {
    /**
     * Filter which UserRoles to delete
     * 
    **/
    where?: UserRoleWhereInput
  }


  /**
   * UserRole without action
   */
  export type UserRoleArgs = {
    /**
     * Select specific fields to fetch from the UserRole
     * 
    **/
    select?: UserRoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserRoleInclude | null
  }



  /**
   * Model UserPermissions
   */


  export type AggregateUserPermissions = {
    _count: UserPermissionsCountAggregateOutputType | null
    _min: UserPermissionsMinAggregateOutputType | null
    _max: UserPermissionsMaxAggregateOutputType | null
  }

  export type UserPermissionsMinAggregateOutputType = {
    userId: string | null
    permissionType: PermissionType | null
    permissionCategory: PermissionCategory | null
    permissionTenant: PermissionTenant | null
  }

  export type UserPermissionsMaxAggregateOutputType = {
    userId: string | null
    permissionType: PermissionType | null
    permissionCategory: PermissionCategory | null
    permissionTenant: PermissionTenant | null
  }

  export type UserPermissionsCountAggregateOutputType = {
    userId: number
    permissionType: number
    permissionCategory: number
    permissionTenant: number
    _all: number
  }


  export type UserPermissionsMinAggregateInputType = {
    userId?: true
    permissionType?: true
    permissionCategory?: true
    permissionTenant?: true
  }

  export type UserPermissionsMaxAggregateInputType = {
    userId?: true
    permissionType?: true
    permissionCategory?: true
    permissionTenant?: true
  }

  export type UserPermissionsCountAggregateInputType = {
    userId?: true
    permissionType?: true
    permissionCategory?: true
    permissionTenant?: true
    _all?: true
  }

  export type UserPermissionsAggregateArgs = {
    /**
     * Filter which UserPermissions to aggregate.
     * 
    **/
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPermissions
    **/
    _count?: true | UserPermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPermissionsMaxAggregateInputType
  }

  export type GetUserPermissionsAggregateType<T extends UserPermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPermissions[P]>
      : GetScalarType<T[P], AggregateUserPermissions[P]>
  }




  export type UserPermissionsGroupByArgs = {
    where?: UserPermissionsWhereInput
    orderBy?: Enumerable<UserPermissionsOrderByWithAggregationInput>
    by: Array<UserPermissionsScalarFieldEnum>
    having?: UserPermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPermissionsCountAggregateInputType | true
    _min?: UserPermissionsMinAggregateInputType
    _max?: UserPermissionsMaxAggregateInputType
  }


  export type UserPermissionsGroupByOutputType = {
    userId: string
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
    _count: UserPermissionsCountAggregateOutputType | null
    _min: UserPermissionsMinAggregateOutputType | null
    _max: UserPermissionsMaxAggregateOutputType | null
  }

  type GetUserPermissionsGroupByPayload<T extends UserPermissionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserPermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], UserPermissionsGroupByOutputType[P]>
        }
      >
    >


  export type UserPermissionsSelect = {
    userId?: boolean
    permissionType?: boolean
    permissionCategory?: boolean
    permissionTenant?: boolean
    user?: boolean | UserArgs
  }

  export type UserPermissionsInclude = {
    user?: boolean | UserArgs
  }

  export type UserPermissionsGetPayload<
    S extends boolean | null | undefined | UserPermissionsArgs,
    U = keyof S
      > = S extends true
        ? UserPermissions
    : S extends undefined
    ? never
    : S extends UserPermissionsArgs | UserPermissionsFindManyArgs
    ?'include' extends U
    ? UserPermissions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserPermissions ? UserPermissions[P] : never
  } 
    : UserPermissions
  : UserPermissions


  type UserPermissionsCountArgs = Merge<
    Omit<UserPermissionsFindManyArgs, 'select' | 'include'> & {
      select?: UserPermissionsCountAggregateInputType | true
    }
  >

  export interface UserPermissionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserPermissions that matches the filter.
     * @param {UserPermissionsFindUniqueArgs} args - Arguments to find a UserPermissions
     * @example
     * // Get one UserPermissions
     * const userPermissions = await prisma.userPermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPermissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserPermissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserPermissions'> extends True ? CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions>, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T>>> : CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions | null >, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T> | null >>

    /**
     * Find the first UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsFindFirstArgs} args - Arguments to find a UserPermissions
     * @example
     * // Get one UserPermissions
     * const userPermissions = await prisma.userPermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPermissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserPermissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserPermissions'> extends True ? CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions>, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T>>> : CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions | null >, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T> | null >>

    /**
     * Find zero or more UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPermissions
     * const userPermissions = await prisma.userPermissions.findMany()
     * 
     * // Get first 10 UserPermissions
     * const userPermissions = await prisma.userPermissions.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPermissionsWithUserIdOnly = await prisma.userPermissions.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserPermissionsFindManyArgs>(
      args?: SelectSubset<T, UserPermissionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserPermissions>>, PrismaPromise<Array<UserPermissionsGetPayload<T>>>>

    /**
     * Create a UserPermissions.
     * @param {UserPermissionsCreateArgs} args - Arguments to create a UserPermissions.
     * @example
     * // Create one UserPermissions
     * const UserPermissions = await prisma.userPermissions.create({
     *   data: {
     *     // ... data to create a UserPermissions
     *   }
     * })
     * 
    **/
    create<T extends UserPermissionsCreateArgs>(
      args: SelectSubset<T, UserPermissionsCreateArgs>
    ): CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions>, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T>>>

    /**
     * Create many UserPermissions.
     *     @param {UserPermissionsCreateManyArgs} args - Arguments to create many UserPermissions.
     *     @example
     *     // Create many UserPermissions
     *     const userPermissions = await prisma.userPermissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPermissionsCreateManyArgs>(
      args?: SelectSubset<T, UserPermissionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserPermissions.
     * @param {UserPermissionsDeleteArgs} args - Arguments to delete one UserPermissions.
     * @example
     * // Delete one UserPermissions
     * const UserPermissions = await prisma.userPermissions.delete({
     *   where: {
     *     // ... filter to delete one UserPermissions
     *   }
     * })
     * 
    **/
    delete<T extends UserPermissionsDeleteArgs>(
      args: SelectSubset<T, UserPermissionsDeleteArgs>
    ): CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions>, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T>>>

    /**
     * Update one UserPermissions.
     * @param {UserPermissionsUpdateArgs} args - Arguments to update one UserPermissions.
     * @example
     * // Update one UserPermissions
     * const userPermissions = await prisma.userPermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPermissionsUpdateArgs>(
      args: SelectSubset<T, UserPermissionsUpdateArgs>
    ): CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions>, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T>>>

    /**
     * Delete zero or more UserPermissions.
     * @param {UserPermissionsDeleteManyArgs} args - Arguments to filter UserPermissions to delete.
     * @example
     * // Delete a few UserPermissions
     * const { count } = await prisma.userPermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPermissionsDeleteManyArgs>(
      args?: SelectSubset<T, UserPermissionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPermissions
     * const userPermissions = await prisma.userPermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPermissionsUpdateManyArgs>(
      args: SelectSubset<T, UserPermissionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPermissions.
     * @param {UserPermissionsUpsertArgs} args - Arguments to update or create a UserPermissions.
     * @example
     * // Update or create a UserPermissions
     * const userPermissions = await prisma.userPermissions.upsert({
     *   create: {
     *     // ... data to create a UserPermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPermissions we want to update
     *   }
     * })
    **/
    upsert<T extends UserPermissionsUpsertArgs>(
      args: SelectSubset<T, UserPermissionsUpsertArgs>
    ): CheckSelect<T, Prisma__UserPermissionsClient<UserPermissions>, Prisma__UserPermissionsClient<UserPermissionsGetPayload<T>>>

    /**
     * Count the number of UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsCountArgs} args - Arguments to filter UserPermissions to count.
     * @example
     * // Count the number of UserPermissions
     * const count = await prisma.userPermissions.count({
     *   where: {
     *     // ... the filter for the UserPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserPermissionsCountArgs>(
      args?: Subset<T, UserPermissionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPermissionsAggregateArgs>(args: Subset<T, UserPermissionsAggregateArgs>): PrismaPromise<GetUserPermissionsAggregateType<T>>

    /**
     * Group by UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPermissionsGroupByArgs['orderBy'] }
        : { orderBy?: UserPermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPermissionsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPermissionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserPermissions findUnique
   */
  export type UserPermissionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * Throw an Error if a UserPermissions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserPermissions to fetch.
     * 
    **/
    where: UserPermissionsWhereUniqueInput
  }


  /**
   * UserPermissions findFirst
   */
  export type UserPermissionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * Throw an Error if a UserPermissions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserPermissions to fetch.
     * 
    **/
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     * 
    **/
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     * 
    **/
    distinct?: Enumerable<UserPermissionsScalarFieldEnum>
  }


  /**
   * UserPermissions findMany
   */
  export type UserPermissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * Filter, which UserPermissions to fetch.
     * 
    **/
    where?: UserPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPermissions.
     * 
    **/
    cursor?: UserPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserPermissionsScalarFieldEnum>
  }


  /**
   * UserPermissions create
   */
  export type UserPermissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * The data needed to create a UserPermissions.
     * 
    **/
    data: XOR<UserPermissionsCreateInput, UserPermissionsUncheckedCreateInput>
  }


  /**
   * UserPermissions createMany
   */
  export type UserPermissionsCreateManyArgs = {
    /**
     * The data used to create many UserPermissions.
     * 
    **/
    data: Enumerable<UserPermissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserPermissions update
   */
  export type UserPermissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * The data needed to update a UserPermissions.
     * 
    **/
    data: XOR<UserPermissionsUpdateInput, UserPermissionsUncheckedUpdateInput>
    /**
     * Choose, which UserPermissions to update.
     * 
    **/
    where: UserPermissionsWhereUniqueInput
  }


  /**
   * UserPermissions updateMany
   */
  export type UserPermissionsUpdateManyArgs = {
    /**
     * The data used to update UserPermissions.
     * 
    **/
    data: XOR<UserPermissionsUpdateManyMutationInput, UserPermissionsUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     * 
    **/
    where?: UserPermissionsWhereInput
  }


  /**
   * UserPermissions upsert
   */
  export type UserPermissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * The filter to search for the UserPermissions to update in case it exists.
     * 
    **/
    where: UserPermissionsWhereUniqueInput
    /**
     * In case the UserPermissions found by the `where` argument doesn't exist, create a new UserPermissions with this data.
     * 
    **/
    create: XOR<UserPermissionsCreateInput, UserPermissionsUncheckedCreateInput>
    /**
     * In case the UserPermissions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserPermissionsUpdateInput, UserPermissionsUncheckedUpdateInput>
  }


  /**
   * UserPermissions delete
   */
  export type UserPermissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
    /**
     * Filter which UserPermissions to delete.
     * 
    **/
    where: UserPermissionsWhereUniqueInput
  }


  /**
   * UserPermissions deleteMany
   */
  export type UserPermissionsDeleteManyArgs = {
    /**
     * Filter which UserPermissions to delete
     * 
    **/
    where?: UserPermissionsWhereInput
  }


  /**
   * UserPermissions without action
   */
  export type UserPermissionsArgs = {
    /**
     * Select specific fields to fetch from the UserPermissions
     * 
    **/
    select?: UserPermissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPermissionsInclude | null
  }



  /**
   * Model RolePermissions
   */


  export type AggregateRolePermissions = {
    _count: RolePermissionsCountAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  export type RolePermissionsMinAggregateOutputType = {
    role: Role | null
    permissionType: PermissionType | null
    permissionCategory: PermissionCategory | null
    permissionTenant: PermissionTenant | null
  }

  export type RolePermissionsMaxAggregateOutputType = {
    role: Role | null
    permissionType: PermissionType | null
    permissionCategory: PermissionCategory | null
    permissionTenant: PermissionTenant | null
  }

  export type RolePermissionsCountAggregateOutputType = {
    role: number
    permissionType: number
    permissionCategory: number
    permissionTenant: number
    _all: number
  }


  export type RolePermissionsMinAggregateInputType = {
    role?: true
    permissionType?: true
    permissionCategory?: true
    permissionTenant?: true
  }

  export type RolePermissionsMaxAggregateInputType = {
    role?: true
    permissionType?: true
    permissionCategory?: true
    permissionTenant?: true
  }

  export type RolePermissionsCountAggregateInputType = {
    role?: true
    permissionType?: true
    permissionCategory?: true
    permissionTenant?: true
    _all?: true
  }

  export type RolePermissionsAggregateArgs = {
    /**
     * Filter which RolePermissions to aggregate.
     * 
    **/
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type GetRolePermissionsAggregateType<T extends RolePermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermissions[P]>
      : GetScalarType<T[P], AggregateRolePermissions[P]>
  }




  export type RolePermissionsGroupByArgs = {
    where?: RolePermissionsWhereInput
    orderBy?: Enumerable<RolePermissionsOrderByWithAggregationInput>
    by: Array<RolePermissionsScalarFieldEnum>
    having?: RolePermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionsCountAggregateInputType | true
    _min?: RolePermissionsMinAggregateInputType
    _max?: RolePermissionsMaxAggregateInputType
  }


  export type RolePermissionsGroupByOutputType = {
    role: Role
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
    _count: RolePermissionsCountAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  type GetRolePermissionsGroupByPayload<T extends RolePermissionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RolePermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionsSelect = {
    role?: boolean
    permissionType?: boolean
    permissionCategory?: boolean
    permissionTenant?: boolean
  }

  export type RolePermissionsGetPayload<
    S extends boolean | null | undefined | RolePermissionsArgs,
    U = keyof S
      > = S extends true
        ? RolePermissions
    : S extends undefined
    ? never
    : S extends RolePermissionsArgs | RolePermissionsFindManyArgs
    ?'include' extends U
    ? RolePermissions 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof RolePermissions ? RolePermissions[P] : never
  } 
    : RolePermissions
  : RolePermissions


  type RolePermissionsCountArgs = Merge<
    Omit<RolePermissionsFindManyArgs, 'select' | 'include'> & {
      select?: RolePermissionsCountAggregateInputType | true
    }
  >

  export interface RolePermissionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RolePermissions that matches the filter.
     * @param {RolePermissionsFindUniqueArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolePermissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolePermissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RolePermissions'> extends True ? CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions>, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions | null >, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T> | null >>

    /**
     * Find the first RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolePermissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolePermissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RolePermissions'> extends True ? CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions>, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T>>> : CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions | null >, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T> | null >>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany({ take: 10 })
     * 
     * 
    **/
    findMany<T extends RolePermissionsFindManyArgs>(
      args?: SelectSubset<T, RolePermissionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RolePermissions>>, PrismaPromise<Array<RolePermissionsGetPayload<T>>>>

    /**
     * Create a RolePermissions.
     * @param {RolePermissionsCreateArgs} args - Arguments to create a RolePermissions.
     * @example
     * // Create one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.create({
     *   data: {
     *     // ... data to create a RolePermissions
     *   }
     * })
     * 
    **/
    create<T extends RolePermissionsCreateArgs>(
      args: SelectSubset<T, RolePermissionsCreateArgs>
    ): CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions>, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T>>>

    /**
     * Create many RolePermissions.
     *     @param {RolePermissionsCreateManyArgs} args - Arguments to create many RolePermissions.
     *     @example
     *     // Create many RolePermissions
     *     const rolePermissions = await prisma.rolePermissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolePermissionsCreateManyArgs>(
      args?: SelectSubset<T, RolePermissionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermissions.
     * @param {RolePermissionsDeleteArgs} args - Arguments to delete one RolePermissions.
     * @example
     * // Delete one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.delete({
     *   where: {
     *     // ... filter to delete one RolePermissions
     *   }
     * })
     * 
    **/
    delete<T extends RolePermissionsDeleteArgs>(
      args: SelectSubset<T, RolePermissionsDeleteArgs>
    ): CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions>, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T>>>

    /**
     * Update one RolePermissions.
     * @param {RolePermissionsUpdateArgs} args - Arguments to update one RolePermissions.
     * @example
     * // Update one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolePermissionsUpdateArgs>(
      args: SelectSubset<T, RolePermissionsUpdateArgs>
    ): CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions>, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T>>>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionsDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolePermissionsDeleteManyArgs>(
      args?: SelectSubset<T, RolePermissionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolePermissionsUpdateManyArgs>(
      args: SelectSubset<T, RolePermissionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermissions.
     * @param {RolePermissionsUpsertArgs} args - Arguments to update or create a RolePermissions.
     * @example
     * // Update or create a RolePermissions
     * const rolePermissions = await prisma.rolePermissions.upsert({
     *   create: {
     *     // ... data to create a RolePermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermissions we want to update
     *   }
     * })
    **/
    upsert<T extends RolePermissionsUpsertArgs>(
      args: SelectSubset<T, RolePermissionsUpsertArgs>
    ): CheckSelect<T, Prisma__RolePermissionsClient<RolePermissions>, Prisma__RolePermissionsClient<RolePermissionsGetPayload<T>>>

    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermissions.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionsCountArgs>(
      args?: Subset<T, RolePermissionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionsAggregateArgs>(args: Subset<T, RolePermissionsAggregateArgs>): PrismaPromise<GetRolePermissionsAggregateType<T>>

    /**
     * Group by RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionsGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolePermissionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RolePermissions findUnique
   */
  export type RolePermissionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * Throw an Error if a RolePermissions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RolePermissions to fetch.
     * 
    **/
    where: RolePermissionsWhereUniqueInput
  }


  /**
   * RolePermissions findFirst
   */
  export type RolePermissionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * Throw an Error if a RolePermissions can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RolePermissions to fetch.
     * 
    **/
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     * 
    **/
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     * 
    **/
    distinct?: Enumerable<RolePermissionsScalarFieldEnum>
  }


  /**
   * RolePermissions findMany
   */
  export type RolePermissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * Filter, which RolePermissions to fetch.
     * 
    **/
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     * 
    **/
    orderBy?: Enumerable<RolePermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     * 
    **/
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolePermissionsScalarFieldEnum>
  }


  /**
   * RolePermissions create
   */
  export type RolePermissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * The data needed to create a RolePermissions.
     * 
    **/
    data: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
  }


  /**
   * RolePermissions createMany
   */
  export type RolePermissionsCreateManyArgs = {
    /**
     * The data used to create many RolePermissions.
     * 
    **/
    data: Enumerable<RolePermissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RolePermissions update
   */
  export type RolePermissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * The data needed to update a RolePermissions.
     * 
    **/
    data: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
    /**
     * Choose, which RolePermissions to update.
     * 
    **/
    where: RolePermissionsWhereUniqueInput
  }


  /**
   * RolePermissions updateMany
   */
  export type RolePermissionsUpdateManyArgs = {
    /**
     * The data used to update RolePermissions.
     * 
    **/
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     * 
    **/
    where?: RolePermissionsWhereInput
  }


  /**
   * RolePermissions upsert
   */
  export type RolePermissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * The filter to search for the RolePermissions to update in case it exists.
     * 
    **/
    where: RolePermissionsWhereUniqueInput
    /**
     * In case the RolePermissions found by the `where` argument doesn't exist, create a new RolePermissions with this data.
     * 
    **/
    create: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
    /**
     * In case the RolePermissions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
  }


  /**
   * RolePermissions delete
   */
  export type RolePermissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
    /**
     * Filter which RolePermissions to delete.
     * 
    **/
    where: RolePermissionsWhereUniqueInput
  }


  /**
   * RolePermissions deleteMany
   */
  export type RolePermissionsDeleteManyArgs = {
    /**
     * Filter which RolePermissions to delete
     * 
    **/
    where?: RolePermissionsWhereInput
  }


  /**
   * RolePermissions without action
   */
  export type RolePermissionsArgs = {
    /**
     * Select specific fields to fetch from the RolePermissions
     * 
    **/
    select?: RolePermissionsSelect | null
  }



  /**
   * Model UserProfile
   */


  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    userId: string | null
    profilePicture: string | null
    bio: string | null
    employmentStatus: boolean | null
    openToOffers: boolean | null
  }

  export type UserProfileMaxAggregateOutputType = {
    userId: string | null
    profilePicture: string | null
    bio: string | null
    employmentStatus: boolean | null
    openToOffers: boolean | null
  }

  export type UserProfileCountAggregateOutputType = {
    userId: number
    profilePicture: number
    bio: number
    employmentStatus: number
    openToOffers: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    userId?: true
    profilePicture?: true
    bio?: true
    employmentStatus?: true
    openToOffers?: true
  }

  export type UserProfileMaxAggregateInputType = {
    userId?: true
    profilePicture?: true
    bio?: true
    employmentStatus?: true
    openToOffers?: true
  }

  export type UserProfileCountAggregateInputType = {
    userId?: true
    profilePicture?: true
    bio?: true
    employmentStatus?: true
    openToOffers?: true
    _all?: true
  }

  export type UserProfileAggregateArgs = {
    /**
     * Filter which UserProfile to aggregate.
     * 
    **/
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs = {
    where?: UserProfileWhereInput
    orderBy?: Enumerable<UserProfileOrderByWithAggregationInput>
    by: Array<UserProfileScalarFieldEnum>
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }


  export type UserProfileGroupByOutputType = {
    userId: string
    profilePicture: string | null
    bio: string | null
    employmentStatus: boolean
    openToOffers: boolean
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect = {
    userId?: boolean
    profilePicture?: boolean
    bio?: boolean
    employmentStatus?: boolean
    openToOffers?: boolean
    user?: boolean | UserArgs
  }

  export type UserProfileInclude = {
    user?: boolean | UserArgs
  }

  export type UserProfileGetPayload<
    S extends boolean | null | undefined | UserProfileArgs,
    U = keyof S
      > = S extends true
        ? UserProfile
    : S extends undefined
    ? never
    : S extends UserProfileArgs | UserProfileFindManyArgs
    ?'include' extends U
    ? UserProfile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserProfile ? UserProfile[P] : never
  } 
    : UserProfile
  : UserProfile


  type UserProfileCountArgs = Merge<
    Omit<UserProfileFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileCountAggregateInputType | true
    }
  >

  export interface UserProfileDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserProfile'> extends True ? CheckSelect<T, Prisma__UserProfileClient<UserProfile>, Prisma__UserProfileClient<UserProfileGetPayload<T>>> : CheckSelect<T, Prisma__UserProfileClient<UserProfile | null >, Prisma__UserProfileClient<UserProfileGetPayload<T> | null >>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserProfile'> extends True ? CheckSelect<T, Prisma__UserProfileClient<UserProfile>, Prisma__UserProfileClient<UserProfileGetPayload<T>>> : CheckSelect<T, Prisma__UserProfileClient<UserProfile | null >, Prisma__UserProfileClient<UserProfileGetPayload<T> | null >>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userProfileWithUserIdOnly = await prisma.userProfile.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserProfileFindManyArgs>(
      args?: SelectSubset<T, UserProfileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserProfile>>, PrismaPromise<Array<UserProfileGetPayload<T>>>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
    **/
    create<T extends UserProfileCreateArgs>(
      args: SelectSubset<T, UserProfileCreateArgs>
    ): CheckSelect<T, Prisma__UserProfileClient<UserProfile>, Prisma__UserProfileClient<UserProfileGetPayload<T>>>

    /**
     * Create many UserProfiles.
     *     @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     *     @example
     *     // Create many UserProfiles
     *     const userProfile = await prisma.userProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileCreateManyArgs>(
      args?: SelectSubset<T, UserProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileDeleteArgs>(
      args: SelectSubset<T, UserProfileDeleteArgs>
    ): CheckSelect<T, Prisma__UserProfileClient<UserProfile>, Prisma__UserProfileClient<UserProfileGetPayload<T>>>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileUpdateArgs>(
      args: SelectSubset<T, UserProfileUpdateArgs>
    ): CheckSelect<T, Prisma__UserProfileClient<UserProfile>, Prisma__UserProfileClient<UserProfileGetPayload<T>>>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileDeleteManyArgs>(
      args?: SelectSubset<T, UserProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileUpdateManyArgs>(
      args: SelectSubset<T, UserProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileUpsertArgs>(
      args: SelectSubset<T, UserProfileUpsertArgs>
    ): CheckSelect<T, Prisma__UserProfileClient<UserProfile>, Prisma__UserProfileClient<UserProfileGetPayload<T>>>

    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * Throw an Error if a UserProfile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserProfile to fetch.
     * 
    **/
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * Throw an Error if a UserProfile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserProfile to fetch.
     * 
    **/
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     * 
    **/
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     * 
    **/
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * Filter, which UserProfiles to fetch.
     * 
    **/
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     * 
    **/
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserProfileScalarFieldEnum>
  }


  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * The data needed to create a UserProfile.
     * 
    **/
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }


  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs = {
    /**
     * The data used to create many UserProfiles.
     * 
    **/
    data: Enumerable<UserProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * The data needed to update a UserProfile.
     * 
    **/
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     * 
    **/
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs = {
    /**
     * The data used to update UserProfiles.
     * 
    **/
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     * 
    **/
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     * 
    **/
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     * 
    **/
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }


  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
    /**
     * Filter which UserProfile to delete.
     * 
    **/
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs = {
    /**
     * Filter which UserProfiles to delete
     * 
    **/
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile without action
   */
  export type UserProfileArgs = {
    /**
     * Select specific fields to fetch from the UserProfile
     * 
    **/
    select?: UserProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileInclude | null
  }



  /**
   * Model UserTag
   */


  export type AggregateUserTag = {
    _count: UserTagCountAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  export type UserTagMinAggregateOutputType = {
    userId: string | null
    tag: string | null
  }

  export type UserTagMaxAggregateOutputType = {
    userId: string | null
    tag: string | null
  }

  export type UserTagCountAggregateOutputType = {
    userId: number
    tag: number
    _all: number
  }


  export type UserTagMinAggregateInputType = {
    userId?: true
    tag?: true
  }

  export type UserTagMaxAggregateInputType = {
    userId?: true
    tag?: true
  }

  export type UserTagCountAggregateInputType = {
    userId?: true
    tag?: true
    _all?: true
  }

  export type UserTagAggregateArgs = {
    /**
     * Filter which UserTag to aggregate.
     * 
    **/
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagMaxAggregateInputType
  }

  export type GetUserTagAggregateType<T extends UserTagAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTag[P]>
      : GetScalarType<T[P], AggregateUserTag[P]>
  }




  export type UserTagGroupByArgs = {
    where?: UserTagWhereInput
    orderBy?: Enumerable<UserTagOrderByWithAggregationInput>
    by: Array<UserTagScalarFieldEnum>
    having?: UserTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagCountAggregateInputType | true
    _min?: UserTagMinAggregateInputType
    _max?: UserTagMaxAggregateInputType
  }


  export type UserTagGroupByOutputType = {
    userId: string
    tag: string
    _count: UserTagCountAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  type GetUserTagGroupByPayload<T extends UserTagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagGroupByOutputType[P]>
        }
      >
    >


  export type UserTagSelect = {
    userId?: boolean
    tag?: boolean
    user?: boolean | UserArgs
  }

  export type UserTagInclude = {
    user?: boolean | UserArgs
  }

  export type UserTagGetPayload<
    S extends boolean | null | undefined | UserTagArgs,
    U = keyof S
      > = S extends true
        ? UserTag
    : S extends undefined
    ? never
    : S extends UserTagArgs | UserTagFindManyArgs
    ?'include' extends U
    ? UserTag  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserTag ? UserTag[P] : never
  } 
    : UserTag
  : UserTag


  type UserTagCountArgs = Merge<
    Omit<UserTagFindManyArgs, 'select' | 'include'> & {
      select?: UserTagCountAggregateInputType | true
    }
  >

  export interface UserTagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserTag that matches the filter.
     * @param {UserTagFindUniqueArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserTag'> extends True ? CheckSelect<T, Prisma__UserTagClient<UserTag>, Prisma__UserTagClient<UserTagGetPayload<T>>> : CheckSelect<T, Prisma__UserTagClient<UserTag | null >, Prisma__UserTagClient<UserTagGetPayload<T> | null >>

    /**
     * Find the first UserTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserTag'> extends True ? CheckSelect<T, Prisma__UserTagClient<UserTag>, Prisma__UserTagClient<UserTagGetPayload<T>>> : CheckSelect<T, Prisma__UserTagClient<UserTag | null >, Prisma__UserTagClient<UserTagGetPayload<T> | null >>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTag.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTag.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userTagWithUserIdOnly = await prisma.userTag.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserTagFindManyArgs>(
      args?: SelectSubset<T, UserTagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserTag>>, PrismaPromise<Array<UserTagGetPayload<T>>>>

    /**
     * Create a UserTag.
     * @param {UserTagCreateArgs} args - Arguments to create a UserTag.
     * @example
     * // Create one UserTag
     * const UserTag = await prisma.userTag.create({
     *   data: {
     *     // ... data to create a UserTag
     *   }
     * })
     * 
    **/
    create<T extends UserTagCreateArgs>(
      args: SelectSubset<T, UserTagCreateArgs>
    ): CheckSelect<T, Prisma__UserTagClient<UserTag>, Prisma__UserTagClient<UserTagGetPayload<T>>>

    /**
     * Create many UserTags.
     *     @param {UserTagCreateManyArgs} args - Arguments to create many UserTags.
     *     @example
     *     // Create many UserTags
     *     const userTag = await prisma.userTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserTagCreateManyArgs>(
      args?: SelectSubset<T, UserTagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserTag.
     * @param {UserTagDeleteArgs} args - Arguments to delete one UserTag.
     * @example
     * // Delete one UserTag
     * const UserTag = await prisma.userTag.delete({
     *   where: {
     *     // ... filter to delete one UserTag
     *   }
     * })
     * 
    **/
    delete<T extends UserTagDeleteArgs>(
      args: SelectSubset<T, UserTagDeleteArgs>
    ): CheckSelect<T, Prisma__UserTagClient<UserTag>, Prisma__UserTagClient<UserTagGetPayload<T>>>

    /**
     * Update one UserTag.
     * @param {UserTagUpdateArgs} args - Arguments to update one UserTag.
     * @example
     * // Update one UserTag
     * const userTag = await prisma.userTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTagUpdateArgs>(
      args: SelectSubset<T, UserTagUpdateArgs>
    ): CheckSelect<T, Prisma__UserTagClient<UserTag>, Prisma__UserTagClient<UserTagGetPayload<T>>>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTagDeleteManyArgs>(
      args?: SelectSubset<T, UserTagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTag = await prisma.userTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTagUpdateManyArgs>(
      args: SelectSubset<T, UserTagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTag.
     * @param {UserTagUpsertArgs} args - Arguments to update or create a UserTag.
     * @example
     * // Update or create a UserTag
     * const userTag = await prisma.userTag.upsert({
     *   create: {
     *     // ... data to create a UserTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTag we want to update
     *   }
     * })
    **/
    upsert<T extends UserTagUpsertArgs>(
      args: SelectSubset<T, UserTagUpsertArgs>
    ): CheckSelect<T, Prisma__UserTagClient<UserTag>, Prisma__UserTagClient<UserTagGetPayload<T>>>

    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTag.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagCountArgs>(
      args?: Subset<T, UserTagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagAggregateArgs>(args: Subset<T, UserTagAggregateArgs>): PrismaPromise<GetUserTagAggregateType<T>>

    /**
     * Group by UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagGroupByArgs['orderBy'] }
        : { orderBy?: UserTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserTagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserTag findUnique
   */
  export type UserTagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * Throw an Error if a UserTag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserTag to fetch.
     * 
    **/
    where: UserTagWhereUniqueInput
  }


  /**
   * UserTag findFirst
   */
  export type UserTagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * Throw an Error if a UserTag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserTag to fetch.
     * 
    **/
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     * 
    **/
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     * 
    **/
    distinct?: Enumerable<UserTagScalarFieldEnum>
  }


  /**
   * UserTag findMany
   */
  export type UserTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * Filter, which UserTags to fetch.
     * 
    **/
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     * 
    **/
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserTagScalarFieldEnum>
  }


  /**
   * UserTag create
   */
  export type UserTagCreateArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * The data needed to create a UserTag.
     * 
    **/
    data: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
  }


  /**
   * UserTag createMany
   */
  export type UserTagCreateManyArgs = {
    /**
     * The data used to create many UserTags.
     * 
    **/
    data: Enumerable<UserTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserTag update
   */
  export type UserTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * The data needed to update a UserTag.
     * 
    **/
    data: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
    /**
     * Choose, which UserTag to update.
     * 
    **/
    where: UserTagWhereUniqueInput
  }


  /**
   * UserTag updateMany
   */
  export type UserTagUpdateManyArgs = {
    /**
     * The data used to update UserTags.
     * 
    **/
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     * 
    **/
    where?: UserTagWhereInput
  }


  /**
   * UserTag upsert
   */
  export type UserTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * The filter to search for the UserTag to update in case it exists.
     * 
    **/
    where: UserTagWhereUniqueInput
    /**
     * In case the UserTag found by the `where` argument doesn't exist, create a new UserTag with this data.
     * 
    **/
    create: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
    /**
     * In case the UserTag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
  }


  /**
   * UserTag delete
   */
  export type UserTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
    /**
     * Filter which UserTag to delete.
     * 
    **/
    where: UserTagWhereUniqueInput
  }


  /**
   * UserTag deleteMany
   */
  export type UserTagDeleteManyArgs = {
    /**
     * Filter which UserTags to delete
     * 
    **/
    where?: UserTagWhereInput
  }


  /**
   * UserTag without action
   */
  export type UserTagArgs = {
    /**
     * Select specific fields to fetch from the UserTag
     * 
    **/
    select?: UserTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTagInclude | null
  }



  /**
   * Model UserSocialMedia
   */


  export type AggregateUserSocialMedia = {
    _count: UserSocialMediaCountAggregateOutputType | null
    _min: UserSocialMediaMinAggregateOutputType | null
    _max: UserSocialMediaMaxAggregateOutputType | null
  }

  export type UserSocialMediaMinAggregateOutputType = {
    userId: string | null
    type: SocialMedia | null
    link: string | null
  }

  export type UserSocialMediaMaxAggregateOutputType = {
    userId: string | null
    type: SocialMedia | null
    link: string | null
  }

  export type UserSocialMediaCountAggregateOutputType = {
    userId: number
    type: number
    link: number
    _all: number
  }


  export type UserSocialMediaMinAggregateInputType = {
    userId?: true
    type?: true
    link?: true
  }

  export type UserSocialMediaMaxAggregateInputType = {
    userId?: true
    type?: true
    link?: true
  }

  export type UserSocialMediaCountAggregateInputType = {
    userId?: true
    type?: true
    link?: true
    _all?: true
  }

  export type UserSocialMediaAggregateArgs = {
    /**
     * Filter which UserSocialMedia to aggregate.
     * 
    **/
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSocialMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSocialMedias
    **/
    _count?: true | UserSocialMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSocialMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSocialMediaMaxAggregateInputType
  }

  export type GetUserSocialMediaAggregateType<T extends UserSocialMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSocialMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSocialMedia[P]>
      : GetScalarType<T[P], AggregateUserSocialMedia[P]>
  }




  export type UserSocialMediaGroupByArgs = {
    where?: UserSocialMediaWhereInput
    orderBy?: Enumerable<UserSocialMediaOrderByWithAggregationInput>
    by: Array<UserSocialMediaScalarFieldEnum>
    having?: UserSocialMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSocialMediaCountAggregateInputType | true
    _min?: UserSocialMediaMinAggregateInputType
    _max?: UserSocialMediaMaxAggregateInputType
  }


  export type UserSocialMediaGroupByOutputType = {
    userId: string
    type: SocialMedia
    link: string
    _count: UserSocialMediaCountAggregateOutputType | null
    _min: UserSocialMediaMinAggregateOutputType | null
    _max: UserSocialMediaMaxAggregateOutputType | null
  }

  type GetUserSocialMediaGroupByPayload<T extends UserSocialMediaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserSocialMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSocialMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSocialMediaGroupByOutputType[P]>
            : GetScalarType<T[P], UserSocialMediaGroupByOutputType[P]>
        }
      >
    >


  export type UserSocialMediaSelect = {
    userId?: boolean
    type?: boolean
    link?: boolean
    user?: boolean | UserArgs
  }

  export type UserSocialMediaInclude = {
    user?: boolean | UserArgs
  }

  export type UserSocialMediaGetPayload<
    S extends boolean | null | undefined | UserSocialMediaArgs,
    U = keyof S
      > = S extends true
        ? UserSocialMedia
    : S extends undefined
    ? never
    : S extends UserSocialMediaArgs | UserSocialMediaFindManyArgs
    ?'include' extends U
    ? UserSocialMedia  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserSocialMedia ? UserSocialMedia[P] : never
  } 
    : UserSocialMedia
  : UserSocialMedia


  type UserSocialMediaCountArgs = Merge<
    Omit<UserSocialMediaFindManyArgs, 'select' | 'include'> & {
      select?: UserSocialMediaCountAggregateInputType | true
    }
  >

  export interface UserSocialMediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserSocialMedia that matches the filter.
     * @param {UserSocialMediaFindUniqueArgs} args - Arguments to find a UserSocialMedia
     * @example
     * // Get one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSocialMediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserSocialMediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserSocialMedia'> extends True ? CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia>, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T>>> : CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia | null >, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T> | null >>

    /**
     * Find the first UserSocialMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaFindFirstArgs} args - Arguments to find a UserSocialMedia
     * @example
     * // Get one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSocialMediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserSocialMediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserSocialMedia'> extends True ? CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia>, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T>>> : CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia | null >, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T> | null >>

    /**
     * Find zero or more UserSocialMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSocialMedias
     * const userSocialMedias = await prisma.userSocialMedia.findMany()
     * 
     * // Get first 10 UserSocialMedias
     * const userSocialMedias = await prisma.userSocialMedia.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSocialMediaWithUserIdOnly = await prisma.userSocialMedia.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserSocialMediaFindManyArgs>(
      args?: SelectSubset<T, UserSocialMediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserSocialMedia>>, PrismaPromise<Array<UserSocialMediaGetPayload<T>>>>

    /**
     * Create a UserSocialMedia.
     * @param {UserSocialMediaCreateArgs} args - Arguments to create a UserSocialMedia.
     * @example
     * // Create one UserSocialMedia
     * const UserSocialMedia = await prisma.userSocialMedia.create({
     *   data: {
     *     // ... data to create a UserSocialMedia
     *   }
     * })
     * 
    **/
    create<T extends UserSocialMediaCreateArgs>(
      args: SelectSubset<T, UserSocialMediaCreateArgs>
    ): CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia>, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T>>>

    /**
     * Create many UserSocialMedias.
     *     @param {UserSocialMediaCreateManyArgs} args - Arguments to create many UserSocialMedias.
     *     @example
     *     // Create many UserSocialMedias
     *     const userSocialMedia = await prisma.userSocialMedia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserSocialMediaCreateManyArgs>(
      args?: SelectSubset<T, UserSocialMediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserSocialMedia.
     * @param {UserSocialMediaDeleteArgs} args - Arguments to delete one UserSocialMedia.
     * @example
     * // Delete one UserSocialMedia
     * const UserSocialMedia = await prisma.userSocialMedia.delete({
     *   where: {
     *     // ... filter to delete one UserSocialMedia
     *   }
     * })
     * 
    **/
    delete<T extends UserSocialMediaDeleteArgs>(
      args: SelectSubset<T, UserSocialMediaDeleteArgs>
    ): CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia>, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T>>>

    /**
     * Update one UserSocialMedia.
     * @param {UserSocialMediaUpdateArgs} args - Arguments to update one UserSocialMedia.
     * @example
     * // Update one UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSocialMediaUpdateArgs>(
      args: SelectSubset<T, UserSocialMediaUpdateArgs>
    ): CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia>, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T>>>

    /**
     * Delete zero or more UserSocialMedias.
     * @param {UserSocialMediaDeleteManyArgs} args - Arguments to filter UserSocialMedias to delete.
     * @example
     * // Delete a few UserSocialMedias
     * const { count } = await prisma.userSocialMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSocialMediaDeleteManyArgs>(
      args?: SelectSubset<T, UserSocialMediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSocialMedias
     * const userSocialMedia = await prisma.userSocialMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSocialMediaUpdateManyArgs>(
      args: SelectSubset<T, UserSocialMediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSocialMedia.
     * @param {UserSocialMediaUpsertArgs} args - Arguments to update or create a UserSocialMedia.
     * @example
     * // Update or create a UserSocialMedia
     * const userSocialMedia = await prisma.userSocialMedia.upsert({
     *   create: {
     *     // ... data to create a UserSocialMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSocialMedia we want to update
     *   }
     * })
    **/
    upsert<T extends UserSocialMediaUpsertArgs>(
      args: SelectSubset<T, UserSocialMediaUpsertArgs>
    ): CheckSelect<T, Prisma__UserSocialMediaClient<UserSocialMedia>, Prisma__UserSocialMediaClient<UserSocialMediaGetPayload<T>>>

    /**
     * Count the number of UserSocialMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaCountArgs} args - Arguments to filter UserSocialMedias to count.
     * @example
     * // Count the number of UserSocialMedias
     * const count = await prisma.userSocialMedia.count({
     *   where: {
     *     // ... the filter for the UserSocialMedias we want to count
     *   }
     * })
    **/
    count<T extends UserSocialMediaCountArgs>(
      args?: Subset<T, UserSocialMediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSocialMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSocialMediaAggregateArgs>(args: Subset<T, UserSocialMediaAggregateArgs>): PrismaPromise<GetUserSocialMediaAggregateType<T>>

    /**
     * Group by UserSocialMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSocialMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSocialMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSocialMediaGroupByArgs['orderBy'] }
        : { orderBy?: UserSocialMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSocialMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSocialMediaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSocialMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserSocialMediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserSocialMedia findUnique
   */
  export type UserSocialMediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * Throw an Error if a UserSocialMedia can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSocialMedia to fetch.
     * 
    **/
    where: UserSocialMediaWhereUniqueInput
  }


  /**
   * UserSocialMedia findFirst
   */
  export type UserSocialMediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * Throw an Error if a UserSocialMedia can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSocialMedia to fetch.
     * 
    **/
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSocialMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSocialMedias.
     * 
    **/
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSocialMedias.
     * 
    **/
    distinct?: Enumerable<UserSocialMediaScalarFieldEnum>
  }


  /**
   * UserSocialMedia findMany
   */
  export type UserSocialMediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * Filter, which UserSocialMedias to fetch.
     * 
    **/
    where?: UserSocialMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSocialMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<UserSocialMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSocialMedias.
     * 
    **/
    cursor?: UserSocialMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSocialMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSocialMedias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserSocialMediaScalarFieldEnum>
  }


  /**
   * UserSocialMedia create
   */
  export type UserSocialMediaCreateArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * The data needed to create a UserSocialMedia.
     * 
    **/
    data: XOR<UserSocialMediaCreateInput, UserSocialMediaUncheckedCreateInput>
  }


  /**
   * UserSocialMedia createMany
   */
  export type UserSocialMediaCreateManyArgs = {
    /**
     * The data used to create many UserSocialMedias.
     * 
    **/
    data: Enumerable<UserSocialMediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserSocialMedia update
   */
  export type UserSocialMediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * The data needed to update a UserSocialMedia.
     * 
    **/
    data: XOR<UserSocialMediaUpdateInput, UserSocialMediaUncheckedUpdateInput>
    /**
     * Choose, which UserSocialMedia to update.
     * 
    **/
    where: UserSocialMediaWhereUniqueInput
  }


  /**
   * UserSocialMedia updateMany
   */
  export type UserSocialMediaUpdateManyArgs = {
    /**
     * The data used to update UserSocialMedias.
     * 
    **/
    data: XOR<UserSocialMediaUpdateManyMutationInput, UserSocialMediaUncheckedUpdateManyInput>
    /**
     * Filter which UserSocialMedias to update
     * 
    **/
    where?: UserSocialMediaWhereInput
  }


  /**
   * UserSocialMedia upsert
   */
  export type UserSocialMediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * The filter to search for the UserSocialMedia to update in case it exists.
     * 
    **/
    where: UserSocialMediaWhereUniqueInput
    /**
     * In case the UserSocialMedia found by the `where` argument doesn't exist, create a new UserSocialMedia with this data.
     * 
    **/
    create: XOR<UserSocialMediaCreateInput, UserSocialMediaUncheckedCreateInput>
    /**
     * In case the UserSocialMedia was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserSocialMediaUpdateInput, UserSocialMediaUncheckedUpdateInput>
  }


  /**
   * UserSocialMedia delete
   */
  export type UserSocialMediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
    /**
     * Filter which UserSocialMedia to delete.
     * 
    **/
    where: UserSocialMediaWhereUniqueInput
  }


  /**
   * UserSocialMedia deleteMany
   */
  export type UserSocialMediaDeleteManyArgs = {
    /**
     * Filter which UserSocialMedias to delete
     * 
    **/
    where?: UserSocialMediaWhereInput
  }


  /**
   * UserSocialMedia without action
   */
  export type UserSocialMediaArgs = {
    /**
     * Select specific fields to fetch from the UserSocialMedia
     * 
    **/
    select?: UserSocialMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserSocialMediaInclude | null
  }



  /**
   * Model UserLocation
   */


  export type AggregateUserLocation = {
    _count: UserLocationCountAggregateOutputType | null
    _min: UserLocationMinAggregateOutputType | null
    _max: UserLocationMaxAggregateOutputType | null
  }

  export type UserLocationMinAggregateOutputType = {
    userId: string | null
    location: string | null
  }

  export type UserLocationMaxAggregateOutputType = {
    userId: string | null
    location: string | null
  }

  export type UserLocationCountAggregateOutputType = {
    userId: number
    location: number
    _all: number
  }


  export type UserLocationMinAggregateInputType = {
    userId?: true
    location?: true
  }

  export type UserLocationMaxAggregateInputType = {
    userId?: true
    location?: true
  }

  export type UserLocationCountAggregateInputType = {
    userId?: true
    location?: true
    _all?: true
  }

  export type UserLocationAggregateArgs = {
    /**
     * Filter which UserLocation to aggregate.
     * 
    **/
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<UserLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLocations
    **/
    _count?: true | UserLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLocationMaxAggregateInputType
  }

  export type GetUserLocationAggregateType<T extends UserLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLocation[P]>
      : GetScalarType<T[P], AggregateUserLocation[P]>
  }




  export type UserLocationGroupByArgs = {
    where?: UserLocationWhereInput
    orderBy?: Enumerable<UserLocationOrderByWithAggregationInput>
    by: Array<UserLocationScalarFieldEnum>
    having?: UserLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLocationCountAggregateInputType | true
    _min?: UserLocationMinAggregateInputType
    _max?: UserLocationMaxAggregateInputType
  }


  export type UserLocationGroupByOutputType = {
    userId: string
    location: string
    _count: UserLocationCountAggregateOutputType | null
    _min: UserLocationMinAggregateOutputType | null
    _max: UserLocationMaxAggregateOutputType | null
  }

  type GetUserLocationGroupByPayload<T extends UserLocationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLocationGroupByOutputType[P]>
            : GetScalarType<T[P], UserLocationGroupByOutputType[P]>
        }
      >
    >


  export type UserLocationSelect = {
    userId?: boolean
    location?: boolean
    user?: boolean | UserArgs
  }

  export type UserLocationInclude = {
    user?: boolean | UserArgs
  }

  export type UserLocationGetPayload<
    S extends boolean | null | undefined | UserLocationArgs,
    U = keyof S
      > = S extends true
        ? UserLocation
    : S extends undefined
    ? never
    : S extends UserLocationArgs | UserLocationFindManyArgs
    ?'include' extends U
    ? UserLocation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserLocation ? UserLocation[P] : never
  } 
    : UserLocation
  : UserLocation


  type UserLocationCountArgs = Merge<
    Omit<UserLocationFindManyArgs, 'select' | 'include'> & {
      select?: UserLocationCountAggregateInputType | true
    }
  >

  export interface UserLocationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserLocation that matches the filter.
     * @param {UserLocationFindUniqueArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserLocationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserLocationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserLocation'> extends True ? CheckSelect<T, Prisma__UserLocationClient<UserLocation>, Prisma__UserLocationClient<UserLocationGetPayload<T>>> : CheckSelect<T, Prisma__UserLocationClient<UserLocation | null >, Prisma__UserLocationClient<UserLocationGetPayload<T> | null >>

    /**
     * Find the first UserLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindFirstArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserLocationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserLocationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserLocation'> extends True ? CheckSelect<T, Prisma__UserLocationClient<UserLocation>, Prisma__UserLocationClient<UserLocationGetPayload<T>>> : CheckSelect<T, Prisma__UserLocationClient<UserLocation | null >, Prisma__UserLocationClient<UserLocationGetPayload<T> | null >>

    /**
     * Find zero or more UserLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLocations
     * const userLocations = await prisma.userLocation.findMany()
     * 
     * // Get first 10 UserLocations
     * const userLocations = await prisma.userLocation.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userLocationWithUserIdOnly = await prisma.userLocation.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserLocationFindManyArgs>(
      args?: SelectSubset<T, UserLocationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserLocation>>, PrismaPromise<Array<UserLocationGetPayload<T>>>>

    /**
     * Create a UserLocation.
     * @param {UserLocationCreateArgs} args - Arguments to create a UserLocation.
     * @example
     * // Create one UserLocation
     * const UserLocation = await prisma.userLocation.create({
     *   data: {
     *     // ... data to create a UserLocation
     *   }
     * })
     * 
    **/
    create<T extends UserLocationCreateArgs>(
      args: SelectSubset<T, UserLocationCreateArgs>
    ): CheckSelect<T, Prisma__UserLocationClient<UserLocation>, Prisma__UserLocationClient<UserLocationGetPayload<T>>>

    /**
     * Create many UserLocations.
     *     @param {UserLocationCreateManyArgs} args - Arguments to create many UserLocations.
     *     @example
     *     // Create many UserLocations
     *     const userLocation = await prisma.userLocation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserLocationCreateManyArgs>(
      args?: SelectSubset<T, UserLocationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserLocation.
     * @param {UserLocationDeleteArgs} args - Arguments to delete one UserLocation.
     * @example
     * // Delete one UserLocation
     * const UserLocation = await prisma.userLocation.delete({
     *   where: {
     *     // ... filter to delete one UserLocation
     *   }
     * })
     * 
    **/
    delete<T extends UserLocationDeleteArgs>(
      args: SelectSubset<T, UserLocationDeleteArgs>
    ): CheckSelect<T, Prisma__UserLocationClient<UserLocation>, Prisma__UserLocationClient<UserLocationGetPayload<T>>>

    /**
     * Update one UserLocation.
     * @param {UserLocationUpdateArgs} args - Arguments to update one UserLocation.
     * @example
     * // Update one UserLocation
     * const userLocation = await prisma.userLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserLocationUpdateArgs>(
      args: SelectSubset<T, UserLocationUpdateArgs>
    ): CheckSelect<T, Prisma__UserLocationClient<UserLocation>, Prisma__UserLocationClient<UserLocationGetPayload<T>>>

    /**
     * Delete zero or more UserLocations.
     * @param {UserLocationDeleteManyArgs} args - Arguments to filter UserLocations to delete.
     * @example
     * // Delete a few UserLocations
     * const { count } = await prisma.userLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserLocationDeleteManyArgs>(
      args?: SelectSubset<T, UserLocationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLocations
     * const userLocation = await prisma.userLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserLocationUpdateManyArgs>(
      args: SelectSubset<T, UserLocationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLocation.
     * @param {UserLocationUpsertArgs} args - Arguments to update or create a UserLocation.
     * @example
     * // Update or create a UserLocation
     * const userLocation = await prisma.userLocation.upsert({
     *   create: {
     *     // ... data to create a UserLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLocation we want to update
     *   }
     * })
    **/
    upsert<T extends UserLocationUpsertArgs>(
      args: SelectSubset<T, UserLocationUpsertArgs>
    ): CheckSelect<T, Prisma__UserLocationClient<UserLocation>, Prisma__UserLocationClient<UserLocationGetPayload<T>>>

    /**
     * Count the number of UserLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationCountArgs} args - Arguments to filter UserLocations to count.
     * @example
     * // Count the number of UserLocations
     * const count = await prisma.userLocation.count({
     *   where: {
     *     // ... the filter for the UserLocations we want to count
     *   }
     * })
    **/
    count<T extends UserLocationCountArgs>(
      args?: Subset<T, UserLocationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLocationAggregateArgs>(args: Subset<T, UserLocationAggregateArgs>): PrismaPromise<GetUserLocationAggregateType<T>>

    /**
     * Group by UserLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLocationGroupByArgs['orderBy'] }
        : { orderBy?: UserLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLocationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserLocationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserLocation findUnique
   */
  export type UserLocationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * Throw an Error if a UserLocation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserLocation to fetch.
     * 
    **/
    where: UserLocationWhereUniqueInput
  }


  /**
   * UserLocation findFirst
   */
  export type UserLocationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * Throw an Error if a UserLocation can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserLocation to fetch.
     * 
    **/
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<UserLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLocations.
     * 
    **/
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLocations.
     * 
    **/
    distinct?: Enumerable<UserLocationScalarFieldEnum>
  }


  /**
   * UserLocation findMany
   */
  export type UserLocationFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * Filter, which UserLocations to fetch.
     * 
    **/
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     * 
    **/
    orderBy?: Enumerable<UserLocationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLocations.
     * 
    **/
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserLocationScalarFieldEnum>
  }


  /**
   * UserLocation create
   */
  export type UserLocationCreateArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * The data needed to create a UserLocation.
     * 
    **/
    data: XOR<UserLocationCreateInput, UserLocationUncheckedCreateInput>
  }


  /**
   * UserLocation createMany
   */
  export type UserLocationCreateManyArgs = {
    /**
     * The data used to create many UserLocations.
     * 
    **/
    data: Enumerable<UserLocationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserLocation update
   */
  export type UserLocationUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * The data needed to update a UserLocation.
     * 
    **/
    data: XOR<UserLocationUpdateInput, UserLocationUncheckedUpdateInput>
    /**
     * Choose, which UserLocation to update.
     * 
    **/
    where: UserLocationWhereUniqueInput
  }


  /**
   * UserLocation updateMany
   */
  export type UserLocationUpdateManyArgs = {
    /**
     * The data used to update UserLocations.
     * 
    **/
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyInput>
    /**
     * Filter which UserLocations to update
     * 
    **/
    where?: UserLocationWhereInput
  }


  /**
   * UserLocation upsert
   */
  export type UserLocationUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * The filter to search for the UserLocation to update in case it exists.
     * 
    **/
    where: UserLocationWhereUniqueInput
    /**
     * In case the UserLocation found by the `where` argument doesn't exist, create a new UserLocation with this data.
     * 
    **/
    create: XOR<UserLocationCreateInput, UserLocationUncheckedCreateInput>
    /**
     * In case the UserLocation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserLocationUpdateInput, UserLocationUncheckedUpdateInput>
  }


  /**
   * UserLocation delete
   */
  export type UserLocationDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
    /**
     * Filter which UserLocation to delete.
     * 
    **/
    where: UserLocationWhereUniqueInput
  }


  /**
   * UserLocation deleteMany
   */
  export type UserLocationDeleteManyArgs = {
    /**
     * Filter which UserLocations to delete
     * 
    **/
    where?: UserLocationWhereInput
  }


  /**
   * UserLocation without action
   */
  export type UserLocationArgs = {
    /**
     * Select specific fields to fetch from the UserLocation
     * 
    **/
    select?: UserLocationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserLocationInclude | null
  }



  /**
   * Model UserEmail
   */


  export type AggregateUserEmail = {
    _count: UserEmailCountAggregateOutputType | null
    _min: UserEmailMinAggregateOutputType | null
    _max: UserEmailMaxAggregateOutputType | null
  }

  export type UserEmailMinAggregateOutputType = {
    userId: string | null
    email: string | null
  }

  export type UserEmailMaxAggregateOutputType = {
    userId: string | null
    email: string | null
  }

  export type UserEmailCountAggregateOutputType = {
    userId: number
    email: number
    _all: number
  }


  export type UserEmailMinAggregateInputType = {
    userId?: true
    email?: true
  }

  export type UserEmailMaxAggregateInputType = {
    userId?: true
    email?: true
  }

  export type UserEmailCountAggregateInputType = {
    userId?: true
    email?: true
    _all?: true
  }

  export type UserEmailAggregateArgs = {
    /**
     * Filter which UserEmail to aggregate.
     * 
    **/
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     * 
    **/
    orderBy?: Enumerable<UserEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEmails
    **/
    _count?: true | UserEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEmailMaxAggregateInputType
  }

  export type GetUserEmailAggregateType<T extends UserEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEmail[P]>
      : GetScalarType<T[P], AggregateUserEmail[P]>
  }




  export type UserEmailGroupByArgs = {
    where?: UserEmailWhereInput
    orderBy?: Enumerable<UserEmailOrderByWithAggregationInput>
    by: Array<UserEmailScalarFieldEnum>
    having?: UserEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEmailCountAggregateInputType | true
    _min?: UserEmailMinAggregateInputType
    _max?: UserEmailMaxAggregateInputType
  }


  export type UserEmailGroupByOutputType = {
    userId: string
    email: string
    _count: UserEmailCountAggregateOutputType | null
    _min: UserEmailMinAggregateOutputType | null
    _max: UserEmailMaxAggregateOutputType | null
  }

  type GetUserEmailGroupByPayload<T extends UserEmailGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEmailGroupByOutputType[P]>
            : GetScalarType<T[P], UserEmailGroupByOutputType[P]>
        }
      >
    >


  export type UserEmailSelect = {
    userId?: boolean
    email?: boolean
    user?: boolean | UserArgs
  }

  export type UserEmailInclude = {
    user?: boolean | UserArgs
  }

  export type UserEmailGetPayload<
    S extends boolean | null | undefined | UserEmailArgs,
    U = keyof S
      > = S extends true
        ? UserEmail
    : S extends undefined
    ? never
    : S extends UserEmailArgs | UserEmailFindManyArgs
    ?'include' extends U
    ? UserEmail  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserEmail ? UserEmail[P] : never
  } 
    : UserEmail
  : UserEmail


  type UserEmailCountArgs = Merge<
    Omit<UserEmailFindManyArgs, 'select' | 'include'> & {
      select?: UserEmailCountAggregateInputType | true
    }
  >

  export interface UserEmailDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserEmail that matches the filter.
     * @param {UserEmailFindUniqueArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserEmailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserEmailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserEmail'> extends True ? CheckSelect<T, Prisma__UserEmailClient<UserEmail>, Prisma__UserEmailClient<UserEmailGetPayload<T>>> : CheckSelect<T, Prisma__UserEmailClient<UserEmail | null >, Prisma__UserEmailClient<UserEmailGetPayload<T> | null >>

    /**
     * Find the first UserEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindFirstArgs} args - Arguments to find a UserEmail
     * @example
     * // Get one UserEmail
     * const userEmail = await prisma.userEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserEmailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserEmailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserEmail'> extends True ? CheckSelect<T, Prisma__UserEmailClient<UserEmail>, Prisma__UserEmailClient<UserEmailGetPayload<T>>> : CheckSelect<T, Prisma__UserEmailClient<UserEmail | null >, Prisma__UserEmailClient<UserEmailGetPayload<T> | null >>

    /**
     * Find zero or more UserEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEmails
     * const userEmails = await prisma.userEmail.findMany()
     * 
     * // Get first 10 UserEmails
     * const userEmails = await prisma.userEmail.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userEmailWithUserIdOnly = await prisma.userEmail.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserEmailFindManyArgs>(
      args?: SelectSubset<T, UserEmailFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserEmail>>, PrismaPromise<Array<UserEmailGetPayload<T>>>>

    /**
     * Create a UserEmail.
     * @param {UserEmailCreateArgs} args - Arguments to create a UserEmail.
     * @example
     * // Create one UserEmail
     * const UserEmail = await prisma.userEmail.create({
     *   data: {
     *     // ... data to create a UserEmail
     *   }
     * })
     * 
    **/
    create<T extends UserEmailCreateArgs>(
      args: SelectSubset<T, UserEmailCreateArgs>
    ): CheckSelect<T, Prisma__UserEmailClient<UserEmail>, Prisma__UserEmailClient<UserEmailGetPayload<T>>>

    /**
     * Create many UserEmails.
     *     @param {UserEmailCreateManyArgs} args - Arguments to create many UserEmails.
     *     @example
     *     // Create many UserEmails
     *     const userEmail = await prisma.userEmail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserEmailCreateManyArgs>(
      args?: SelectSubset<T, UserEmailCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserEmail.
     * @param {UserEmailDeleteArgs} args - Arguments to delete one UserEmail.
     * @example
     * // Delete one UserEmail
     * const UserEmail = await prisma.userEmail.delete({
     *   where: {
     *     // ... filter to delete one UserEmail
     *   }
     * })
     * 
    **/
    delete<T extends UserEmailDeleteArgs>(
      args: SelectSubset<T, UserEmailDeleteArgs>
    ): CheckSelect<T, Prisma__UserEmailClient<UserEmail>, Prisma__UserEmailClient<UserEmailGetPayload<T>>>

    /**
     * Update one UserEmail.
     * @param {UserEmailUpdateArgs} args - Arguments to update one UserEmail.
     * @example
     * // Update one UserEmail
     * const userEmail = await prisma.userEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserEmailUpdateArgs>(
      args: SelectSubset<T, UserEmailUpdateArgs>
    ): CheckSelect<T, Prisma__UserEmailClient<UserEmail>, Prisma__UserEmailClient<UserEmailGetPayload<T>>>

    /**
     * Delete zero or more UserEmails.
     * @param {UserEmailDeleteManyArgs} args - Arguments to filter UserEmails to delete.
     * @example
     * // Delete a few UserEmails
     * const { count } = await prisma.userEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserEmailDeleteManyArgs>(
      args?: SelectSubset<T, UserEmailDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEmails
     * const userEmail = await prisma.userEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserEmailUpdateManyArgs>(
      args: SelectSubset<T, UserEmailUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserEmail.
     * @param {UserEmailUpsertArgs} args - Arguments to update or create a UserEmail.
     * @example
     * // Update or create a UserEmail
     * const userEmail = await prisma.userEmail.upsert({
     *   create: {
     *     // ... data to create a UserEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEmail we want to update
     *   }
     * })
    **/
    upsert<T extends UserEmailUpsertArgs>(
      args: SelectSubset<T, UserEmailUpsertArgs>
    ): CheckSelect<T, Prisma__UserEmailClient<UserEmail>, Prisma__UserEmailClient<UserEmailGetPayload<T>>>

    /**
     * Count the number of UserEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailCountArgs} args - Arguments to filter UserEmails to count.
     * @example
     * // Count the number of UserEmails
     * const count = await prisma.userEmail.count({
     *   where: {
     *     // ... the filter for the UserEmails we want to count
     *   }
     * })
    **/
    count<T extends UserEmailCountArgs>(
      args?: Subset<T, UserEmailCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEmailAggregateArgs>(args: Subset<T, UserEmailAggregateArgs>): PrismaPromise<GetUserEmailAggregateType<T>>

    /**
     * Group by UserEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEmailGroupByArgs['orderBy'] }
        : { orderBy?: UserEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEmailGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserEmailClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserEmail findUnique
   */
  export type UserEmailFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * Throw an Error if a UserEmail can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserEmail to fetch.
     * 
    **/
    where: UserEmailWhereUniqueInput
  }


  /**
   * UserEmail findFirst
   */
  export type UserEmailFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * Throw an Error if a UserEmail can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserEmail to fetch.
     * 
    **/
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     * 
    **/
    orderBy?: Enumerable<UserEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEmails.
     * 
    **/
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEmails.
     * 
    **/
    distinct?: Enumerable<UserEmailScalarFieldEnum>
  }


  /**
   * UserEmail findMany
   */
  export type UserEmailFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * Filter, which UserEmails to fetch.
     * 
    **/
    where?: UserEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEmails to fetch.
     * 
    **/
    orderBy?: Enumerable<UserEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEmails.
     * 
    **/
    cursor?: UserEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEmails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEmails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserEmailScalarFieldEnum>
  }


  /**
   * UserEmail create
   */
  export type UserEmailCreateArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * The data needed to create a UserEmail.
     * 
    **/
    data: XOR<UserEmailCreateInput, UserEmailUncheckedCreateInput>
  }


  /**
   * UserEmail createMany
   */
  export type UserEmailCreateManyArgs = {
    /**
     * The data used to create many UserEmails.
     * 
    **/
    data: Enumerable<UserEmailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserEmail update
   */
  export type UserEmailUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * The data needed to update a UserEmail.
     * 
    **/
    data: XOR<UserEmailUpdateInput, UserEmailUncheckedUpdateInput>
    /**
     * Choose, which UserEmail to update.
     * 
    **/
    where: UserEmailWhereUniqueInput
  }


  /**
   * UserEmail updateMany
   */
  export type UserEmailUpdateManyArgs = {
    /**
     * The data used to update UserEmails.
     * 
    **/
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyInput>
    /**
     * Filter which UserEmails to update
     * 
    **/
    where?: UserEmailWhereInput
  }


  /**
   * UserEmail upsert
   */
  export type UserEmailUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * The filter to search for the UserEmail to update in case it exists.
     * 
    **/
    where: UserEmailWhereUniqueInput
    /**
     * In case the UserEmail found by the `where` argument doesn't exist, create a new UserEmail with this data.
     * 
    **/
    create: XOR<UserEmailCreateInput, UserEmailUncheckedCreateInput>
    /**
     * In case the UserEmail was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserEmailUpdateInput, UserEmailUncheckedUpdateInput>
  }


  /**
   * UserEmail delete
   */
  export type UserEmailDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
    /**
     * Filter which UserEmail to delete.
     * 
    **/
    where: UserEmailWhereUniqueInput
  }


  /**
   * UserEmail deleteMany
   */
  export type UserEmailDeleteManyArgs = {
    /**
     * Filter which UserEmails to delete
     * 
    **/
    where?: UserEmailWhereInput
  }


  /**
   * UserEmail without action
   */
  export type UserEmailArgs = {
    /**
     * Select specific fields to fetch from the UserEmail
     * 
    **/
    select?: UserEmailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserEmailInclude | null
  }



  /**
   * Model UserProfileFile
   */


  export type AggregateUserProfileFile = {
    _count: UserProfileFileCountAggregateOutputType | null
    _min: UserProfileFileMinAggregateOutputType | null
    _max: UserProfileFileMaxAggregateOutputType | null
  }

  export type UserProfileFileMinAggregateOutputType = {
    fileId: string | null
    userId: string | null
    filePath: string | null
    fileCategory: FileCategory | null
    fileExtension: string | null
  }

  export type UserProfileFileMaxAggregateOutputType = {
    fileId: string | null
    userId: string | null
    filePath: string | null
    fileCategory: FileCategory | null
    fileExtension: string | null
  }

  export type UserProfileFileCountAggregateOutputType = {
    fileId: number
    userId: number
    filePath: number
    fileCategory: number
    fileExtension: number
    _all: number
  }


  export type UserProfileFileMinAggregateInputType = {
    fileId?: true
    userId?: true
    filePath?: true
    fileCategory?: true
    fileExtension?: true
  }

  export type UserProfileFileMaxAggregateInputType = {
    fileId?: true
    userId?: true
    filePath?: true
    fileCategory?: true
    fileExtension?: true
  }

  export type UserProfileFileCountAggregateInputType = {
    fileId?: true
    userId?: true
    filePath?: true
    fileCategory?: true
    fileExtension?: true
    _all?: true
  }

  export type UserProfileFileAggregateArgs = {
    /**
     * Filter which UserProfileFile to aggregate.
     * 
    **/
    where?: UserProfileFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileFileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserProfileFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfileFiles
    **/
    _count?: true | UserProfileFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileFileMaxAggregateInputType
  }

  export type GetUserProfileFileAggregateType<T extends UserProfileFileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfileFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfileFile[P]>
      : GetScalarType<T[P], AggregateUserProfileFile[P]>
  }




  export type UserProfileFileGroupByArgs = {
    where?: UserProfileFileWhereInput
    orderBy?: Enumerable<UserProfileFileOrderByWithAggregationInput>
    by: Array<UserProfileFileScalarFieldEnum>
    having?: UserProfileFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileFileCountAggregateInputType | true
    _min?: UserProfileFileMinAggregateInputType
    _max?: UserProfileFileMaxAggregateInputType
  }


  export type UserProfileFileGroupByOutputType = {
    fileId: string
    userId: string
    filePath: string
    fileCategory: FileCategory | null
    fileExtension: string | null
    _count: UserProfileFileCountAggregateOutputType | null
    _min: UserProfileFileMinAggregateOutputType | null
    _max: UserProfileFileMaxAggregateOutputType | null
  }

  type GetUserProfileFileGroupByPayload<T extends UserProfileFileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserProfileFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileFileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileFileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileFileSelect = {
    fileId?: boolean
    userId?: boolean
    filePath?: boolean
    fileCategory?: boolean
    fileExtension?: boolean
    user?: boolean | UserArgs
  }

  export type UserProfileFileInclude = {
    user?: boolean | UserArgs
  }

  export type UserProfileFileGetPayload<
    S extends boolean | null | undefined | UserProfileFileArgs,
    U = keyof S
      > = S extends true
        ? UserProfileFile
    : S extends undefined
    ? never
    : S extends UserProfileFileArgs | UserProfileFileFindManyArgs
    ?'include' extends U
    ? UserProfileFile  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserProfileFile ? UserProfileFile[P] : never
  } 
    : UserProfileFile
  : UserProfileFile


  type UserProfileFileCountArgs = Merge<
    Omit<UserProfileFileFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileFileCountAggregateInputType | true
    }
  >

  export interface UserProfileFileDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserProfileFile that matches the filter.
     * @param {UserProfileFileFindUniqueArgs} args - Arguments to find a UserProfileFile
     * @example
     * // Get one UserProfileFile
     * const userProfileFile = await prisma.userProfileFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileFileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserProfileFileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserProfileFile'> extends True ? CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile>, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T>>> : CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile | null >, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T> | null >>

    /**
     * Find the first UserProfileFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFileFindFirstArgs} args - Arguments to find a UserProfileFile
     * @example
     * // Get one UserProfileFile
     * const userProfileFile = await prisma.userProfileFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileFileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserProfileFileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserProfileFile'> extends True ? CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile>, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T>>> : CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile | null >, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T> | null >>

    /**
     * Find zero or more UserProfileFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfileFiles
     * const userProfileFiles = await prisma.userProfileFile.findMany()
     * 
     * // Get first 10 UserProfileFiles
     * const userProfileFiles = await prisma.userProfileFile.findMany({ take: 10 })
     * 
     * // Only select the `fileId`
     * const userProfileFileWithFileIdOnly = await prisma.userProfileFile.findMany({ select: { fileId: true } })
     * 
    **/
    findMany<T extends UserProfileFileFindManyArgs>(
      args?: SelectSubset<T, UserProfileFileFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserProfileFile>>, PrismaPromise<Array<UserProfileFileGetPayload<T>>>>

    /**
     * Create a UserProfileFile.
     * @param {UserProfileFileCreateArgs} args - Arguments to create a UserProfileFile.
     * @example
     * // Create one UserProfileFile
     * const UserProfileFile = await prisma.userProfileFile.create({
     *   data: {
     *     // ... data to create a UserProfileFile
     *   }
     * })
     * 
    **/
    create<T extends UserProfileFileCreateArgs>(
      args: SelectSubset<T, UserProfileFileCreateArgs>
    ): CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile>, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T>>>

    /**
     * Create many UserProfileFiles.
     *     @param {UserProfileFileCreateManyArgs} args - Arguments to create many UserProfileFiles.
     *     @example
     *     // Create many UserProfileFiles
     *     const userProfileFile = await prisma.userProfileFile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileFileCreateManyArgs>(
      args?: SelectSubset<T, UserProfileFileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfileFile.
     * @param {UserProfileFileDeleteArgs} args - Arguments to delete one UserProfileFile.
     * @example
     * // Delete one UserProfileFile
     * const UserProfileFile = await prisma.userProfileFile.delete({
     *   where: {
     *     // ... filter to delete one UserProfileFile
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileFileDeleteArgs>(
      args: SelectSubset<T, UserProfileFileDeleteArgs>
    ): CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile>, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T>>>

    /**
     * Update one UserProfileFile.
     * @param {UserProfileFileUpdateArgs} args - Arguments to update one UserProfileFile.
     * @example
     * // Update one UserProfileFile
     * const userProfileFile = await prisma.userProfileFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileFileUpdateArgs>(
      args: SelectSubset<T, UserProfileFileUpdateArgs>
    ): CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile>, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T>>>

    /**
     * Delete zero or more UserProfileFiles.
     * @param {UserProfileFileDeleteManyArgs} args - Arguments to filter UserProfileFiles to delete.
     * @example
     * // Delete a few UserProfileFiles
     * const { count } = await prisma.userProfileFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileFileDeleteManyArgs>(
      args?: SelectSubset<T, UserProfileFileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfileFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfileFiles
     * const userProfileFile = await prisma.userProfileFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileFileUpdateManyArgs>(
      args: SelectSubset<T, UserProfileFileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfileFile.
     * @param {UserProfileFileUpsertArgs} args - Arguments to update or create a UserProfileFile.
     * @example
     * // Update or create a UserProfileFile
     * const userProfileFile = await prisma.userProfileFile.upsert({
     *   create: {
     *     // ... data to create a UserProfileFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfileFile we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileFileUpsertArgs>(
      args: SelectSubset<T, UserProfileFileUpsertArgs>
    ): CheckSelect<T, Prisma__UserProfileFileClient<UserProfileFile>, Prisma__UserProfileFileClient<UserProfileFileGetPayload<T>>>

    /**
     * Count the number of UserProfileFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFileCountArgs} args - Arguments to filter UserProfileFiles to count.
     * @example
     * // Count the number of UserProfileFiles
     * const count = await prisma.userProfileFile.count({
     *   where: {
     *     // ... the filter for the UserProfileFiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileFileCountArgs>(
      args?: Subset<T, UserProfileFileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfileFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileFileAggregateArgs>(args: Subset<T, UserProfileFileAggregateArgs>): PrismaPromise<GetUserProfileFileAggregateType<T>>

    /**
     * Group by UserProfileFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileFileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileFileGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfileFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileFileClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserProfileFile findUnique
   */
  export type UserProfileFileFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * Throw an Error if a UserProfileFile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserProfileFile to fetch.
     * 
    **/
    where: UserProfileFileWhereUniqueInput
  }


  /**
   * UserProfileFile findFirst
   */
  export type UserProfileFileFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * Throw an Error if a UserProfileFile can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserProfileFile to fetch.
     * 
    **/
    where?: UserProfileFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileFileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfileFiles.
     * 
    **/
    cursor?: UserProfileFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfileFiles.
     * 
    **/
    distinct?: Enumerable<UserProfileFileScalarFieldEnum>
  }


  /**
   * UserProfileFile findMany
   */
  export type UserProfileFileFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * Filter, which UserProfileFiles to fetch.
     * 
    **/
    where?: UserProfileFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfileFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UserProfileFileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfileFiles.
     * 
    **/
    cursor?: UserProfileFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfileFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfileFiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserProfileFileScalarFieldEnum>
  }


  /**
   * UserProfileFile create
   */
  export type UserProfileFileCreateArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * The data needed to create a UserProfileFile.
     * 
    **/
    data: XOR<UserProfileFileCreateInput, UserProfileFileUncheckedCreateInput>
  }


  /**
   * UserProfileFile createMany
   */
  export type UserProfileFileCreateManyArgs = {
    /**
     * The data used to create many UserProfileFiles.
     * 
    **/
    data: Enumerable<UserProfileFileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserProfileFile update
   */
  export type UserProfileFileUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * The data needed to update a UserProfileFile.
     * 
    **/
    data: XOR<UserProfileFileUpdateInput, UserProfileFileUncheckedUpdateInput>
    /**
     * Choose, which UserProfileFile to update.
     * 
    **/
    where: UserProfileFileWhereUniqueInput
  }


  /**
   * UserProfileFile updateMany
   */
  export type UserProfileFileUpdateManyArgs = {
    /**
     * The data used to update UserProfileFiles.
     * 
    **/
    data: XOR<UserProfileFileUpdateManyMutationInput, UserProfileFileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfileFiles to update
     * 
    **/
    where?: UserProfileFileWhereInput
  }


  /**
   * UserProfileFile upsert
   */
  export type UserProfileFileUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * The filter to search for the UserProfileFile to update in case it exists.
     * 
    **/
    where: UserProfileFileWhereUniqueInput
    /**
     * In case the UserProfileFile found by the `where` argument doesn't exist, create a new UserProfileFile with this data.
     * 
    **/
    create: XOR<UserProfileFileCreateInput, UserProfileFileUncheckedCreateInput>
    /**
     * In case the UserProfileFile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserProfileFileUpdateInput, UserProfileFileUncheckedUpdateInput>
  }


  /**
   * UserProfileFile delete
   */
  export type UserProfileFileDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
    /**
     * Filter which UserProfileFile to delete.
     * 
    **/
    where: UserProfileFileWhereUniqueInput
  }


  /**
   * UserProfileFile deleteMany
   */
  export type UserProfileFileDeleteManyArgs = {
    /**
     * Filter which UserProfileFiles to delete
     * 
    **/
    where?: UserProfileFileWhereInput
  }


  /**
   * UserProfileFile without action
   */
  export type UserProfileFileArgs = {
    /**
     * Select specific fields to fetch from the UserProfileFile
     * 
    **/
    select?: UserProfileFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserProfileFileInclude | null
  }



  /**
   * Model UserDegree
   */


  export type AggregateUserDegree = {
    _count: UserDegreeCountAggregateOutputType | null
    _min: UserDegreeMinAggregateOutputType | null
    _max: UserDegreeMaxAggregateOutputType | null
  }

  export type UserDegreeMinAggregateOutputType = {
    userID: string | null
    degreeType: string | null
    degreeName: string | null
  }

  export type UserDegreeMaxAggregateOutputType = {
    userID: string | null
    degreeType: string | null
    degreeName: string | null
  }

  export type UserDegreeCountAggregateOutputType = {
    userID: number
    degreeType: number
    degreeName: number
    _all: number
  }


  export type UserDegreeMinAggregateInputType = {
    userID?: true
    degreeType?: true
    degreeName?: true
  }

  export type UserDegreeMaxAggregateInputType = {
    userID?: true
    degreeType?: true
    degreeName?: true
  }

  export type UserDegreeCountAggregateInputType = {
    userID?: true
    degreeType?: true
    degreeName?: true
    _all?: true
  }

  export type UserDegreeAggregateArgs = {
    /**
     * Filter which UserDegree to aggregate.
     * 
    **/
    where?: UserDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDegrees to fetch.
     * 
    **/
    orderBy?: Enumerable<UserDegreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDegrees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDegrees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDegrees
    **/
    _count?: true | UserDegreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDegreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDegreeMaxAggregateInputType
  }

  export type GetUserDegreeAggregateType<T extends UserDegreeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDegree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDegree[P]>
      : GetScalarType<T[P], AggregateUserDegree[P]>
  }




  export type UserDegreeGroupByArgs = {
    where?: UserDegreeWhereInput
    orderBy?: Enumerable<UserDegreeOrderByWithAggregationInput>
    by: Array<UserDegreeScalarFieldEnum>
    having?: UserDegreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDegreeCountAggregateInputType | true
    _min?: UserDegreeMinAggregateInputType
    _max?: UserDegreeMaxAggregateInputType
  }


  export type UserDegreeGroupByOutputType = {
    userID: string
    degreeType: string
    degreeName: string
    _count: UserDegreeCountAggregateOutputType | null
    _min: UserDegreeMinAggregateOutputType | null
    _max: UserDegreeMaxAggregateOutputType | null
  }

  type GetUserDegreeGroupByPayload<T extends UserDegreeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserDegreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDegreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDegreeGroupByOutputType[P]>
            : GetScalarType<T[P], UserDegreeGroupByOutputType[P]>
        }
      >
    >


  export type UserDegreeSelect = {
    userID?: boolean
    degreeType?: boolean
    degreeName?: boolean
    user?: boolean | UserArgs
  }

  export type UserDegreeInclude = {
    user?: boolean | UserArgs
  }

  export type UserDegreeGetPayload<
    S extends boolean | null | undefined | UserDegreeArgs,
    U = keyof S
      > = S extends true
        ? UserDegree
    : S extends undefined
    ? never
    : S extends UserDegreeArgs | UserDegreeFindManyArgs
    ?'include' extends U
    ? UserDegree  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserDegree ? UserDegree[P] : never
  } 
    : UserDegree
  : UserDegree


  type UserDegreeCountArgs = Merge<
    Omit<UserDegreeFindManyArgs, 'select' | 'include'> & {
      select?: UserDegreeCountAggregateInputType | true
    }
  >

  export interface UserDegreeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserDegree that matches the filter.
     * @param {UserDegreeFindUniqueArgs} args - Arguments to find a UserDegree
     * @example
     * // Get one UserDegree
     * const userDegree = await prisma.userDegree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserDegreeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserDegreeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserDegree'> extends True ? CheckSelect<T, Prisma__UserDegreeClient<UserDegree>, Prisma__UserDegreeClient<UserDegreeGetPayload<T>>> : CheckSelect<T, Prisma__UserDegreeClient<UserDegree | null >, Prisma__UserDegreeClient<UserDegreeGetPayload<T> | null >>

    /**
     * Find the first UserDegree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDegreeFindFirstArgs} args - Arguments to find a UserDegree
     * @example
     * // Get one UserDegree
     * const userDegree = await prisma.userDegree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserDegreeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserDegreeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserDegree'> extends True ? CheckSelect<T, Prisma__UserDegreeClient<UserDegree>, Prisma__UserDegreeClient<UserDegreeGetPayload<T>>> : CheckSelect<T, Prisma__UserDegreeClient<UserDegree | null >, Prisma__UserDegreeClient<UserDegreeGetPayload<T> | null >>

    /**
     * Find zero or more UserDegrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDegreeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDegrees
     * const userDegrees = await prisma.userDegree.findMany()
     * 
     * // Get first 10 UserDegrees
     * const userDegrees = await prisma.userDegree.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userDegreeWithUserIDOnly = await prisma.userDegree.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends UserDegreeFindManyArgs>(
      args?: SelectSubset<T, UserDegreeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserDegree>>, PrismaPromise<Array<UserDegreeGetPayload<T>>>>

    /**
     * Create a UserDegree.
     * @param {UserDegreeCreateArgs} args - Arguments to create a UserDegree.
     * @example
     * // Create one UserDegree
     * const UserDegree = await prisma.userDegree.create({
     *   data: {
     *     // ... data to create a UserDegree
     *   }
     * })
     * 
    **/
    create<T extends UserDegreeCreateArgs>(
      args: SelectSubset<T, UserDegreeCreateArgs>
    ): CheckSelect<T, Prisma__UserDegreeClient<UserDegree>, Prisma__UserDegreeClient<UserDegreeGetPayload<T>>>

    /**
     * Create many UserDegrees.
     *     @param {UserDegreeCreateManyArgs} args - Arguments to create many UserDegrees.
     *     @example
     *     // Create many UserDegrees
     *     const userDegree = await prisma.userDegree.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserDegreeCreateManyArgs>(
      args?: SelectSubset<T, UserDegreeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserDegree.
     * @param {UserDegreeDeleteArgs} args - Arguments to delete one UserDegree.
     * @example
     * // Delete one UserDegree
     * const UserDegree = await prisma.userDegree.delete({
     *   where: {
     *     // ... filter to delete one UserDegree
     *   }
     * })
     * 
    **/
    delete<T extends UserDegreeDeleteArgs>(
      args: SelectSubset<T, UserDegreeDeleteArgs>
    ): CheckSelect<T, Prisma__UserDegreeClient<UserDegree>, Prisma__UserDegreeClient<UserDegreeGetPayload<T>>>

    /**
     * Update one UserDegree.
     * @param {UserDegreeUpdateArgs} args - Arguments to update one UserDegree.
     * @example
     * // Update one UserDegree
     * const userDegree = await prisma.userDegree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserDegreeUpdateArgs>(
      args: SelectSubset<T, UserDegreeUpdateArgs>
    ): CheckSelect<T, Prisma__UserDegreeClient<UserDegree>, Prisma__UserDegreeClient<UserDegreeGetPayload<T>>>

    /**
     * Delete zero or more UserDegrees.
     * @param {UserDegreeDeleteManyArgs} args - Arguments to filter UserDegrees to delete.
     * @example
     * // Delete a few UserDegrees
     * const { count } = await prisma.userDegree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDegreeDeleteManyArgs>(
      args?: SelectSubset<T, UserDegreeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDegrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDegreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDegrees
     * const userDegree = await prisma.userDegree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserDegreeUpdateManyArgs>(
      args: SelectSubset<T, UserDegreeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDegree.
     * @param {UserDegreeUpsertArgs} args - Arguments to update or create a UserDegree.
     * @example
     * // Update or create a UserDegree
     * const userDegree = await prisma.userDegree.upsert({
     *   create: {
     *     // ... data to create a UserDegree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDegree we want to update
     *   }
     * })
    **/
    upsert<T extends UserDegreeUpsertArgs>(
      args: SelectSubset<T, UserDegreeUpsertArgs>
    ): CheckSelect<T, Prisma__UserDegreeClient<UserDegree>, Prisma__UserDegreeClient<UserDegreeGetPayload<T>>>

    /**
     * Count the number of UserDegrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDegreeCountArgs} args - Arguments to filter UserDegrees to count.
     * @example
     * // Count the number of UserDegrees
     * const count = await prisma.userDegree.count({
     *   where: {
     *     // ... the filter for the UserDegrees we want to count
     *   }
     * })
    **/
    count<T extends UserDegreeCountArgs>(
      args?: Subset<T, UserDegreeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDegreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDegree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDegreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDegreeAggregateArgs>(args: Subset<T, UserDegreeAggregateArgs>): PrismaPromise<GetUserDegreeAggregateType<T>>

    /**
     * Group by UserDegree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDegreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDegreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDegreeGroupByArgs['orderBy'] }
        : { orderBy?: UserDegreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDegreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDegreeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDegree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserDegreeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserDegree findUnique
   */
  export type UserDegreeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * Throw an Error if a UserDegree can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserDegree to fetch.
     * 
    **/
    where: UserDegreeWhereUniqueInput
  }


  /**
   * UserDegree findFirst
   */
  export type UserDegreeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * Throw an Error if a UserDegree can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserDegree to fetch.
     * 
    **/
    where?: UserDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDegrees to fetch.
     * 
    **/
    orderBy?: Enumerable<UserDegreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDegrees.
     * 
    **/
    cursor?: UserDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDegrees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDegrees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDegrees.
     * 
    **/
    distinct?: Enumerable<UserDegreeScalarFieldEnum>
  }


  /**
   * UserDegree findMany
   */
  export type UserDegreeFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * Filter, which UserDegrees to fetch.
     * 
    **/
    where?: UserDegreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDegrees to fetch.
     * 
    **/
    orderBy?: Enumerable<UserDegreeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDegrees.
     * 
    **/
    cursor?: UserDegreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDegrees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDegrees.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserDegreeScalarFieldEnum>
  }


  /**
   * UserDegree create
   */
  export type UserDegreeCreateArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * The data needed to create a UserDegree.
     * 
    **/
    data: XOR<UserDegreeCreateInput, UserDegreeUncheckedCreateInput>
  }


  /**
   * UserDegree createMany
   */
  export type UserDegreeCreateManyArgs = {
    /**
     * The data used to create many UserDegrees.
     * 
    **/
    data: Enumerable<UserDegreeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserDegree update
   */
  export type UserDegreeUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * The data needed to update a UserDegree.
     * 
    **/
    data: XOR<UserDegreeUpdateInput, UserDegreeUncheckedUpdateInput>
    /**
     * Choose, which UserDegree to update.
     * 
    **/
    where: UserDegreeWhereUniqueInput
  }


  /**
   * UserDegree updateMany
   */
  export type UserDegreeUpdateManyArgs = {
    /**
     * The data used to update UserDegrees.
     * 
    **/
    data: XOR<UserDegreeUpdateManyMutationInput, UserDegreeUncheckedUpdateManyInput>
    /**
     * Filter which UserDegrees to update
     * 
    **/
    where?: UserDegreeWhereInput
  }


  /**
   * UserDegree upsert
   */
  export type UserDegreeUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * The filter to search for the UserDegree to update in case it exists.
     * 
    **/
    where: UserDegreeWhereUniqueInput
    /**
     * In case the UserDegree found by the `where` argument doesn't exist, create a new UserDegree with this data.
     * 
    **/
    create: XOR<UserDegreeCreateInput, UserDegreeUncheckedCreateInput>
    /**
     * In case the UserDegree was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserDegreeUpdateInput, UserDegreeUncheckedUpdateInput>
  }


  /**
   * UserDegree delete
   */
  export type UserDegreeDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
    /**
     * Filter which UserDegree to delete.
     * 
    **/
    where: UserDegreeWhereUniqueInput
  }


  /**
   * UserDegree deleteMany
   */
  export type UserDegreeDeleteManyArgs = {
    /**
     * Filter which UserDegrees to delete
     * 
    **/
    where?: UserDegreeWhereInput
  }


  /**
   * UserDegree without action
   */
  export type UserDegreeArgs = {
    /**
     * Select specific fields to fetch from the UserDegree
     * 
    **/
    select?: UserDegreeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserDegreeInclude | null
  }



  /**
   * Model Short
   */


  export type AggregateShort = {
    _count: ShortCountAggregateOutputType | null
    _min: ShortMinAggregateOutputType | null
    _max: ShortMaxAggregateOutputType | null
  }

  export type ShortMinAggregateOutputType = {
    id: string | null
    userId: string | null
    description: string | null
    link: string | null
    thumbnail: string | null
    datePosted: Date | null
    archived: boolean | null
  }

  export type ShortMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    description: string | null
    link: string | null
    thumbnail: string | null
    datePosted: Date | null
    archived: boolean | null
  }

  export type ShortCountAggregateOutputType = {
    id: number
    userId: number
    description: number
    link: number
    thumbnail: number
    datePosted: number
    archived: number
    _all: number
  }


  export type ShortMinAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    link?: true
    thumbnail?: true
    datePosted?: true
    archived?: true
  }

  export type ShortMaxAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    link?: true
    thumbnail?: true
    datePosted?: true
    archived?: true
  }

  export type ShortCountAggregateInputType = {
    id?: true
    userId?: true
    description?: true
    link?: true
    thumbnail?: true
    datePosted?: true
    archived?: true
    _all?: true
  }

  export type ShortAggregateArgs = {
    /**
     * Filter which Short to aggregate.
     * 
    **/
    where?: ShortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shorts to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shorts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shorts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shorts
    **/
    _count?: true | ShortCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShortMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShortMaxAggregateInputType
  }

  export type GetShortAggregateType<T extends ShortAggregateArgs> = {
        [P in keyof T & keyof AggregateShort]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShort[P]>
      : GetScalarType<T[P], AggregateShort[P]>
  }




  export type ShortGroupByArgs = {
    where?: ShortWhereInput
    orderBy?: Enumerable<ShortOrderByWithAggregationInput>
    by: Array<ShortScalarFieldEnum>
    having?: ShortScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShortCountAggregateInputType | true
    _min?: ShortMinAggregateInputType
    _max?: ShortMaxAggregateInputType
  }


  export type ShortGroupByOutputType = {
    id: string
    userId: string
    description: string | null
    link: string | null
    thumbnail: string | null
    datePosted: Date
    archived: boolean
    _count: ShortCountAggregateOutputType | null
    _min: ShortMinAggregateOutputType | null
    _max: ShortMaxAggregateOutputType | null
  }

  type GetShortGroupByPayload<T extends ShortGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShortGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShortGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShortGroupByOutputType[P]>
            : GetScalarType<T[P], ShortGroupByOutputType[P]>
        }
      >
    >


  export type ShortSelect = {
    id?: boolean
    userId?: boolean
    description?: boolean
    link?: boolean
    thumbnail?: boolean
    datePosted?: boolean
    archived?: boolean
    user?: boolean | UserArgs
    shortTag?: boolean | ShortTagFindManyArgs
    shortReport?: boolean | ShortReportFindManyArgs
    _count?: boolean | ShortCountOutputTypeArgs
  }

  export type ShortInclude = {
    user?: boolean | UserArgs
    shortTag?: boolean | ShortTagFindManyArgs
    shortReport?: boolean | ShortReportFindManyArgs
    _count?: boolean | ShortCountOutputTypeArgs
  }

  export type ShortGetPayload<
    S extends boolean | null | undefined | ShortArgs,
    U = keyof S
      > = S extends true
        ? Short
    : S extends undefined
    ? never
    : S extends ShortArgs | ShortFindManyArgs
    ?'include' extends U
    ? Short  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'shortTag' ? Array < ShortTagGetPayload<S['include'][P]>>  :
        P extends 'shortReport' ? Array < ShortReportGetPayload<S['include'][P]>>  :
        P extends '_count' ? ShortCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'shortTag' ? Array < ShortTagGetPayload<S['select'][P]>>  :
        P extends 'shortReport' ? Array < ShortReportGetPayload<S['select'][P]>>  :
        P extends '_count' ? ShortCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Short ? Short[P] : never
  } 
    : Short
  : Short


  type ShortCountArgs = Merge<
    Omit<ShortFindManyArgs, 'select' | 'include'> & {
      select?: ShortCountAggregateInputType | true
    }
  >

  export interface ShortDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Short that matches the filter.
     * @param {ShortFindUniqueArgs} args - Arguments to find a Short
     * @example
     * // Get one Short
     * const short = await prisma.short.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShortFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShortFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Short'> extends True ? CheckSelect<T, Prisma__ShortClient<Short>, Prisma__ShortClient<ShortGetPayload<T>>> : CheckSelect<T, Prisma__ShortClient<Short | null >, Prisma__ShortClient<ShortGetPayload<T> | null >>

    /**
     * Find the first Short that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortFindFirstArgs} args - Arguments to find a Short
     * @example
     * // Get one Short
     * const short = await prisma.short.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShortFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShortFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Short'> extends True ? CheckSelect<T, Prisma__ShortClient<Short>, Prisma__ShortClient<ShortGetPayload<T>>> : CheckSelect<T, Prisma__ShortClient<Short | null >, Prisma__ShortClient<ShortGetPayload<T> | null >>

    /**
     * Find zero or more Shorts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shorts
     * const shorts = await prisma.short.findMany()
     * 
     * // Get first 10 Shorts
     * const shorts = await prisma.short.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shortWithIdOnly = await prisma.short.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShortFindManyArgs>(
      args?: SelectSubset<T, ShortFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Short>>, PrismaPromise<Array<ShortGetPayload<T>>>>

    /**
     * Create a Short.
     * @param {ShortCreateArgs} args - Arguments to create a Short.
     * @example
     * // Create one Short
     * const Short = await prisma.short.create({
     *   data: {
     *     // ... data to create a Short
     *   }
     * })
     * 
    **/
    create<T extends ShortCreateArgs>(
      args: SelectSubset<T, ShortCreateArgs>
    ): CheckSelect<T, Prisma__ShortClient<Short>, Prisma__ShortClient<ShortGetPayload<T>>>

    /**
     * Create many Shorts.
     *     @param {ShortCreateManyArgs} args - Arguments to create many Shorts.
     *     @example
     *     // Create many Shorts
     *     const short = await prisma.short.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShortCreateManyArgs>(
      args?: SelectSubset<T, ShortCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Short.
     * @param {ShortDeleteArgs} args - Arguments to delete one Short.
     * @example
     * // Delete one Short
     * const Short = await prisma.short.delete({
     *   where: {
     *     // ... filter to delete one Short
     *   }
     * })
     * 
    **/
    delete<T extends ShortDeleteArgs>(
      args: SelectSubset<T, ShortDeleteArgs>
    ): CheckSelect<T, Prisma__ShortClient<Short>, Prisma__ShortClient<ShortGetPayload<T>>>

    /**
     * Update one Short.
     * @param {ShortUpdateArgs} args - Arguments to update one Short.
     * @example
     * // Update one Short
     * const short = await prisma.short.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShortUpdateArgs>(
      args: SelectSubset<T, ShortUpdateArgs>
    ): CheckSelect<T, Prisma__ShortClient<Short>, Prisma__ShortClient<ShortGetPayload<T>>>

    /**
     * Delete zero or more Shorts.
     * @param {ShortDeleteManyArgs} args - Arguments to filter Shorts to delete.
     * @example
     * // Delete a few Shorts
     * const { count } = await prisma.short.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShortDeleteManyArgs>(
      args?: SelectSubset<T, ShortDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shorts
     * const short = await prisma.short.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShortUpdateManyArgs>(
      args: SelectSubset<T, ShortUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Short.
     * @param {ShortUpsertArgs} args - Arguments to update or create a Short.
     * @example
     * // Update or create a Short
     * const short = await prisma.short.upsert({
     *   create: {
     *     // ... data to create a Short
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Short we want to update
     *   }
     * })
    **/
    upsert<T extends ShortUpsertArgs>(
      args: SelectSubset<T, ShortUpsertArgs>
    ): CheckSelect<T, Prisma__ShortClient<Short>, Prisma__ShortClient<ShortGetPayload<T>>>

    /**
     * Count the number of Shorts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortCountArgs} args - Arguments to filter Shorts to count.
     * @example
     * // Count the number of Shorts
     * const count = await prisma.short.count({
     *   where: {
     *     // ... the filter for the Shorts we want to count
     *   }
     * })
    **/
    count<T extends ShortCountArgs>(
      args?: Subset<T, ShortCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShortCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Short.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShortAggregateArgs>(args: Subset<T, ShortAggregateArgs>): PrismaPromise<GetShortAggregateType<T>>

    /**
     * Group by Short.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShortGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShortGroupByArgs['orderBy'] }
        : { orderBy?: ShortGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShortGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShortGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Short.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShortClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    shortTag<T extends ShortTagFindManyArgs = {}>(args?: Subset<T, ShortTagFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShortTag>>, PrismaPromise<Array<ShortTagGetPayload<T>>>>;

    shortReport<T extends ShortReportFindManyArgs = {}>(args?: Subset<T, ShortReportFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShortReport>>, PrismaPromise<Array<ShortReportGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Short findUnique
   */
  export type ShortFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * Throw an Error if a Short can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Short to fetch.
     * 
    **/
    where: ShortWhereUniqueInput
  }


  /**
   * Short findFirst
   */
  export type ShortFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * Throw an Error if a Short can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Short to fetch.
     * 
    **/
    where?: ShortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shorts to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shorts.
     * 
    **/
    cursor?: ShortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shorts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shorts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shorts.
     * 
    **/
    distinct?: Enumerable<ShortScalarFieldEnum>
  }


  /**
   * Short findMany
   */
  export type ShortFindManyArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * Filter, which Shorts to fetch.
     * 
    **/
    where?: ShortWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shorts to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shorts.
     * 
    **/
    cursor?: ShortWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shorts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shorts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShortScalarFieldEnum>
  }


  /**
   * Short create
   */
  export type ShortCreateArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * The data needed to create a Short.
     * 
    **/
    data: XOR<ShortCreateInput, ShortUncheckedCreateInput>
  }


  /**
   * Short createMany
   */
  export type ShortCreateManyArgs = {
    /**
     * The data used to create many Shorts.
     * 
    **/
    data: Enumerable<ShortCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Short update
   */
  export type ShortUpdateArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * The data needed to update a Short.
     * 
    **/
    data: XOR<ShortUpdateInput, ShortUncheckedUpdateInput>
    /**
     * Choose, which Short to update.
     * 
    **/
    where: ShortWhereUniqueInput
  }


  /**
   * Short updateMany
   */
  export type ShortUpdateManyArgs = {
    /**
     * The data used to update Shorts.
     * 
    **/
    data: XOR<ShortUpdateManyMutationInput, ShortUncheckedUpdateManyInput>
    /**
     * Filter which Shorts to update
     * 
    **/
    where?: ShortWhereInput
  }


  /**
   * Short upsert
   */
  export type ShortUpsertArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * The filter to search for the Short to update in case it exists.
     * 
    **/
    where: ShortWhereUniqueInput
    /**
     * In case the Short found by the `where` argument doesn't exist, create a new Short with this data.
     * 
    **/
    create: XOR<ShortCreateInput, ShortUncheckedCreateInput>
    /**
     * In case the Short was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShortUpdateInput, ShortUncheckedUpdateInput>
  }


  /**
   * Short delete
   */
  export type ShortDeleteArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
    /**
     * Filter which Short to delete.
     * 
    **/
    where: ShortWhereUniqueInput
  }


  /**
   * Short deleteMany
   */
  export type ShortDeleteManyArgs = {
    /**
     * Filter which Shorts to delete
     * 
    **/
    where?: ShortWhereInput
  }


  /**
   * Short without action
   */
  export type ShortArgs = {
    /**
     * Select specific fields to fetch from the Short
     * 
    **/
    select?: ShortSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortInclude | null
  }



  /**
   * Model ShortTag
   */


  export type AggregateShortTag = {
    _count: ShortTagCountAggregateOutputType | null
    _min: ShortTagMinAggregateOutputType | null
    _max: ShortTagMaxAggregateOutputType | null
  }

  export type ShortTagMinAggregateOutputType = {
    shortId: string | null
    tag: string | null
  }

  export type ShortTagMaxAggregateOutputType = {
    shortId: string | null
    tag: string | null
  }

  export type ShortTagCountAggregateOutputType = {
    shortId: number
    tag: number
    _all: number
  }


  export type ShortTagMinAggregateInputType = {
    shortId?: true
    tag?: true
  }

  export type ShortTagMaxAggregateInputType = {
    shortId?: true
    tag?: true
  }

  export type ShortTagCountAggregateInputType = {
    shortId?: true
    tag?: true
    _all?: true
  }

  export type ShortTagAggregateArgs = {
    /**
     * Filter which ShortTag to aggregate.
     * 
    **/
    where?: ShortTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShortTags to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShortTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShortTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShortTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShortTags
    **/
    _count?: true | ShortTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShortTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShortTagMaxAggregateInputType
  }

  export type GetShortTagAggregateType<T extends ShortTagAggregateArgs> = {
        [P in keyof T & keyof AggregateShortTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShortTag[P]>
      : GetScalarType<T[P], AggregateShortTag[P]>
  }




  export type ShortTagGroupByArgs = {
    where?: ShortTagWhereInput
    orderBy?: Enumerable<ShortTagOrderByWithAggregationInput>
    by: Array<ShortTagScalarFieldEnum>
    having?: ShortTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShortTagCountAggregateInputType | true
    _min?: ShortTagMinAggregateInputType
    _max?: ShortTagMaxAggregateInputType
  }


  export type ShortTagGroupByOutputType = {
    shortId: string
    tag: string
    _count: ShortTagCountAggregateOutputType | null
    _min: ShortTagMinAggregateOutputType | null
    _max: ShortTagMaxAggregateOutputType | null
  }

  type GetShortTagGroupByPayload<T extends ShortTagGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShortTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShortTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShortTagGroupByOutputType[P]>
            : GetScalarType<T[P], ShortTagGroupByOutputType[P]>
        }
      >
    >


  export type ShortTagSelect = {
    shortId?: boolean
    tag?: boolean
    short?: boolean | ShortArgs
  }

  export type ShortTagInclude = {
    short?: boolean | ShortArgs
  }

  export type ShortTagGetPayload<
    S extends boolean | null | undefined | ShortTagArgs,
    U = keyof S
      > = S extends true
        ? ShortTag
    : S extends undefined
    ? never
    : S extends ShortTagArgs | ShortTagFindManyArgs
    ?'include' extends U
    ? ShortTag  & {
    [P in TrueKeys<S['include']>]:
        P extends 'short' ? ShortGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'short' ? ShortGetPayload<S['select'][P]> :  P extends keyof ShortTag ? ShortTag[P] : never
  } 
    : ShortTag
  : ShortTag


  type ShortTagCountArgs = Merge<
    Omit<ShortTagFindManyArgs, 'select' | 'include'> & {
      select?: ShortTagCountAggregateInputType | true
    }
  >

  export interface ShortTagDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShortTag that matches the filter.
     * @param {ShortTagFindUniqueArgs} args - Arguments to find a ShortTag
     * @example
     * // Get one ShortTag
     * const shortTag = await prisma.shortTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShortTagFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShortTagFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShortTag'> extends True ? CheckSelect<T, Prisma__ShortTagClient<ShortTag>, Prisma__ShortTagClient<ShortTagGetPayload<T>>> : CheckSelect<T, Prisma__ShortTagClient<ShortTag | null >, Prisma__ShortTagClient<ShortTagGetPayload<T> | null >>

    /**
     * Find the first ShortTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortTagFindFirstArgs} args - Arguments to find a ShortTag
     * @example
     * // Get one ShortTag
     * const shortTag = await prisma.shortTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShortTagFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShortTagFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShortTag'> extends True ? CheckSelect<T, Prisma__ShortTagClient<ShortTag>, Prisma__ShortTagClient<ShortTagGetPayload<T>>> : CheckSelect<T, Prisma__ShortTagClient<ShortTag | null >, Prisma__ShortTagClient<ShortTagGetPayload<T> | null >>

    /**
     * Find zero or more ShortTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortTagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShortTags
     * const shortTags = await prisma.shortTag.findMany()
     * 
     * // Get first 10 ShortTags
     * const shortTags = await prisma.shortTag.findMany({ take: 10 })
     * 
     * // Only select the `shortId`
     * const shortTagWithShortIdOnly = await prisma.shortTag.findMany({ select: { shortId: true } })
     * 
    **/
    findMany<T extends ShortTagFindManyArgs>(
      args?: SelectSubset<T, ShortTagFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShortTag>>, PrismaPromise<Array<ShortTagGetPayload<T>>>>

    /**
     * Create a ShortTag.
     * @param {ShortTagCreateArgs} args - Arguments to create a ShortTag.
     * @example
     * // Create one ShortTag
     * const ShortTag = await prisma.shortTag.create({
     *   data: {
     *     // ... data to create a ShortTag
     *   }
     * })
     * 
    **/
    create<T extends ShortTagCreateArgs>(
      args: SelectSubset<T, ShortTagCreateArgs>
    ): CheckSelect<T, Prisma__ShortTagClient<ShortTag>, Prisma__ShortTagClient<ShortTagGetPayload<T>>>

    /**
     * Create many ShortTags.
     *     @param {ShortTagCreateManyArgs} args - Arguments to create many ShortTags.
     *     @example
     *     // Create many ShortTags
     *     const shortTag = await prisma.shortTag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShortTagCreateManyArgs>(
      args?: SelectSubset<T, ShortTagCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShortTag.
     * @param {ShortTagDeleteArgs} args - Arguments to delete one ShortTag.
     * @example
     * // Delete one ShortTag
     * const ShortTag = await prisma.shortTag.delete({
     *   where: {
     *     // ... filter to delete one ShortTag
     *   }
     * })
     * 
    **/
    delete<T extends ShortTagDeleteArgs>(
      args: SelectSubset<T, ShortTagDeleteArgs>
    ): CheckSelect<T, Prisma__ShortTagClient<ShortTag>, Prisma__ShortTagClient<ShortTagGetPayload<T>>>

    /**
     * Update one ShortTag.
     * @param {ShortTagUpdateArgs} args - Arguments to update one ShortTag.
     * @example
     * // Update one ShortTag
     * const shortTag = await prisma.shortTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShortTagUpdateArgs>(
      args: SelectSubset<T, ShortTagUpdateArgs>
    ): CheckSelect<T, Prisma__ShortTagClient<ShortTag>, Prisma__ShortTagClient<ShortTagGetPayload<T>>>

    /**
     * Delete zero or more ShortTags.
     * @param {ShortTagDeleteManyArgs} args - Arguments to filter ShortTags to delete.
     * @example
     * // Delete a few ShortTags
     * const { count } = await prisma.shortTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShortTagDeleteManyArgs>(
      args?: SelectSubset<T, ShortTagDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShortTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShortTags
     * const shortTag = await prisma.shortTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShortTagUpdateManyArgs>(
      args: SelectSubset<T, ShortTagUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShortTag.
     * @param {ShortTagUpsertArgs} args - Arguments to update or create a ShortTag.
     * @example
     * // Update or create a ShortTag
     * const shortTag = await prisma.shortTag.upsert({
     *   create: {
     *     // ... data to create a ShortTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShortTag we want to update
     *   }
     * })
    **/
    upsert<T extends ShortTagUpsertArgs>(
      args: SelectSubset<T, ShortTagUpsertArgs>
    ): CheckSelect<T, Prisma__ShortTagClient<ShortTag>, Prisma__ShortTagClient<ShortTagGetPayload<T>>>

    /**
     * Count the number of ShortTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortTagCountArgs} args - Arguments to filter ShortTags to count.
     * @example
     * // Count the number of ShortTags
     * const count = await prisma.shortTag.count({
     *   where: {
     *     // ... the filter for the ShortTags we want to count
     *   }
     * })
    **/
    count<T extends ShortTagCountArgs>(
      args?: Subset<T, ShortTagCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShortTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShortTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShortTagAggregateArgs>(args: Subset<T, ShortTagAggregateArgs>): PrismaPromise<GetShortTagAggregateType<T>>

    /**
     * Group by ShortTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShortTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShortTagGroupByArgs['orderBy'] }
        : { orderBy?: ShortTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShortTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShortTagGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShortTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShortTagClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    short<T extends ShortArgs = {}>(args?: Subset<T, ShortArgs>): CheckSelect<T, Prisma__ShortClient<Short | null >, Prisma__ShortClient<ShortGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShortTag findUnique
   */
  export type ShortTagFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * Throw an Error if a ShortTag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShortTag to fetch.
     * 
    **/
    where: ShortTagWhereUniqueInput
  }


  /**
   * ShortTag findFirst
   */
  export type ShortTagFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * Throw an Error if a ShortTag can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShortTag to fetch.
     * 
    **/
    where?: ShortTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShortTags to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShortTags.
     * 
    **/
    cursor?: ShortTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShortTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShortTags.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShortTags.
     * 
    **/
    distinct?: Enumerable<ShortTagScalarFieldEnum>
  }


  /**
   * ShortTag findMany
   */
  export type ShortTagFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * Filter, which ShortTags to fetch.
     * 
    **/
    where?: ShortTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShortTags to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortTagOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShortTags.
     * 
    **/
    cursor?: ShortTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShortTags from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShortTags.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShortTagScalarFieldEnum>
  }


  /**
   * ShortTag create
   */
  export type ShortTagCreateArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * The data needed to create a ShortTag.
     * 
    **/
    data: XOR<ShortTagCreateInput, ShortTagUncheckedCreateInput>
  }


  /**
   * ShortTag createMany
   */
  export type ShortTagCreateManyArgs = {
    /**
     * The data used to create many ShortTags.
     * 
    **/
    data: Enumerable<ShortTagCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShortTag update
   */
  export type ShortTagUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * The data needed to update a ShortTag.
     * 
    **/
    data: XOR<ShortTagUpdateInput, ShortTagUncheckedUpdateInput>
    /**
     * Choose, which ShortTag to update.
     * 
    **/
    where: ShortTagWhereUniqueInput
  }


  /**
   * ShortTag updateMany
   */
  export type ShortTagUpdateManyArgs = {
    /**
     * The data used to update ShortTags.
     * 
    **/
    data: XOR<ShortTagUpdateManyMutationInput, ShortTagUncheckedUpdateManyInput>
    /**
     * Filter which ShortTags to update
     * 
    **/
    where?: ShortTagWhereInput
  }


  /**
   * ShortTag upsert
   */
  export type ShortTagUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * The filter to search for the ShortTag to update in case it exists.
     * 
    **/
    where: ShortTagWhereUniqueInput
    /**
     * In case the ShortTag found by the `where` argument doesn't exist, create a new ShortTag with this data.
     * 
    **/
    create: XOR<ShortTagCreateInput, ShortTagUncheckedCreateInput>
    /**
     * In case the ShortTag was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShortTagUpdateInput, ShortTagUncheckedUpdateInput>
  }


  /**
   * ShortTag delete
   */
  export type ShortTagDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
    /**
     * Filter which ShortTag to delete.
     * 
    **/
    where: ShortTagWhereUniqueInput
  }


  /**
   * ShortTag deleteMany
   */
  export type ShortTagDeleteManyArgs = {
    /**
     * Filter which ShortTags to delete
     * 
    **/
    where?: ShortTagWhereInput
  }


  /**
   * ShortTag without action
   */
  export type ShortTagArgs = {
    /**
     * Select specific fields to fetch from the ShortTag
     * 
    **/
    select?: ShortTagSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortTagInclude | null
  }



  /**
   * Model ShortReport
   */


  export type AggregateShortReport = {
    _count: ShortReportCountAggregateOutputType | null
    _min: ShortReportMinAggregateOutputType | null
    _max: ShortReportMaxAggregateOutputType | null
  }

  export type ShortReportMinAggregateOutputType = {
    shortId: string | null
    userId: string | null
    reason: string | null
  }

  export type ShortReportMaxAggregateOutputType = {
    shortId: string | null
    userId: string | null
    reason: string | null
  }

  export type ShortReportCountAggregateOutputType = {
    shortId: number
    userId: number
    reason: number
    _all: number
  }


  export type ShortReportMinAggregateInputType = {
    shortId?: true
    userId?: true
    reason?: true
  }

  export type ShortReportMaxAggregateInputType = {
    shortId?: true
    userId?: true
    reason?: true
  }

  export type ShortReportCountAggregateInputType = {
    shortId?: true
    userId?: true
    reason?: true
    _all?: true
  }

  export type ShortReportAggregateArgs = {
    /**
     * Filter which ShortReport to aggregate.
     * 
    **/
    where?: ShortReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShortReports to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ShortReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShortReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShortReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShortReports
    **/
    _count?: true | ShortReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShortReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShortReportMaxAggregateInputType
  }

  export type GetShortReportAggregateType<T extends ShortReportAggregateArgs> = {
        [P in keyof T & keyof AggregateShortReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShortReport[P]>
      : GetScalarType<T[P], AggregateShortReport[P]>
  }




  export type ShortReportGroupByArgs = {
    where?: ShortReportWhereInput
    orderBy?: Enumerable<ShortReportOrderByWithAggregationInput>
    by: Array<ShortReportScalarFieldEnum>
    having?: ShortReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShortReportCountAggregateInputType | true
    _min?: ShortReportMinAggregateInputType
    _max?: ShortReportMaxAggregateInputType
  }


  export type ShortReportGroupByOutputType = {
    shortId: string
    userId: string
    reason: string
    _count: ShortReportCountAggregateOutputType | null
    _min: ShortReportMinAggregateOutputType | null
    _max: ShortReportMaxAggregateOutputType | null
  }

  type GetShortReportGroupByPayload<T extends ShortReportGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ShortReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShortReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShortReportGroupByOutputType[P]>
            : GetScalarType<T[P], ShortReportGroupByOutputType[P]>
        }
      >
    >


  export type ShortReportSelect = {
    shortId?: boolean
    userId?: boolean
    reason?: boolean
    user?: boolean | UserArgs
    short?: boolean | ShortArgs
  }

  export type ShortReportInclude = {
    user?: boolean | UserArgs
    short?: boolean | ShortArgs
  }

  export type ShortReportGetPayload<
    S extends boolean | null | undefined | ShortReportArgs,
    U = keyof S
      > = S extends true
        ? ShortReport
    : S extends undefined
    ? never
    : S extends ShortReportArgs | ShortReportFindManyArgs
    ?'include' extends U
    ? ShortReport  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'short' ? ShortGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'short' ? ShortGetPayload<S['select'][P]> :  P extends keyof ShortReport ? ShortReport[P] : never
  } 
    : ShortReport
  : ShortReport


  type ShortReportCountArgs = Merge<
    Omit<ShortReportFindManyArgs, 'select' | 'include'> & {
      select?: ShortReportCountAggregateInputType | true
    }
  >

  export interface ShortReportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShortReport that matches the filter.
     * @param {ShortReportFindUniqueArgs} args - Arguments to find a ShortReport
     * @example
     * // Get one ShortReport
     * const shortReport = await prisma.shortReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShortReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShortReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShortReport'> extends True ? CheckSelect<T, Prisma__ShortReportClient<ShortReport>, Prisma__ShortReportClient<ShortReportGetPayload<T>>> : CheckSelect<T, Prisma__ShortReportClient<ShortReport | null >, Prisma__ShortReportClient<ShortReportGetPayload<T> | null >>

    /**
     * Find the first ShortReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortReportFindFirstArgs} args - Arguments to find a ShortReport
     * @example
     * // Get one ShortReport
     * const shortReport = await prisma.shortReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShortReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShortReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShortReport'> extends True ? CheckSelect<T, Prisma__ShortReportClient<ShortReport>, Prisma__ShortReportClient<ShortReportGetPayload<T>>> : CheckSelect<T, Prisma__ShortReportClient<ShortReport | null >, Prisma__ShortReportClient<ShortReportGetPayload<T> | null >>

    /**
     * Find zero or more ShortReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShortReports
     * const shortReports = await prisma.shortReport.findMany()
     * 
     * // Get first 10 ShortReports
     * const shortReports = await prisma.shortReport.findMany({ take: 10 })
     * 
     * // Only select the `shortId`
     * const shortReportWithShortIdOnly = await prisma.shortReport.findMany({ select: { shortId: true } })
     * 
    **/
    findMany<T extends ShortReportFindManyArgs>(
      args?: SelectSubset<T, ShortReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShortReport>>, PrismaPromise<Array<ShortReportGetPayload<T>>>>

    /**
     * Create a ShortReport.
     * @param {ShortReportCreateArgs} args - Arguments to create a ShortReport.
     * @example
     * // Create one ShortReport
     * const ShortReport = await prisma.shortReport.create({
     *   data: {
     *     // ... data to create a ShortReport
     *   }
     * })
     * 
    **/
    create<T extends ShortReportCreateArgs>(
      args: SelectSubset<T, ShortReportCreateArgs>
    ): CheckSelect<T, Prisma__ShortReportClient<ShortReport>, Prisma__ShortReportClient<ShortReportGetPayload<T>>>

    /**
     * Create many ShortReports.
     *     @param {ShortReportCreateManyArgs} args - Arguments to create many ShortReports.
     *     @example
     *     // Create many ShortReports
     *     const shortReport = await prisma.shortReport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShortReportCreateManyArgs>(
      args?: SelectSubset<T, ShortReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ShortReport.
     * @param {ShortReportDeleteArgs} args - Arguments to delete one ShortReport.
     * @example
     * // Delete one ShortReport
     * const ShortReport = await prisma.shortReport.delete({
     *   where: {
     *     // ... filter to delete one ShortReport
     *   }
     * })
     * 
    **/
    delete<T extends ShortReportDeleteArgs>(
      args: SelectSubset<T, ShortReportDeleteArgs>
    ): CheckSelect<T, Prisma__ShortReportClient<ShortReport>, Prisma__ShortReportClient<ShortReportGetPayload<T>>>

    /**
     * Update one ShortReport.
     * @param {ShortReportUpdateArgs} args - Arguments to update one ShortReport.
     * @example
     * // Update one ShortReport
     * const shortReport = await prisma.shortReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShortReportUpdateArgs>(
      args: SelectSubset<T, ShortReportUpdateArgs>
    ): CheckSelect<T, Prisma__ShortReportClient<ShortReport>, Prisma__ShortReportClient<ShortReportGetPayload<T>>>

    /**
     * Delete zero or more ShortReports.
     * @param {ShortReportDeleteManyArgs} args - Arguments to filter ShortReports to delete.
     * @example
     * // Delete a few ShortReports
     * const { count } = await prisma.shortReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShortReportDeleteManyArgs>(
      args?: SelectSubset<T, ShortReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShortReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShortReports
     * const shortReport = await prisma.shortReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShortReportUpdateManyArgs>(
      args: SelectSubset<T, ShortReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShortReport.
     * @param {ShortReportUpsertArgs} args - Arguments to update or create a ShortReport.
     * @example
     * // Update or create a ShortReport
     * const shortReport = await prisma.shortReport.upsert({
     *   create: {
     *     // ... data to create a ShortReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShortReport we want to update
     *   }
     * })
    **/
    upsert<T extends ShortReportUpsertArgs>(
      args: SelectSubset<T, ShortReportUpsertArgs>
    ): CheckSelect<T, Prisma__ShortReportClient<ShortReport>, Prisma__ShortReportClient<ShortReportGetPayload<T>>>

    /**
     * Count the number of ShortReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortReportCountArgs} args - Arguments to filter ShortReports to count.
     * @example
     * // Count the number of ShortReports
     * const count = await prisma.shortReport.count({
     *   where: {
     *     // ... the filter for the ShortReports we want to count
     *   }
     * })
    **/
    count<T extends ShortReportCountArgs>(
      args?: Subset<T, ShortReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShortReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShortReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShortReportAggregateArgs>(args: Subset<T, ShortReportAggregateArgs>): PrismaPromise<GetShortReportAggregateType<T>>

    /**
     * Group by ShortReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShortReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShortReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShortReportGroupByArgs['orderBy'] }
        : { orderBy?: ShortReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShortReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShortReportGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShortReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShortReportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    short<T extends ShortArgs = {}>(args?: Subset<T, ShortArgs>): CheckSelect<T, Prisma__ShortClient<Short | null >, Prisma__ShortClient<ShortGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShortReport findUnique
   */
  export type ShortReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * Throw an Error if a ShortReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShortReport to fetch.
     * 
    **/
    where: ShortReportWhereUniqueInput
  }


  /**
   * ShortReport findFirst
   */
  export type ShortReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * Throw an Error if a ShortReport can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShortReport to fetch.
     * 
    **/
    where?: ShortReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShortReports to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShortReports.
     * 
    **/
    cursor?: ShortReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShortReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShortReports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShortReports.
     * 
    **/
    distinct?: Enumerable<ShortReportScalarFieldEnum>
  }


  /**
   * ShortReport findMany
   */
  export type ShortReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * Filter, which ShortReports to fetch.
     * 
    **/
    where?: ShortReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShortReports to fetch.
     * 
    **/
    orderBy?: Enumerable<ShortReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShortReports.
     * 
    **/
    cursor?: ShortReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShortReports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShortReports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ShortReportScalarFieldEnum>
  }


  /**
   * ShortReport create
   */
  export type ShortReportCreateArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * The data needed to create a ShortReport.
     * 
    **/
    data: XOR<ShortReportCreateInput, ShortReportUncheckedCreateInput>
  }


  /**
   * ShortReport createMany
   */
  export type ShortReportCreateManyArgs = {
    /**
     * The data used to create many ShortReports.
     * 
    **/
    data: Enumerable<ShortReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShortReport update
   */
  export type ShortReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * The data needed to update a ShortReport.
     * 
    **/
    data: XOR<ShortReportUpdateInput, ShortReportUncheckedUpdateInput>
    /**
     * Choose, which ShortReport to update.
     * 
    **/
    where: ShortReportWhereUniqueInput
  }


  /**
   * ShortReport updateMany
   */
  export type ShortReportUpdateManyArgs = {
    /**
     * The data used to update ShortReports.
     * 
    **/
    data: XOR<ShortReportUpdateManyMutationInput, ShortReportUncheckedUpdateManyInput>
    /**
     * Filter which ShortReports to update
     * 
    **/
    where?: ShortReportWhereInput
  }


  /**
   * ShortReport upsert
   */
  export type ShortReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * The filter to search for the ShortReport to update in case it exists.
     * 
    **/
    where: ShortReportWhereUniqueInput
    /**
     * In case the ShortReport found by the `where` argument doesn't exist, create a new ShortReport with this data.
     * 
    **/
    create: XOR<ShortReportCreateInput, ShortReportUncheckedCreateInput>
    /**
     * In case the ShortReport was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ShortReportUpdateInput, ShortReportUncheckedUpdateInput>
  }


  /**
   * ShortReport delete
   */
  export type ShortReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
    /**
     * Filter which ShortReport to delete.
     * 
    **/
    where: ShortReportWhereUniqueInput
  }


  /**
   * ShortReport deleteMany
   */
  export type ShortReportDeleteManyArgs = {
    /**
     * Filter which ShortReports to delete
     * 
    **/
    where?: ShortReportWhereInput
  }


  /**
   * ShortReport without action
   */
  export type ShortReportArgs = {
    /**
     * Select specific fields to fetch from the ShortReport
     * 
    **/
    select?: ShortReportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ShortReportInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userIdFrom: string | null
    userIdTo: string | null
    date: Date | null
    seen: boolean | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userIdFrom: string | null
    userIdTo: string | null
    date: Date | null
    seen: boolean | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userIdFrom: number
    userIdTo: number
    data: number
    date: number
    seen: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userIdFrom?: true
    userIdTo?: true
    date?: true
    seen?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userIdFrom?: true
    userIdTo?: true
    date?: true
    seen?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userIdFrom?: true
    userIdTo?: true
    data?: true
    date?: true
    seen?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: Array<NotificationScalarFieldEnum>
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: string
    userIdFrom: string | null
    userIdTo: string
    data: JsonValue
    date: Date
    seen: boolean
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect = {
    id?: boolean
    userIdFrom?: boolean
    userIdTo?: boolean
    data?: boolean
    date?: boolean
    seen?: boolean
    notificationFrom?: boolean | UserArgs
    notificationTo?: boolean | UserArgs
  }

  export type NotificationInclude = {
    notificationFrom?: boolean | UserArgs
    notificationTo?: boolean | UserArgs
  }

  export type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationArgs,
    U = keyof S
      > = S extends true
        ? Notification
    : S extends undefined
    ? never
    : S extends NotificationArgs | NotificationFindManyArgs
    ?'include' extends U
    ? Notification  & {
    [P in TrueKeys<S['include']>]:
        P extends 'notificationFrom' ? UserGetPayload<S['include'][P]> | null :
        P extends 'notificationTo' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'notificationFrom' ? UserGetPayload<S['select'][P]> | null :
        P extends 'notificationTo' ? UserGetPayload<S['select'][P]> :  P extends keyof Notification ? Notification[P] : never
  } 
    : Notification
  : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>> : CheckSelect<T, Prisma__NotificationClient<Notification | null >, Prisma__NotificationClient<NotificationGetPayload<T> | null >>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>> : CheckSelect<T, Prisma__NotificationClient<Notification | null >, Prisma__NotificationClient<NotificationGetPayload<T> | null >>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Notification>>, PrismaPromise<Array<NotificationGetPayload<T>>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): CheckSelect<T, Prisma__NotificationClient<Notification>, Prisma__NotificationClient<NotificationGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    notificationFrom<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    notificationTo<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Throw an Error if a Notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     * 
    **/
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     * 
    **/
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     * 
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     * 
    **/
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
  }



  /**
   * Model Blog
   */


  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    date: Date | null
    archived: boolean | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    date: Date | null
    archived: boolean | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    date: number
    archived: number
    _all: number
  }


  export type BlogMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    date?: true
    archived?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    date?: true
    archived?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    date?: true
    archived?: true
    _all?: true
  }

  export type BlogAggregateArgs = {
    /**
     * Filter which Blog to aggregate.
     * 
    **/
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs = {
    where?: BlogWhereInput
    orderBy?: Enumerable<BlogOrderByWithAggregationInput>
    by: Array<BlogScalarFieldEnum>
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }


  export type BlogGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string | null
    date: Date
    archived: boolean
    _count: BlogCountAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    archived?: boolean
    user?: boolean | UserArgs
    blogComment?: boolean | BlogCommentFindManyArgs
    blogMedia?: boolean | BlogMediaFindManyArgs
    _count?: boolean | BlogCountOutputTypeArgs
  }

  export type BlogInclude = {
    user?: boolean | UserArgs
    blogComment?: boolean | BlogCommentFindManyArgs
    blogMedia?: boolean | BlogMediaFindManyArgs
    _count?: boolean | BlogCountOutputTypeArgs
  }

  export type BlogGetPayload<
    S extends boolean | null | undefined | BlogArgs,
    U = keyof S
      > = S extends true
        ? Blog
    : S extends undefined
    ? never
    : S extends BlogArgs | BlogFindManyArgs
    ?'include' extends U
    ? Blog  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'blogComment' ? Array < BlogCommentGetPayload<S['include'][P]>>  :
        P extends 'blogMedia' ? Array < BlogMediaGetPayload<S['include'][P]>>  :
        P extends '_count' ? BlogCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'blogComment' ? Array < BlogCommentGetPayload<S['select'][P]>>  :
        P extends 'blogMedia' ? Array < BlogMediaGetPayload<S['select'][P]>>  :
        P extends '_count' ? BlogCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Blog ? Blog[P] : never
  } 
    : Blog
  : Blog


  type BlogCountArgs = Merge<
    Omit<BlogFindManyArgs, 'select' | 'include'> & {
      select?: BlogCountAggregateInputType | true
    }
  >

  export interface BlogDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Blog'> extends True ? CheckSelect<T, Prisma__BlogClient<Blog>, Prisma__BlogClient<BlogGetPayload<T>>> : CheckSelect<T, Prisma__BlogClient<Blog | null >, Prisma__BlogClient<BlogGetPayload<T> | null >>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Blog'> extends True ? CheckSelect<T, Prisma__BlogClient<Blog>, Prisma__BlogClient<BlogGetPayload<T>>> : CheckSelect<T, Prisma__BlogClient<Blog | null >, Prisma__BlogClient<BlogGetPayload<T> | null >>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogFindManyArgs>(
      args?: SelectSubset<T, BlogFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Blog>>, PrismaPromise<Array<BlogGetPayload<T>>>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
    **/
    create<T extends BlogCreateArgs>(
      args: SelectSubset<T, BlogCreateArgs>
    ): CheckSelect<T, Prisma__BlogClient<Blog>, Prisma__BlogClient<BlogGetPayload<T>>>

    /**
     * Create many Blogs.
     *     @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     *     @example
     *     // Create many Blogs
     *     const blog = await prisma.blog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogCreateManyArgs>(
      args?: SelectSubset<T, BlogCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
    **/
    delete<T extends BlogDeleteArgs>(
      args: SelectSubset<T, BlogDeleteArgs>
    ): CheckSelect<T, Prisma__BlogClient<Blog>, Prisma__BlogClient<BlogGetPayload<T>>>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogUpdateArgs>(
      args: SelectSubset<T, BlogUpdateArgs>
    ): CheckSelect<T, Prisma__BlogClient<Blog>, Prisma__BlogClient<BlogGetPayload<T>>>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogDeleteManyArgs>(
      args?: SelectSubset<T, BlogDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogUpdateManyArgs>(
      args: SelectSubset<T, BlogUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
    **/
    upsert<T extends BlogUpsertArgs>(
      args: SelectSubset<T, BlogUpsertArgs>
    ): CheckSelect<T, Prisma__BlogClient<Blog>, Prisma__BlogClient<BlogGetPayload<T>>>

    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlogClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    blogComment<T extends BlogCommentFindManyArgs = {}>(args?: Subset<T, BlogCommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BlogComment>>, PrismaPromise<Array<BlogCommentGetPayload<T>>>>;

    blogMedia<T extends BlogMediaFindManyArgs = {}>(args?: Subset<T, BlogMediaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<BlogMedia>>, PrismaPromise<Array<BlogMediaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * Throw an Error if a Blog can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Blog to fetch.
     * 
    **/
    where: BlogWhereUniqueInput
  }


  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * Throw an Error if a Blog can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Blog to fetch.
     * 
    **/
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     * 
    **/
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     * 
    **/
    distinct?: Enumerable<BlogScalarFieldEnum>
  }


  /**
   * Blog findMany
   */
  export type BlogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * Filter, which Blogs to fetch.
     * 
    **/
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     * 
    **/
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BlogScalarFieldEnum>
  }


  /**
   * Blog create
   */
  export type BlogCreateArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * The data needed to create a Blog.
     * 
    **/
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }


  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs = {
    /**
     * The data used to create many Blogs.
     * 
    **/
    data: Enumerable<BlogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Blog update
   */
  export type BlogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * The data needed to update a Blog.
     * 
    **/
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     * 
    **/
    where: BlogWhereUniqueInput
  }


  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs = {
    /**
     * The data used to update Blogs.
     * 
    **/
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     * 
    **/
    where?: BlogWhereInput
  }


  /**
   * Blog upsert
   */
  export type BlogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * The filter to search for the Blog to update in case it exists.
     * 
    **/
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     * 
    **/
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }


  /**
   * Blog delete
   */
  export type BlogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
    /**
     * Filter which Blog to delete.
     * 
    **/
    where: BlogWhereUniqueInput
  }


  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs = {
    /**
     * Filter which Blogs to delete
     * 
    **/
    where?: BlogWhereInput
  }


  /**
   * Blog without action
   */
  export type BlogArgs = {
    /**
     * Select specific fields to fetch from the Blog
     * 
    **/
    select?: BlogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogInclude | null
  }



  /**
   * Model BlogComment
   */


  export type AggregateBlogComment = {
    _count: BlogCommentCountAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  export type BlogCommentMinAggregateOutputType = {
    id: string | null
    blogId: string | null
    userId: string | null
    content: string | null
    date: Date | null
  }

  export type BlogCommentMaxAggregateOutputType = {
    id: string | null
    blogId: string | null
    userId: string | null
    content: string | null
    date: Date | null
  }

  export type BlogCommentCountAggregateOutputType = {
    id: number
    blogId: number
    userId: number
    content: number
    date: number
    _all: number
  }


  export type BlogCommentMinAggregateInputType = {
    id?: true
    blogId?: true
    userId?: true
    content?: true
    date?: true
  }

  export type BlogCommentMaxAggregateInputType = {
    id?: true
    blogId?: true
    userId?: true
    content?: true
    date?: true
  }

  export type BlogCommentCountAggregateInputType = {
    id?: true
    blogId?: true
    userId?: true
    content?: true
    date?: true
    _all?: true
  }

  export type BlogCommentAggregateArgs = {
    /**
     * Filter which BlogComment to aggregate.
     * 
    **/
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogComments
    **/
    _count?: true | BlogCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogCommentMaxAggregateInputType
  }

  export type GetBlogCommentAggregateType<T extends BlogCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogComment[P]>
      : GetScalarType<T[P], AggregateBlogComment[P]>
  }




  export type BlogCommentGroupByArgs = {
    where?: BlogCommentWhereInput
    orderBy?: Enumerable<BlogCommentOrderByWithAggregationInput>
    by: Array<BlogCommentScalarFieldEnum>
    having?: BlogCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCommentCountAggregateInputType | true
    _min?: BlogCommentMinAggregateInputType
    _max?: BlogCommentMaxAggregateInputType
  }


  export type BlogCommentGroupByOutputType = {
    id: string
    blogId: string
    userId: string
    content: string
    date: Date
    _count: BlogCommentCountAggregateOutputType | null
    _min: BlogCommentMinAggregateOutputType | null
    _max: BlogCommentMaxAggregateOutputType | null
  }

  type GetBlogCommentGroupByPayload<T extends BlogCommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BlogCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
            : GetScalarType<T[P], BlogCommentGroupByOutputType[P]>
        }
      >
    >


  export type BlogCommentSelect = {
    id?: boolean
    blogId?: boolean
    userId?: boolean
    content?: boolean
    date?: boolean
    blog?: boolean | BlogArgs
    user?: boolean | UserArgs
  }

  export type BlogCommentInclude = {
    blog?: boolean | BlogArgs
    user?: boolean | UserArgs
  }

  export type BlogCommentGetPayload<
    S extends boolean | null | undefined | BlogCommentArgs,
    U = keyof S
      > = S extends true
        ? BlogComment
    : S extends undefined
    ? never
    : S extends BlogCommentArgs | BlogCommentFindManyArgs
    ?'include' extends U
    ? BlogComment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'blog' ? BlogGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'blog' ? BlogGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof BlogComment ? BlogComment[P] : never
  } 
    : BlogComment
  : BlogComment


  type BlogCommentCountArgs = Merge<
    Omit<BlogCommentFindManyArgs, 'select' | 'include'> & {
      select?: BlogCommentCountAggregateInputType | true
    }
  >

  export interface BlogCommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BlogComment that matches the filter.
     * @param {BlogCommentFindUniqueArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlogCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BlogComment'> extends True ? CheckSelect<T, Prisma__BlogCommentClient<BlogComment>, Prisma__BlogCommentClient<BlogCommentGetPayload<T>>> : CheckSelect<T, Prisma__BlogCommentClient<BlogComment | null >, Prisma__BlogCommentClient<BlogCommentGetPayload<T> | null >>

    /**
     * Find the first BlogComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindFirstArgs} args - Arguments to find a BlogComment
     * @example
     * // Get one BlogComment
     * const blogComment = await prisma.blogComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlogCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BlogComment'> extends True ? CheckSelect<T, Prisma__BlogCommentClient<BlogComment>, Prisma__BlogCommentClient<BlogCommentGetPayload<T>>> : CheckSelect<T, Prisma__BlogCommentClient<BlogComment | null >, Prisma__BlogCommentClient<BlogCommentGetPayload<T> | null >>

    /**
     * Find zero or more BlogComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogComments
     * const blogComments = await prisma.blogComment.findMany()
     * 
     * // Get first 10 BlogComments
     * const blogComments = await prisma.blogComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogCommentWithIdOnly = await prisma.blogComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogCommentFindManyArgs>(
      args?: SelectSubset<T, BlogCommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BlogComment>>, PrismaPromise<Array<BlogCommentGetPayload<T>>>>

    /**
     * Create a BlogComment.
     * @param {BlogCommentCreateArgs} args - Arguments to create a BlogComment.
     * @example
     * // Create one BlogComment
     * const BlogComment = await prisma.blogComment.create({
     *   data: {
     *     // ... data to create a BlogComment
     *   }
     * })
     * 
    **/
    create<T extends BlogCommentCreateArgs>(
      args: SelectSubset<T, BlogCommentCreateArgs>
    ): CheckSelect<T, Prisma__BlogCommentClient<BlogComment>, Prisma__BlogCommentClient<BlogCommentGetPayload<T>>>

    /**
     * Create many BlogComments.
     *     @param {BlogCommentCreateManyArgs} args - Arguments to create many BlogComments.
     *     @example
     *     // Create many BlogComments
     *     const blogComment = await prisma.blogComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogCommentCreateManyArgs>(
      args?: SelectSubset<T, BlogCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BlogComment.
     * @param {BlogCommentDeleteArgs} args - Arguments to delete one BlogComment.
     * @example
     * // Delete one BlogComment
     * const BlogComment = await prisma.blogComment.delete({
     *   where: {
     *     // ... filter to delete one BlogComment
     *   }
     * })
     * 
    **/
    delete<T extends BlogCommentDeleteArgs>(
      args: SelectSubset<T, BlogCommentDeleteArgs>
    ): CheckSelect<T, Prisma__BlogCommentClient<BlogComment>, Prisma__BlogCommentClient<BlogCommentGetPayload<T>>>

    /**
     * Update one BlogComment.
     * @param {BlogCommentUpdateArgs} args - Arguments to update one BlogComment.
     * @example
     * // Update one BlogComment
     * const blogComment = await prisma.blogComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogCommentUpdateArgs>(
      args: SelectSubset<T, BlogCommentUpdateArgs>
    ): CheckSelect<T, Prisma__BlogCommentClient<BlogComment>, Prisma__BlogCommentClient<BlogCommentGetPayload<T>>>

    /**
     * Delete zero or more BlogComments.
     * @param {BlogCommentDeleteManyArgs} args - Arguments to filter BlogComments to delete.
     * @example
     * // Delete a few BlogComments
     * const { count } = await prisma.blogComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogCommentDeleteManyArgs>(
      args?: SelectSubset<T, BlogCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogComments
     * const blogComment = await prisma.blogComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogCommentUpdateManyArgs>(
      args: SelectSubset<T, BlogCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogComment.
     * @param {BlogCommentUpsertArgs} args - Arguments to update or create a BlogComment.
     * @example
     * // Update or create a BlogComment
     * const blogComment = await prisma.blogComment.upsert({
     *   create: {
     *     // ... data to create a BlogComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogComment we want to update
     *   }
     * })
    **/
    upsert<T extends BlogCommentUpsertArgs>(
      args: SelectSubset<T, BlogCommentUpsertArgs>
    ): CheckSelect<T, Prisma__BlogCommentClient<BlogComment>, Prisma__BlogCommentClient<BlogCommentGetPayload<T>>>

    /**
     * Count the number of BlogComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentCountArgs} args - Arguments to filter BlogComments to count.
     * @example
     * // Count the number of BlogComments
     * const count = await prisma.blogComment.count({
     *   where: {
     *     // ... the filter for the BlogComments we want to count
     *   }
     * })
    **/
    count<T extends BlogCommentCountArgs>(
      args?: Subset<T, BlogCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogCommentAggregateArgs>(args: Subset<T, BlogCommentAggregateArgs>): PrismaPromise<GetBlogCommentAggregateType<T>>

    /**
     * Group by BlogComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogCommentGroupByArgs['orderBy'] }
        : { orderBy?: BlogCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogCommentGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlogCommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    blog<T extends BlogArgs = {}>(args?: Subset<T, BlogArgs>): CheckSelect<T, Prisma__BlogClient<Blog | null >, Prisma__BlogClient<BlogGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * BlogComment findUnique
   */
  export type BlogCommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * Throw an Error if a BlogComment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BlogComment to fetch.
     * 
    **/
    where: BlogCommentWhereUniqueInput
  }


  /**
   * BlogComment findFirst
   */
  export type BlogCommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * Throw an Error if a BlogComment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BlogComment to fetch.
     * 
    **/
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogComments.
     * 
    **/
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogComments.
     * 
    **/
    distinct?: Enumerable<BlogCommentScalarFieldEnum>
  }


  /**
   * BlogComment findMany
   */
  export type BlogCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * Filter, which BlogComments to fetch.
     * 
    **/
    where?: BlogCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogComments to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogComments.
     * 
    **/
    cursor?: BlogCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogComments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BlogCommentScalarFieldEnum>
  }


  /**
   * BlogComment create
   */
  export type BlogCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * The data needed to create a BlogComment.
     * 
    **/
    data: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
  }


  /**
   * BlogComment createMany
   */
  export type BlogCommentCreateManyArgs = {
    /**
     * The data used to create many BlogComments.
     * 
    **/
    data: Enumerable<BlogCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BlogComment update
   */
  export type BlogCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * The data needed to update a BlogComment.
     * 
    **/
    data: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
    /**
     * Choose, which BlogComment to update.
     * 
    **/
    where: BlogCommentWhereUniqueInput
  }


  /**
   * BlogComment updateMany
   */
  export type BlogCommentUpdateManyArgs = {
    /**
     * The data used to update BlogComments.
     * 
    **/
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyInput>
    /**
     * Filter which BlogComments to update
     * 
    **/
    where?: BlogCommentWhereInput
  }


  /**
   * BlogComment upsert
   */
  export type BlogCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * The filter to search for the BlogComment to update in case it exists.
     * 
    **/
    where: BlogCommentWhereUniqueInput
    /**
     * In case the BlogComment found by the `where` argument doesn't exist, create a new BlogComment with this data.
     * 
    **/
    create: XOR<BlogCommentCreateInput, BlogCommentUncheckedCreateInput>
    /**
     * In case the BlogComment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BlogCommentUpdateInput, BlogCommentUncheckedUpdateInput>
  }


  /**
   * BlogComment delete
   */
  export type BlogCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
    /**
     * Filter which BlogComment to delete.
     * 
    **/
    where: BlogCommentWhereUniqueInput
  }


  /**
   * BlogComment deleteMany
   */
  export type BlogCommentDeleteManyArgs = {
    /**
     * Filter which BlogComments to delete
     * 
    **/
    where?: BlogCommentWhereInput
  }


  /**
   * BlogComment without action
   */
  export type BlogCommentArgs = {
    /**
     * Select specific fields to fetch from the BlogComment
     * 
    **/
    select?: BlogCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogCommentInclude | null
  }



  /**
   * Model BlogMedia
   */


  export type AggregateBlogMedia = {
    _count: BlogMediaCountAggregateOutputType | null
    _min: BlogMediaMinAggregateOutputType | null
    _max: BlogMediaMaxAggregateOutputType | null
  }

  export type BlogMediaMinAggregateOutputType = {
    blogId: string | null
    media: string | null
  }

  export type BlogMediaMaxAggregateOutputType = {
    blogId: string | null
    media: string | null
  }

  export type BlogMediaCountAggregateOutputType = {
    blogId: number
    media: number
    _all: number
  }


  export type BlogMediaMinAggregateInputType = {
    blogId?: true
    media?: true
  }

  export type BlogMediaMaxAggregateInputType = {
    blogId?: true
    media?: true
  }

  export type BlogMediaCountAggregateInputType = {
    blogId?: true
    media?: true
    _all?: true
  }

  export type BlogMediaAggregateArgs = {
    /**
     * Filter which BlogMedia to aggregate.
     * 
    **/
    where?: BlogMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BlogMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogMedias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogMedias
    **/
    _count?: true | BlogMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMediaMaxAggregateInputType
  }

  export type GetBlogMediaAggregateType<T extends BlogMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogMedia[P]>
      : GetScalarType<T[P], AggregateBlogMedia[P]>
  }




  export type BlogMediaGroupByArgs = {
    where?: BlogMediaWhereInput
    orderBy?: Enumerable<BlogMediaOrderByWithAggregationInput>
    by: Array<BlogMediaScalarFieldEnum>
    having?: BlogMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogMediaCountAggregateInputType | true
    _min?: BlogMediaMinAggregateInputType
    _max?: BlogMediaMaxAggregateInputType
  }


  export type BlogMediaGroupByOutputType = {
    blogId: string
    media: string
    _count: BlogMediaCountAggregateOutputType | null
    _min: BlogMediaMinAggregateOutputType | null
    _max: BlogMediaMaxAggregateOutputType | null
  }

  type GetBlogMediaGroupByPayload<T extends BlogMediaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BlogMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogMediaGroupByOutputType[P]>
            : GetScalarType<T[P], BlogMediaGroupByOutputType[P]>
        }
      >
    >


  export type BlogMediaSelect = {
    blogId?: boolean
    media?: boolean
    blog?: boolean | BlogArgs
  }

  export type BlogMediaInclude = {
    blog?: boolean | BlogArgs
  }

  export type BlogMediaGetPayload<
    S extends boolean | null | undefined | BlogMediaArgs,
    U = keyof S
      > = S extends true
        ? BlogMedia
    : S extends undefined
    ? never
    : S extends BlogMediaArgs | BlogMediaFindManyArgs
    ?'include' extends U
    ? BlogMedia  & {
    [P in TrueKeys<S['include']>]:
        P extends 'blog' ? BlogGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'blog' ? BlogGetPayload<S['select'][P]> :  P extends keyof BlogMedia ? BlogMedia[P] : never
  } 
    : BlogMedia
  : BlogMedia


  type BlogMediaCountArgs = Merge<
    Omit<BlogMediaFindManyArgs, 'select' | 'include'> & {
      select?: BlogMediaCountAggregateInputType | true
    }
  >

  export interface BlogMediaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BlogMedia that matches the filter.
     * @param {BlogMediaFindUniqueArgs} args - Arguments to find a BlogMedia
     * @example
     * // Get one BlogMedia
     * const blogMedia = await prisma.blogMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogMediaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BlogMediaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BlogMedia'> extends True ? CheckSelect<T, Prisma__BlogMediaClient<BlogMedia>, Prisma__BlogMediaClient<BlogMediaGetPayload<T>>> : CheckSelect<T, Prisma__BlogMediaClient<BlogMedia | null >, Prisma__BlogMediaClient<BlogMediaGetPayload<T> | null >>

    /**
     * Find the first BlogMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogMediaFindFirstArgs} args - Arguments to find a BlogMedia
     * @example
     * // Get one BlogMedia
     * const blogMedia = await prisma.blogMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogMediaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BlogMediaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BlogMedia'> extends True ? CheckSelect<T, Prisma__BlogMediaClient<BlogMedia>, Prisma__BlogMediaClient<BlogMediaGetPayload<T>>> : CheckSelect<T, Prisma__BlogMediaClient<BlogMedia | null >, Prisma__BlogMediaClient<BlogMediaGetPayload<T> | null >>

    /**
     * Find zero or more BlogMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogMediaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogMedias
     * const blogMedias = await prisma.blogMedia.findMany()
     * 
     * // Get first 10 BlogMedias
     * const blogMedias = await prisma.blogMedia.findMany({ take: 10 })
     * 
     * // Only select the `blogId`
     * const blogMediaWithBlogIdOnly = await prisma.blogMedia.findMany({ select: { blogId: true } })
     * 
    **/
    findMany<T extends BlogMediaFindManyArgs>(
      args?: SelectSubset<T, BlogMediaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<BlogMedia>>, PrismaPromise<Array<BlogMediaGetPayload<T>>>>

    /**
     * Create a BlogMedia.
     * @param {BlogMediaCreateArgs} args - Arguments to create a BlogMedia.
     * @example
     * // Create one BlogMedia
     * const BlogMedia = await prisma.blogMedia.create({
     *   data: {
     *     // ... data to create a BlogMedia
     *   }
     * })
     * 
    **/
    create<T extends BlogMediaCreateArgs>(
      args: SelectSubset<T, BlogMediaCreateArgs>
    ): CheckSelect<T, Prisma__BlogMediaClient<BlogMedia>, Prisma__BlogMediaClient<BlogMediaGetPayload<T>>>

    /**
     * Create many BlogMedias.
     *     @param {BlogMediaCreateManyArgs} args - Arguments to create many BlogMedias.
     *     @example
     *     // Create many BlogMedias
     *     const blogMedia = await prisma.blogMedia.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogMediaCreateManyArgs>(
      args?: SelectSubset<T, BlogMediaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BlogMedia.
     * @param {BlogMediaDeleteArgs} args - Arguments to delete one BlogMedia.
     * @example
     * // Delete one BlogMedia
     * const BlogMedia = await prisma.blogMedia.delete({
     *   where: {
     *     // ... filter to delete one BlogMedia
     *   }
     * })
     * 
    **/
    delete<T extends BlogMediaDeleteArgs>(
      args: SelectSubset<T, BlogMediaDeleteArgs>
    ): CheckSelect<T, Prisma__BlogMediaClient<BlogMedia>, Prisma__BlogMediaClient<BlogMediaGetPayload<T>>>

    /**
     * Update one BlogMedia.
     * @param {BlogMediaUpdateArgs} args - Arguments to update one BlogMedia.
     * @example
     * // Update one BlogMedia
     * const blogMedia = await prisma.blogMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogMediaUpdateArgs>(
      args: SelectSubset<T, BlogMediaUpdateArgs>
    ): CheckSelect<T, Prisma__BlogMediaClient<BlogMedia>, Prisma__BlogMediaClient<BlogMediaGetPayload<T>>>

    /**
     * Delete zero or more BlogMedias.
     * @param {BlogMediaDeleteManyArgs} args - Arguments to filter BlogMedias to delete.
     * @example
     * // Delete a few BlogMedias
     * const { count } = await prisma.blogMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogMediaDeleteManyArgs>(
      args?: SelectSubset<T, BlogMediaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogMedias
     * const blogMedia = await prisma.blogMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogMediaUpdateManyArgs>(
      args: SelectSubset<T, BlogMediaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogMedia.
     * @param {BlogMediaUpsertArgs} args - Arguments to update or create a BlogMedia.
     * @example
     * // Update or create a BlogMedia
     * const blogMedia = await prisma.blogMedia.upsert({
     *   create: {
     *     // ... data to create a BlogMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogMedia we want to update
     *   }
     * })
    **/
    upsert<T extends BlogMediaUpsertArgs>(
      args: SelectSubset<T, BlogMediaUpsertArgs>
    ): CheckSelect<T, Prisma__BlogMediaClient<BlogMedia>, Prisma__BlogMediaClient<BlogMediaGetPayload<T>>>

    /**
     * Count the number of BlogMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogMediaCountArgs} args - Arguments to filter BlogMedias to count.
     * @example
     * // Count the number of BlogMedias
     * const count = await prisma.blogMedia.count({
     *   where: {
     *     // ... the filter for the BlogMedias we want to count
     *   }
     * })
    **/
    count<T extends BlogMediaCountArgs>(
      args?: Subset<T, BlogMediaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogMediaAggregateArgs>(args: Subset<T, BlogMediaAggregateArgs>): PrismaPromise<GetBlogMediaAggregateType<T>>

    /**
     * Group by BlogMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogMediaGroupByArgs['orderBy'] }
        : { orderBy?: BlogMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogMediaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BlogMediaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    blog<T extends BlogArgs = {}>(args?: Subset<T, BlogArgs>): CheckSelect<T, Prisma__BlogClient<Blog | null >, Prisma__BlogClient<BlogGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * BlogMedia findUnique
   */
  export type BlogMediaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * Throw an Error if a BlogMedia can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BlogMedia to fetch.
     * 
    **/
    where: BlogMediaWhereUniqueInput
  }


  /**
   * BlogMedia findFirst
   */
  export type BlogMediaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * Throw an Error if a BlogMedia can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which BlogMedia to fetch.
     * 
    **/
    where?: BlogMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogMedias.
     * 
    **/
    cursor?: BlogMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogMedias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogMedias.
     * 
    **/
    distinct?: Enumerable<BlogMediaScalarFieldEnum>
  }


  /**
   * BlogMedia findMany
   */
  export type BlogMediaFindManyArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * Filter, which BlogMedias to fetch.
     * 
    **/
    where?: BlogMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogMedias to fetch.
     * 
    **/
    orderBy?: Enumerable<BlogMediaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogMedias.
     * 
    **/
    cursor?: BlogMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogMedias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogMedias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BlogMediaScalarFieldEnum>
  }


  /**
   * BlogMedia create
   */
  export type BlogMediaCreateArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * The data needed to create a BlogMedia.
     * 
    **/
    data: XOR<BlogMediaCreateInput, BlogMediaUncheckedCreateInput>
  }


  /**
   * BlogMedia createMany
   */
  export type BlogMediaCreateManyArgs = {
    /**
     * The data used to create many BlogMedias.
     * 
    **/
    data: Enumerable<BlogMediaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BlogMedia update
   */
  export type BlogMediaUpdateArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * The data needed to update a BlogMedia.
     * 
    **/
    data: XOR<BlogMediaUpdateInput, BlogMediaUncheckedUpdateInput>
    /**
     * Choose, which BlogMedia to update.
     * 
    **/
    where: BlogMediaWhereUniqueInput
  }


  /**
   * BlogMedia updateMany
   */
  export type BlogMediaUpdateManyArgs = {
    /**
     * The data used to update BlogMedias.
     * 
    **/
    data: XOR<BlogMediaUpdateManyMutationInput, BlogMediaUncheckedUpdateManyInput>
    /**
     * Filter which BlogMedias to update
     * 
    **/
    where?: BlogMediaWhereInput
  }


  /**
   * BlogMedia upsert
   */
  export type BlogMediaUpsertArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * The filter to search for the BlogMedia to update in case it exists.
     * 
    **/
    where: BlogMediaWhereUniqueInput
    /**
     * In case the BlogMedia found by the `where` argument doesn't exist, create a new BlogMedia with this data.
     * 
    **/
    create: XOR<BlogMediaCreateInput, BlogMediaUncheckedCreateInput>
    /**
     * In case the BlogMedia was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BlogMediaUpdateInput, BlogMediaUncheckedUpdateInput>
  }


  /**
   * BlogMedia delete
   */
  export type BlogMediaDeleteArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
    /**
     * Filter which BlogMedia to delete.
     * 
    **/
    where: BlogMediaWhereUniqueInput
  }


  /**
   * BlogMedia deleteMany
   */
  export type BlogMediaDeleteManyArgs = {
    /**
     * Filter which BlogMedias to delete
     * 
    **/
    where?: BlogMediaWhereInput
  }


  /**
   * BlogMedia without action
   */
  export type BlogMediaArgs = {
    /**
     * Select specific fields to fetch from the BlogMedia
     * 
    **/
    select?: BlogMediaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BlogMediaInclude | null
  }



  /**
   * Model UserToken
   */


  export type AggregateUserToken = {
    _count: UserTokenCountAggregateOutputType | null
    _avg: UserTokenAvgAggregateOutputType | null
    _sum: UserTokenSumAggregateOutputType | null
    _min: UserTokenMinAggregateOutputType | null
    _max: UserTokenMaxAggregateOutputType | null
  }

  export type UserTokenAvgAggregateOutputType = {
    userTokenType: number | null
    userTokenExpiration: number | null
  }

  export type UserTokenSumAggregateOutputType = {
    userTokenType: number | null
    userTokenExpiration: number | null
  }

  export type UserTokenMinAggregateOutputType = {
    userId: string | null
    userToken: string | null
    userTokenType: number | null
    userTokenExpiration: number | null
  }

  export type UserTokenMaxAggregateOutputType = {
    userId: string | null
    userToken: string | null
    userTokenType: number | null
    userTokenExpiration: number | null
  }

  export type UserTokenCountAggregateOutputType = {
    userId: number
    userToken: number
    userTokenType: number
    userTokenExpiration: number
    _all: number
  }


  export type UserTokenAvgAggregateInputType = {
    userTokenType?: true
    userTokenExpiration?: true
  }

  export type UserTokenSumAggregateInputType = {
    userTokenType?: true
    userTokenExpiration?: true
  }

  export type UserTokenMinAggregateInputType = {
    userId?: true
    userToken?: true
    userTokenType?: true
    userTokenExpiration?: true
  }

  export type UserTokenMaxAggregateInputType = {
    userId?: true
    userToken?: true
    userTokenType?: true
    userTokenExpiration?: true
  }

  export type UserTokenCountAggregateInputType = {
    userId?: true
    userToken?: true
    userTokenType?: true
    userTokenExpiration?: true
    _all?: true
  }

  export type UserTokenAggregateArgs = {
    /**
     * Filter which UserToken to aggregate.
     * 
    **/
    where?: UserTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTokens
    **/
    _count?: true | UserTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTokenMaxAggregateInputType
  }

  export type GetUserTokenAggregateType<T extends UserTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToken[P]>
      : GetScalarType<T[P], AggregateUserToken[P]>
  }




  export type UserTokenGroupByArgs = {
    where?: UserTokenWhereInput
    orderBy?: Enumerable<UserTokenOrderByWithAggregationInput>
    by: Array<UserTokenScalarFieldEnum>
    having?: UserTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTokenCountAggregateInputType | true
    _avg?: UserTokenAvgAggregateInputType
    _sum?: UserTokenSumAggregateInputType
    _min?: UserTokenMinAggregateInputType
    _max?: UserTokenMaxAggregateInputType
  }


  export type UserTokenGroupByOutputType = {
    userId: string
    userToken: string
    userTokenType: number
    userTokenExpiration: number
    _count: UserTokenCountAggregateOutputType | null
    _avg: UserTokenAvgAggregateOutputType | null
    _sum: UserTokenSumAggregateOutputType | null
    _min: UserTokenMinAggregateOutputType | null
    _max: UserTokenMaxAggregateOutputType | null
  }

  type GetUserTokenGroupByPayload<T extends UserTokenGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTokenGroupByOutputType[P]>
            : GetScalarType<T[P], UserTokenGroupByOutputType[P]>
        }
      >
    >


  export type UserTokenSelect = {
    userId?: boolean
    userToken?: boolean
    userTokenType?: boolean
    userTokenExpiration?: boolean
    user?: boolean | UserArgs
  }

  export type UserTokenInclude = {
    user?: boolean | UserArgs
  }

  export type UserTokenGetPayload<
    S extends boolean | null | undefined | UserTokenArgs,
    U = keyof S
      > = S extends true
        ? UserToken
    : S extends undefined
    ? never
    : S extends UserTokenArgs | UserTokenFindManyArgs
    ?'include' extends U
    ? UserToken  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserToken ? UserToken[P] : never
  } 
    : UserToken
  : UserToken


  type UserTokenCountArgs = Merge<
    Omit<UserTokenFindManyArgs, 'select' | 'include'> & {
      select?: UserTokenCountAggregateInputType | true
    }
  >

  export interface UserTokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserToken that matches the filter.
     * @param {UserTokenFindUniqueArgs} args - Arguments to find a UserToken
     * @example
     * // Get one UserToken
     * const userToken = await prisma.userToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserTokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserTokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserToken'> extends True ? CheckSelect<T, Prisma__UserTokenClient<UserToken>, Prisma__UserTokenClient<UserTokenGetPayload<T>>> : CheckSelect<T, Prisma__UserTokenClient<UserToken | null >, Prisma__UserTokenClient<UserTokenGetPayload<T> | null >>

    /**
     * Find the first UserToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenFindFirstArgs} args - Arguments to find a UserToken
     * @example
     * // Get one UserToken
     * const userToken = await prisma.userToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserTokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserTokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserToken'> extends True ? CheckSelect<T, Prisma__UserTokenClient<UserToken>, Prisma__UserTokenClient<UserTokenGetPayload<T>>> : CheckSelect<T, Prisma__UserTokenClient<UserToken | null >, Prisma__UserTokenClient<UserTokenGetPayload<T> | null >>

    /**
     * Find zero or more UserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTokens
     * const userTokens = await prisma.userToken.findMany()
     * 
     * // Get first 10 UserTokens
     * const userTokens = await prisma.userToken.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userTokenWithUserIdOnly = await prisma.userToken.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserTokenFindManyArgs>(
      args?: SelectSubset<T, UserTokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserToken>>, PrismaPromise<Array<UserTokenGetPayload<T>>>>

    /**
     * Create a UserToken.
     * @param {UserTokenCreateArgs} args - Arguments to create a UserToken.
     * @example
     * // Create one UserToken
     * const UserToken = await prisma.userToken.create({
     *   data: {
     *     // ... data to create a UserToken
     *   }
     * })
     * 
    **/
    create<T extends UserTokenCreateArgs>(
      args: SelectSubset<T, UserTokenCreateArgs>
    ): CheckSelect<T, Prisma__UserTokenClient<UserToken>, Prisma__UserTokenClient<UserTokenGetPayload<T>>>

    /**
     * Create many UserTokens.
     *     @param {UserTokenCreateManyArgs} args - Arguments to create many UserTokens.
     *     @example
     *     // Create many UserTokens
     *     const userToken = await prisma.userToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserTokenCreateManyArgs>(
      args?: SelectSubset<T, UserTokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserToken.
     * @param {UserTokenDeleteArgs} args - Arguments to delete one UserToken.
     * @example
     * // Delete one UserToken
     * const UserToken = await prisma.userToken.delete({
     *   where: {
     *     // ... filter to delete one UserToken
     *   }
     * })
     * 
    **/
    delete<T extends UserTokenDeleteArgs>(
      args: SelectSubset<T, UserTokenDeleteArgs>
    ): CheckSelect<T, Prisma__UserTokenClient<UserToken>, Prisma__UserTokenClient<UserTokenGetPayload<T>>>

    /**
     * Update one UserToken.
     * @param {UserTokenUpdateArgs} args - Arguments to update one UserToken.
     * @example
     * // Update one UserToken
     * const userToken = await prisma.userToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserTokenUpdateArgs>(
      args: SelectSubset<T, UserTokenUpdateArgs>
    ): CheckSelect<T, Prisma__UserTokenClient<UserToken>, Prisma__UserTokenClient<UserTokenGetPayload<T>>>

    /**
     * Delete zero or more UserTokens.
     * @param {UserTokenDeleteManyArgs} args - Arguments to filter UserTokens to delete.
     * @example
     * // Delete a few UserTokens
     * const { count } = await prisma.userToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserTokenDeleteManyArgs>(
      args?: SelectSubset<T, UserTokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTokens
     * const userToken = await prisma.userToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserTokenUpdateManyArgs>(
      args: SelectSubset<T, UserTokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToken.
     * @param {UserTokenUpsertArgs} args - Arguments to update or create a UserToken.
     * @example
     * // Update or create a UserToken
     * const userToken = await prisma.userToken.upsert({
     *   create: {
     *     // ... data to create a UserToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToken we want to update
     *   }
     * })
    **/
    upsert<T extends UserTokenUpsertArgs>(
      args: SelectSubset<T, UserTokenUpsertArgs>
    ): CheckSelect<T, Prisma__UserTokenClient<UserToken>, Prisma__UserTokenClient<UserTokenGetPayload<T>>>

    /**
     * Count the number of UserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenCountArgs} args - Arguments to filter UserTokens to count.
     * @example
     * // Count the number of UserTokens
     * const count = await prisma.userToken.count({
     *   where: {
     *     // ... the filter for the UserTokens we want to count
     *   }
     * })
    **/
    count<T extends UserTokenCountArgs>(
      args?: Subset<T, UserTokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTokenAggregateArgs>(args: Subset<T, UserTokenAggregateArgs>): PrismaPromise<GetUserTokenAggregateType<T>>

    /**
     * Group by UserToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTokenGroupByArgs['orderBy'] }
        : { orderBy?: UserTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTokenGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserTokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserToken findUnique
   */
  export type UserTokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * Throw an Error if a UserToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserToken to fetch.
     * 
    **/
    where: UserTokenWhereUniqueInput
  }


  /**
   * UserToken findFirst
   */
  export type UserTokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * Throw an Error if a UserToken can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserToken to fetch.
     * 
    **/
    where?: UserTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTokens.
     * 
    **/
    cursor?: UserTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTokens.
     * 
    **/
    distinct?: Enumerable<UserTokenScalarFieldEnum>
  }


  /**
   * UserToken findMany
   */
  export type UserTokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * Filter, which UserTokens to fetch.
     * 
    **/
    where?: UserTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTokens to fetch.
     * 
    **/
    orderBy?: Enumerable<UserTokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTokens.
     * 
    **/
    cursor?: UserTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserTokenScalarFieldEnum>
  }


  /**
   * UserToken create
   */
  export type UserTokenCreateArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * The data needed to create a UserToken.
     * 
    **/
    data: XOR<UserTokenCreateInput, UserTokenUncheckedCreateInput>
  }


  /**
   * UserToken createMany
   */
  export type UserTokenCreateManyArgs = {
    /**
     * The data used to create many UserTokens.
     * 
    **/
    data: Enumerable<UserTokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserToken update
   */
  export type UserTokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * The data needed to update a UserToken.
     * 
    **/
    data: XOR<UserTokenUpdateInput, UserTokenUncheckedUpdateInput>
    /**
     * Choose, which UserToken to update.
     * 
    **/
    where: UserTokenWhereUniqueInput
  }


  /**
   * UserToken updateMany
   */
  export type UserTokenUpdateManyArgs = {
    /**
     * The data used to update UserTokens.
     * 
    **/
    data: XOR<UserTokenUpdateManyMutationInput, UserTokenUncheckedUpdateManyInput>
    /**
     * Filter which UserTokens to update
     * 
    **/
    where?: UserTokenWhereInput
  }


  /**
   * UserToken upsert
   */
  export type UserTokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * The filter to search for the UserToken to update in case it exists.
     * 
    **/
    where: UserTokenWhereUniqueInput
    /**
     * In case the UserToken found by the `where` argument doesn't exist, create a new UserToken with this data.
     * 
    **/
    create: XOR<UserTokenCreateInput, UserTokenUncheckedCreateInput>
    /**
     * In case the UserToken was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserTokenUpdateInput, UserTokenUncheckedUpdateInput>
  }


  /**
   * UserToken delete
   */
  export type UserTokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
    /**
     * Filter which UserToken to delete.
     * 
    **/
    where: UserTokenWhereUniqueInput
  }


  /**
   * UserToken deleteMany
   */
  export type UserTokenDeleteManyArgs = {
    /**
     * Filter which UserTokens to delete
     * 
    **/
    where?: UserTokenWhereInput
  }


  /**
   * UserToken without action
   */
  export type UserTokenArgs = {
    /**
     * Select specific fields to fetch from the UserToken
     * 
    **/
    select?: UserTokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserTokenInclude | null
  }



  /**
   * Model Test
   */


  export type AggregateTest = {
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  export type TestAvgAggregateOutputType = {
    id: number | null
  }

  export type TestSumAggregateOutputType = {
    id: number | null
  }

  export type TestMinAggregateOutputType = {
    id: number | null
    test1: string | null
    test2: string | null
  }

  export type TestMaxAggregateOutputType = {
    id: number | null
    test1: string | null
    test2: string | null
  }

  export type TestCountAggregateOutputType = {
    id: number
    test1: number
    test2: number
    _all: number
  }


  export type TestAvgAggregateInputType = {
    id?: true
  }

  export type TestSumAggregateInputType = {
    id?: true
  }

  export type TestMinAggregateInputType = {
    id?: true
    test1?: true
    test2?: true
  }

  export type TestMaxAggregateInputType = {
    id?: true
    test1?: true
    test2?: true
  }

  export type TestCountAggregateInputType = {
    id?: true
    test1?: true
    test2?: true
    _all?: true
  }

  export type TestAggregateArgs = {
    /**
     * Filter which Test to aggregate.
     * 
    **/
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     * 
    **/
    orderBy?: Enumerable<TestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestMaxAggregateInputType
  }

  export type GetTestAggregateType<T extends TestAggregateArgs> = {
        [P in keyof T & keyof AggregateTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTest[P]>
      : GetScalarType<T[P], AggregateTest[P]>
  }




  export type TestGroupByArgs = {
    where?: TestWhereInput
    orderBy?: Enumerable<TestOrderByWithAggregationInput>
    by: Array<TestScalarFieldEnum>
    having?: TestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestCountAggregateInputType | true
    _avg?: TestAvgAggregateInputType
    _sum?: TestSumAggregateInputType
    _min?: TestMinAggregateInputType
    _max?: TestMaxAggregateInputType
  }


  export type TestGroupByOutputType = {
    id: number
    test1: string
    test2: string | null
    _count: TestCountAggregateOutputType | null
    _avg: TestAvgAggregateOutputType | null
    _sum: TestSumAggregateOutputType | null
    _min: TestMinAggregateOutputType | null
    _max: TestMaxAggregateOutputType | null
  }

  type GetTestGroupByPayload<T extends TestGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestGroupByOutputType[P]>
            : GetScalarType<T[P], TestGroupByOutputType[P]>
        }
      >
    >


  export type TestSelect = {
    id?: boolean
    test1?: boolean
    test2?: boolean
  }

  export type TestGetPayload<
    S extends boolean | null | undefined | TestArgs,
    U = keyof S
      > = S extends true
        ? Test
    : S extends undefined
    ? never
    : S extends TestArgs | TestFindManyArgs
    ?'include' extends U
    ? Test 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Test ? Test[P] : never
  } 
    : Test
  : Test


  type TestCountArgs = Merge<
    Omit<TestFindManyArgs, 'select' | 'include'> & {
      select?: TestCountAggregateInputType | true
    }
  >

  export interface TestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Test that matches the filter.
     * @param {TestFindUniqueArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Test'> extends True ? CheckSelect<T, Prisma__TestClient<Test>, Prisma__TestClient<TestGetPayload<T>>> : CheckSelect<T, Prisma__TestClient<Test | null >, Prisma__TestClient<TestGetPayload<T> | null >>

    /**
     * Find the first Test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindFirstArgs} args - Arguments to find a Test
     * @example
     * // Get one Test
     * const test = await prisma.test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Test'> extends True ? CheckSelect<T, Prisma__TestClient<Test>, Prisma__TestClient<TestGetPayload<T>>> : CheckSelect<T, Prisma__TestClient<Test | null >, Prisma__TestClient<TestGetPayload<T> | null >>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.test.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testWithIdOnly = await prisma.test.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TestFindManyArgs>(
      args?: SelectSubset<T, TestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Test>>, PrismaPromise<Array<TestGetPayload<T>>>>

    /**
     * Create a Test.
     * @param {TestCreateArgs} args - Arguments to create a Test.
     * @example
     * // Create one Test
     * const Test = await prisma.test.create({
     *   data: {
     *     // ... data to create a Test
     *   }
     * })
     * 
    **/
    create<T extends TestCreateArgs>(
      args: SelectSubset<T, TestCreateArgs>
    ): CheckSelect<T, Prisma__TestClient<Test>, Prisma__TestClient<TestGetPayload<T>>>

    /**
     * Create many Tests.
     *     @param {TestCreateManyArgs} args - Arguments to create many Tests.
     *     @example
     *     // Create many Tests
     *     const test = await prisma.test.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestCreateManyArgs>(
      args?: SelectSubset<T, TestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Test.
     * @param {TestDeleteArgs} args - Arguments to delete one Test.
     * @example
     * // Delete one Test
     * const Test = await prisma.test.delete({
     *   where: {
     *     // ... filter to delete one Test
     *   }
     * })
     * 
    **/
    delete<T extends TestDeleteArgs>(
      args: SelectSubset<T, TestDeleteArgs>
    ): CheckSelect<T, Prisma__TestClient<Test>, Prisma__TestClient<TestGetPayload<T>>>

    /**
     * Update one Test.
     * @param {TestUpdateArgs} args - Arguments to update one Test.
     * @example
     * // Update one Test
     * const test = await prisma.test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestUpdateArgs>(
      args: SelectSubset<T, TestUpdateArgs>
    ): CheckSelect<T, Prisma__TestClient<Test>, Prisma__TestClient<TestGetPayload<T>>>

    /**
     * Delete zero or more Tests.
     * @param {TestDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestDeleteManyArgs>(
      args?: SelectSubset<T, TestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const test = await prisma.test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestUpdateManyArgs>(
      args: SelectSubset<T, TestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Test.
     * @param {TestUpsertArgs} args - Arguments to update or create a Test.
     * @example
     * // Update or create a Test
     * const test = await prisma.test.upsert({
     *   create: {
     *     // ... data to create a Test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Test we want to update
     *   }
     * })
    **/
    upsert<T extends TestUpsertArgs>(
      args: SelectSubset<T, TestUpsertArgs>
    ): CheckSelect<T, Prisma__TestClient<Test>, Prisma__TestClient<TestGetPayload<T>>>

    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.test.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestCountArgs>(
      args?: Subset<T, TestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAggregateArgs>(args: Subset<T, TestAggregateArgs>): PrismaPromise<GetTestAggregateType<T>>

    /**
     * Group by Test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestGroupByArgs['orderBy'] }
        : { orderBy?: TestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Test findUnique
   */
  export type TestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * Throw an Error if a Test can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Test to fetch.
     * 
    **/
    where: TestWhereUniqueInput
  }


  /**
   * Test findFirst
   */
  export type TestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * Throw an Error if a Test can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Test to fetch.
     * 
    **/
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     * 
    **/
    orderBy?: Enumerable<TestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     * 
    **/
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     * 
    **/
    distinct?: Enumerable<TestScalarFieldEnum>
  }


  /**
   * Test findMany
   */
  export type TestFindManyArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * Filter, which Tests to fetch.
     * 
    **/
    where?: TestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     * 
    **/
    orderBy?: Enumerable<TestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     * 
    **/
    cursor?: TestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TestScalarFieldEnum>
  }


  /**
   * Test create
   */
  export type TestCreateArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * The data needed to create a Test.
     * 
    **/
    data: XOR<TestCreateInput, TestUncheckedCreateInput>
  }


  /**
   * Test createMany
   */
  export type TestCreateManyArgs = {
    /**
     * The data used to create many Tests.
     * 
    **/
    data: Enumerable<TestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Test update
   */
  export type TestUpdateArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * The data needed to update a Test.
     * 
    **/
    data: XOR<TestUpdateInput, TestUncheckedUpdateInput>
    /**
     * Choose, which Test to update.
     * 
    **/
    where: TestWhereUniqueInput
  }


  /**
   * Test updateMany
   */
  export type TestUpdateManyArgs = {
    /**
     * The data used to update Tests.
     * 
    **/
    data: XOR<TestUpdateManyMutationInput, TestUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     * 
    **/
    where?: TestWhereInput
  }


  /**
   * Test upsert
   */
  export type TestUpsertArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * The filter to search for the Test to update in case it exists.
     * 
    **/
    where: TestWhereUniqueInput
    /**
     * In case the Test found by the `where` argument doesn't exist, create a new Test with this data.
     * 
    **/
    create: XOR<TestCreateInput, TestUncheckedCreateInput>
    /**
     * In case the Test was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TestUpdateInput, TestUncheckedUpdateInput>
  }


  /**
   * Test delete
   */
  export type TestDeleteArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
    /**
     * Filter which Test to delete.
     * 
    **/
    where: TestWhereUniqueInput
  }


  /**
   * Test deleteMany
   */
  export type TestDeleteManyArgs = {
    /**
     * Filter which Tests to delete
     * 
    **/
    where?: TestWhereInput
  }


  /**
   * Test without action
   */
  export type TestArgs = {
    /**
     * Select specific fields to fetch from the Test
     * 
    **/
    select?: TestSelect | null
  }



  /**
   * Model UserContactNumber
   */


  export type AggregateUserContactNumber = {
    _count: UserContactNumberCountAggregateOutputType | null
    _min: UserContactNumberMinAggregateOutputType | null
    _max: UserContactNumberMaxAggregateOutputType | null
  }

  export type UserContactNumberMinAggregateOutputType = {
    userId: string | null
    number: string | null
  }

  export type UserContactNumberMaxAggregateOutputType = {
    userId: string | null
    number: string | null
  }

  export type UserContactNumberCountAggregateOutputType = {
    userId: number
    number: number
    _all: number
  }


  export type UserContactNumberMinAggregateInputType = {
    userId?: true
    number?: true
  }

  export type UserContactNumberMaxAggregateInputType = {
    userId?: true
    number?: true
  }

  export type UserContactNumberCountAggregateInputType = {
    userId?: true
    number?: true
    _all?: true
  }

  export type UserContactNumberAggregateArgs = {
    /**
     * Filter which UserContactNumber to aggregate.
     * 
    **/
    where?: UserContactNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContactNumbers to fetch.
     * 
    **/
    orderBy?: Enumerable<UserContactNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserContactNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContactNumbers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContactNumbers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserContactNumbers
    **/
    _count?: true | UserContactNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContactNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContactNumberMaxAggregateInputType
  }

  export type GetUserContactNumberAggregateType<T extends UserContactNumberAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContactNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContactNumber[P]>
      : GetScalarType<T[P], AggregateUserContactNumber[P]>
  }




  export type UserContactNumberGroupByArgs = {
    where?: UserContactNumberWhereInput
    orderBy?: Enumerable<UserContactNumberOrderByWithAggregationInput>
    by: Array<UserContactNumberScalarFieldEnum>
    having?: UserContactNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContactNumberCountAggregateInputType | true
    _min?: UserContactNumberMinAggregateInputType
    _max?: UserContactNumberMaxAggregateInputType
  }


  export type UserContactNumberGroupByOutputType = {
    userId: string
    number: string
    _count: UserContactNumberCountAggregateOutputType | null
    _min: UserContactNumberMinAggregateOutputType | null
    _max: UserContactNumberMaxAggregateOutputType | null
  }

  type GetUserContactNumberGroupByPayload<T extends UserContactNumberGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserContactNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserContactNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserContactNumberGroupByOutputType[P]>
            : GetScalarType<T[P], UserContactNumberGroupByOutputType[P]>
        }
      >
    >


  export type UserContactNumberSelect = {
    userId?: boolean
    number?: boolean
    user?: boolean | UserArgs
  }

  export type UserContactNumberInclude = {
    user?: boolean | UserArgs
  }

  export type UserContactNumberGetPayload<
    S extends boolean | null | undefined | UserContactNumberArgs,
    U = keyof S
      > = S extends true
        ? UserContactNumber
    : S extends undefined
    ? never
    : S extends UserContactNumberArgs | UserContactNumberFindManyArgs
    ?'include' extends U
    ? UserContactNumber  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserContactNumber ? UserContactNumber[P] : never
  } 
    : UserContactNumber
  : UserContactNumber


  type UserContactNumberCountArgs = Merge<
    Omit<UserContactNumberFindManyArgs, 'select' | 'include'> & {
      select?: UserContactNumberCountAggregateInputType | true
    }
  >

  export interface UserContactNumberDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserContactNumber that matches the filter.
     * @param {UserContactNumberFindUniqueArgs} args - Arguments to find a UserContactNumber
     * @example
     * // Get one UserContactNumber
     * const userContactNumber = await prisma.userContactNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserContactNumberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserContactNumberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserContactNumber'> extends True ? CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber>, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T>>> : CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber | null >, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T> | null >>

    /**
     * Find the first UserContactNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactNumberFindFirstArgs} args - Arguments to find a UserContactNumber
     * @example
     * // Get one UserContactNumber
     * const userContactNumber = await prisma.userContactNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserContactNumberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserContactNumberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserContactNumber'> extends True ? CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber>, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T>>> : CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber | null >, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T> | null >>

    /**
     * Find zero or more UserContactNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactNumberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContactNumbers
     * const userContactNumbers = await prisma.userContactNumber.findMany()
     * 
     * // Get first 10 UserContactNumbers
     * const userContactNumbers = await prisma.userContactNumber.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userContactNumberWithUserIdOnly = await prisma.userContactNumber.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserContactNumberFindManyArgs>(
      args?: SelectSubset<T, UserContactNumberFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserContactNumber>>, PrismaPromise<Array<UserContactNumberGetPayload<T>>>>

    /**
     * Create a UserContactNumber.
     * @param {UserContactNumberCreateArgs} args - Arguments to create a UserContactNumber.
     * @example
     * // Create one UserContactNumber
     * const UserContactNumber = await prisma.userContactNumber.create({
     *   data: {
     *     // ... data to create a UserContactNumber
     *   }
     * })
     * 
    **/
    create<T extends UserContactNumberCreateArgs>(
      args: SelectSubset<T, UserContactNumberCreateArgs>
    ): CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber>, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T>>>

    /**
     * Create many UserContactNumbers.
     *     @param {UserContactNumberCreateManyArgs} args - Arguments to create many UserContactNumbers.
     *     @example
     *     // Create many UserContactNumbers
     *     const userContactNumber = await prisma.userContactNumber.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserContactNumberCreateManyArgs>(
      args?: SelectSubset<T, UserContactNumberCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserContactNumber.
     * @param {UserContactNumberDeleteArgs} args - Arguments to delete one UserContactNumber.
     * @example
     * // Delete one UserContactNumber
     * const UserContactNumber = await prisma.userContactNumber.delete({
     *   where: {
     *     // ... filter to delete one UserContactNumber
     *   }
     * })
     * 
    **/
    delete<T extends UserContactNumberDeleteArgs>(
      args: SelectSubset<T, UserContactNumberDeleteArgs>
    ): CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber>, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T>>>

    /**
     * Update one UserContactNumber.
     * @param {UserContactNumberUpdateArgs} args - Arguments to update one UserContactNumber.
     * @example
     * // Update one UserContactNumber
     * const userContactNumber = await prisma.userContactNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserContactNumberUpdateArgs>(
      args: SelectSubset<T, UserContactNumberUpdateArgs>
    ): CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber>, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T>>>

    /**
     * Delete zero or more UserContactNumbers.
     * @param {UserContactNumberDeleteManyArgs} args - Arguments to filter UserContactNumbers to delete.
     * @example
     * // Delete a few UserContactNumbers
     * const { count } = await prisma.userContactNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserContactNumberDeleteManyArgs>(
      args?: SelectSubset<T, UserContactNumberDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContactNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContactNumbers
     * const userContactNumber = await prisma.userContactNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserContactNumberUpdateManyArgs>(
      args: SelectSubset<T, UserContactNumberUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContactNumber.
     * @param {UserContactNumberUpsertArgs} args - Arguments to update or create a UserContactNumber.
     * @example
     * // Update or create a UserContactNumber
     * const userContactNumber = await prisma.userContactNumber.upsert({
     *   create: {
     *     // ... data to create a UserContactNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContactNumber we want to update
     *   }
     * })
    **/
    upsert<T extends UserContactNumberUpsertArgs>(
      args: SelectSubset<T, UserContactNumberUpsertArgs>
    ): CheckSelect<T, Prisma__UserContactNumberClient<UserContactNumber>, Prisma__UserContactNumberClient<UserContactNumberGetPayload<T>>>

    /**
     * Count the number of UserContactNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactNumberCountArgs} args - Arguments to filter UserContactNumbers to count.
     * @example
     * // Count the number of UserContactNumbers
     * const count = await prisma.userContactNumber.count({
     *   where: {
     *     // ... the filter for the UserContactNumbers we want to count
     *   }
     * })
    **/
    count<T extends UserContactNumberCountArgs>(
      args?: Subset<T, UserContactNumberCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContactNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContactNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContactNumberAggregateArgs>(args: Subset<T, UserContactNumberAggregateArgs>): PrismaPromise<GetUserContactNumberAggregateType<T>>

    /**
     * Group by UserContactNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserContactNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserContactNumberGroupByArgs['orderBy'] }
        : { orderBy?: UserContactNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserContactNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContactNumberGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserContactNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserContactNumberClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserContactNumber findUnique
   */
  export type UserContactNumberFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * Throw an Error if a UserContactNumber can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserContactNumber to fetch.
     * 
    **/
    where: UserContactNumberWhereUniqueInput
  }


  /**
   * UserContactNumber findFirst
   */
  export type UserContactNumberFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * Throw an Error if a UserContactNumber can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserContactNumber to fetch.
     * 
    **/
    where?: UserContactNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContactNumbers to fetch.
     * 
    **/
    orderBy?: Enumerable<UserContactNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContactNumbers.
     * 
    **/
    cursor?: UserContactNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContactNumbers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContactNumbers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContactNumbers.
     * 
    **/
    distinct?: Enumerable<UserContactNumberScalarFieldEnum>
  }


  /**
   * UserContactNumber findMany
   */
  export type UserContactNumberFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * Filter, which UserContactNumbers to fetch.
     * 
    **/
    where?: UserContactNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContactNumbers to fetch.
     * 
    **/
    orderBy?: Enumerable<UserContactNumberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserContactNumbers.
     * 
    **/
    cursor?: UserContactNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContactNumbers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContactNumbers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserContactNumberScalarFieldEnum>
  }


  /**
   * UserContactNumber create
   */
  export type UserContactNumberCreateArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * The data needed to create a UserContactNumber.
     * 
    **/
    data: XOR<UserContactNumberCreateInput, UserContactNumberUncheckedCreateInput>
  }


  /**
   * UserContactNumber createMany
   */
  export type UserContactNumberCreateManyArgs = {
    /**
     * The data used to create many UserContactNumbers.
     * 
    **/
    data: Enumerable<UserContactNumberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserContactNumber update
   */
  export type UserContactNumberUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * The data needed to update a UserContactNumber.
     * 
    **/
    data: XOR<UserContactNumberUpdateInput, UserContactNumberUncheckedUpdateInput>
    /**
     * Choose, which UserContactNumber to update.
     * 
    **/
    where: UserContactNumberWhereUniqueInput
  }


  /**
   * UserContactNumber updateMany
   */
  export type UserContactNumberUpdateManyArgs = {
    /**
     * The data used to update UserContactNumbers.
     * 
    **/
    data: XOR<UserContactNumberUpdateManyMutationInput, UserContactNumberUncheckedUpdateManyInput>
    /**
     * Filter which UserContactNumbers to update
     * 
    **/
    where?: UserContactNumberWhereInput
  }


  /**
   * UserContactNumber upsert
   */
  export type UserContactNumberUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * The filter to search for the UserContactNumber to update in case it exists.
     * 
    **/
    where: UserContactNumberWhereUniqueInput
    /**
     * In case the UserContactNumber found by the `where` argument doesn't exist, create a new UserContactNumber with this data.
     * 
    **/
    create: XOR<UserContactNumberCreateInput, UserContactNumberUncheckedCreateInput>
    /**
     * In case the UserContactNumber was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserContactNumberUpdateInput, UserContactNumberUncheckedUpdateInput>
  }


  /**
   * UserContactNumber delete
   */
  export type UserContactNumberDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
    /**
     * Filter which UserContactNumber to delete.
     * 
    **/
    where: UserContactNumberWhereUniqueInput
  }


  /**
   * UserContactNumber deleteMany
   */
  export type UserContactNumberDeleteManyArgs = {
    /**
     * Filter which UserContactNumbers to delete
     * 
    **/
    where?: UserContactNumberWhereInput
  }


  /**
   * UserContactNumber without action
   */
  export type UserContactNumberArgs = {
    /**
     * Select specific fields to fetch from the UserContactNumber
     * 
    **/
    select?: UserContactNumberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserContactNumberInclude | null
  }



  /**
   * Model UserExperience
   */


  export type AggregateUserExperience = {
    _count: UserExperienceCountAggregateOutputType | null
    _min: UserExperienceMinAggregateOutputType | null
    _max: UserExperienceMaxAggregateOutputType | null
  }

  export type UserExperienceMinAggregateOutputType = {
    userId: string | null
    experience: string | null
  }

  export type UserExperienceMaxAggregateOutputType = {
    userId: string | null
    experience: string | null
  }

  export type UserExperienceCountAggregateOutputType = {
    userId: number
    experience: number
    _all: number
  }


  export type UserExperienceMinAggregateInputType = {
    userId?: true
    experience?: true
  }

  export type UserExperienceMaxAggregateInputType = {
    userId?: true
    experience?: true
  }

  export type UserExperienceCountAggregateInputType = {
    userId?: true
    experience?: true
    _all?: true
  }

  export type UserExperienceAggregateArgs = {
    /**
     * Filter which UserExperience to aggregate.
     * 
    **/
    where?: UserExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<UserExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserExperiences
    **/
    _count?: true | UserExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserExperienceMaxAggregateInputType
  }

  export type GetUserExperienceAggregateType<T extends UserExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserExperience[P]>
      : GetScalarType<T[P], AggregateUserExperience[P]>
  }




  export type UserExperienceGroupByArgs = {
    where?: UserExperienceWhereInput
    orderBy?: Enumerable<UserExperienceOrderByWithAggregationInput>
    by: Array<UserExperienceScalarFieldEnum>
    having?: UserExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserExperienceCountAggregateInputType | true
    _min?: UserExperienceMinAggregateInputType
    _max?: UserExperienceMaxAggregateInputType
  }


  export type UserExperienceGroupByOutputType = {
    userId: string
    experience: string
    _count: UserExperienceCountAggregateOutputType | null
    _min: UserExperienceMinAggregateOutputType | null
    _max: UserExperienceMaxAggregateOutputType | null
  }

  type GetUserExperienceGroupByPayload<T extends UserExperienceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], UserExperienceGroupByOutputType[P]>
        }
      >
    >


  export type UserExperienceSelect = {
    userId?: boolean
    experience?: boolean
    user?: boolean | UserArgs
  }

  export type UserExperienceInclude = {
    user?: boolean | UserArgs
  }

  export type UserExperienceGetPayload<
    S extends boolean | null | undefined | UserExperienceArgs,
    U = keyof S
      > = S extends true
        ? UserExperience
    : S extends undefined
    ? never
    : S extends UserExperienceArgs | UserExperienceFindManyArgs
    ?'include' extends U
    ? UserExperience  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserExperience ? UserExperience[P] : never
  } 
    : UserExperience
  : UserExperience


  type UserExperienceCountArgs = Merge<
    Omit<UserExperienceFindManyArgs, 'select' | 'include'> & {
      select?: UserExperienceCountAggregateInputType | true
    }
  >

  export interface UserExperienceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserExperience that matches the filter.
     * @param {UserExperienceFindUniqueArgs} args - Arguments to find a UserExperience
     * @example
     * // Get one UserExperience
     * const userExperience = await prisma.userExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserExperienceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserExperienceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserExperience'> extends True ? CheckSelect<T, Prisma__UserExperienceClient<UserExperience>, Prisma__UserExperienceClient<UserExperienceGetPayload<T>>> : CheckSelect<T, Prisma__UserExperienceClient<UserExperience | null >, Prisma__UserExperienceClient<UserExperienceGetPayload<T> | null >>

    /**
     * Find the first UserExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserExperienceFindFirstArgs} args - Arguments to find a UserExperience
     * @example
     * // Get one UserExperience
     * const userExperience = await prisma.userExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserExperienceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserExperienceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserExperience'> extends True ? CheckSelect<T, Prisma__UserExperienceClient<UserExperience>, Prisma__UserExperienceClient<UserExperienceGetPayload<T>>> : CheckSelect<T, Prisma__UserExperienceClient<UserExperience | null >, Prisma__UserExperienceClient<UserExperienceGetPayload<T> | null >>

    /**
     * Find zero or more UserExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserExperienceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserExperiences
     * const userExperiences = await prisma.userExperience.findMany()
     * 
     * // Get first 10 UserExperiences
     * const userExperiences = await prisma.userExperience.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userExperienceWithUserIdOnly = await prisma.userExperience.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserExperienceFindManyArgs>(
      args?: SelectSubset<T, UserExperienceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserExperience>>, PrismaPromise<Array<UserExperienceGetPayload<T>>>>

    /**
     * Create a UserExperience.
     * @param {UserExperienceCreateArgs} args - Arguments to create a UserExperience.
     * @example
     * // Create one UserExperience
     * const UserExperience = await prisma.userExperience.create({
     *   data: {
     *     // ... data to create a UserExperience
     *   }
     * })
     * 
    **/
    create<T extends UserExperienceCreateArgs>(
      args: SelectSubset<T, UserExperienceCreateArgs>
    ): CheckSelect<T, Prisma__UserExperienceClient<UserExperience>, Prisma__UserExperienceClient<UserExperienceGetPayload<T>>>

    /**
     * Create many UserExperiences.
     *     @param {UserExperienceCreateManyArgs} args - Arguments to create many UserExperiences.
     *     @example
     *     // Create many UserExperiences
     *     const userExperience = await prisma.userExperience.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserExperienceCreateManyArgs>(
      args?: SelectSubset<T, UserExperienceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserExperience.
     * @param {UserExperienceDeleteArgs} args - Arguments to delete one UserExperience.
     * @example
     * // Delete one UserExperience
     * const UserExperience = await prisma.userExperience.delete({
     *   where: {
     *     // ... filter to delete one UserExperience
     *   }
     * })
     * 
    **/
    delete<T extends UserExperienceDeleteArgs>(
      args: SelectSubset<T, UserExperienceDeleteArgs>
    ): CheckSelect<T, Prisma__UserExperienceClient<UserExperience>, Prisma__UserExperienceClient<UserExperienceGetPayload<T>>>

    /**
     * Update one UserExperience.
     * @param {UserExperienceUpdateArgs} args - Arguments to update one UserExperience.
     * @example
     * // Update one UserExperience
     * const userExperience = await prisma.userExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserExperienceUpdateArgs>(
      args: SelectSubset<T, UserExperienceUpdateArgs>
    ): CheckSelect<T, Prisma__UserExperienceClient<UserExperience>, Prisma__UserExperienceClient<UserExperienceGetPayload<T>>>

    /**
     * Delete zero or more UserExperiences.
     * @param {UserExperienceDeleteManyArgs} args - Arguments to filter UserExperiences to delete.
     * @example
     * // Delete a few UserExperiences
     * const { count } = await prisma.userExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserExperienceDeleteManyArgs>(
      args?: SelectSubset<T, UserExperienceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserExperiences
     * const userExperience = await prisma.userExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserExperienceUpdateManyArgs>(
      args: SelectSubset<T, UserExperienceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserExperience.
     * @param {UserExperienceUpsertArgs} args - Arguments to update or create a UserExperience.
     * @example
     * // Update or create a UserExperience
     * const userExperience = await prisma.userExperience.upsert({
     *   create: {
     *     // ... data to create a UserExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserExperience we want to update
     *   }
     * })
    **/
    upsert<T extends UserExperienceUpsertArgs>(
      args: SelectSubset<T, UserExperienceUpsertArgs>
    ): CheckSelect<T, Prisma__UserExperienceClient<UserExperience>, Prisma__UserExperienceClient<UserExperienceGetPayload<T>>>

    /**
     * Count the number of UserExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserExperienceCountArgs} args - Arguments to filter UserExperiences to count.
     * @example
     * // Count the number of UserExperiences
     * const count = await prisma.userExperience.count({
     *   where: {
     *     // ... the filter for the UserExperiences we want to count
     *   }
     * })
    **/
    count<T extends UserExperienceCountArgs>(
      args?: Subset<T, UserExperienceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserExperienceAggregateArgs>(args: Subset<T, UserExperienceAggregateArgs>): PrismaPromise<GetUserExperienceAggregateType<T>>

    /**
     * Group by UserExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserExperienceGroupByArgs['orderBy'] }
        : { orderBy?: UserExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserExperienceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserExperienceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserExperience findUnique
   */
  export type UserExperienceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * Throw an Error if a UserExperience can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserExperience to fetch.
     * 
    **/
    where: UserExperienceWhereUniqueInput
  }


  /**
   * UserExperience findFirst
   */
  export type UserExperienceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * Throw an Error if a UserExperience can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserExperience to fetch.
     * 
    **/
    where?: UserExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<UserExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserExperiences.
     * 
    **/
    cursor?: UserExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserExperiences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserExperiences.
     * 
    **/
    distinct?: Enumerable<UserExperienceScalarFieldEnum>
  }


  /**
   * UserExperience findMany
   */
  export type UserExperienceFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * Filter, which UserExperiences to fetch.
     * 
    **/
    where?: UserExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserExperiences to fetch.
     * 
    **/
    orderBy?: Enumerable<UserExperienceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserExperiences.
     * 
    **/
    cursor?: UserExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserExperiences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserExperiences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserExperienceScalarFieldEnum>
  }


  /**
   * UserExperience create
   */
  export type UserExperienceCreateArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * The data needed to create a UserExperience.
     * 
    **/
    data: XOR<UserExperienceCreateInput, UserExperienceUncheckedCreateInput>
  }


  /**
   * UserExperience createMany
   */
  export type UserExperienceCreateManyArgs = {
    /**
     * The data used to create many UserExperiences.
     * 
    **/
    data: Enumerable<UserExperienceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserExperience update
   */
  export type UserExperienceUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * The data needed to update a UserExperience.
     * 
    **/
    data: XOR<UserExperienceUpdateInput, UserExperienceUncheckedUpdateInput>
    /**
     * Choose, which UserExperience to update.
     * 
    **/
    where: UserExperienceWhereUniqueInput
  }


  /**
   * UserExperience updateMany
   */
  export type UserExperienceUpdateManyArgs = {
    /**
     * The data used to update UserExperiences.
     * 
    **/
    data: XOR<UserExperienceUpdateManyMutationInput, UserExperienceUncheckedUpdateManyInput>
    /**
     * Filter which UserExperiences to update
     * 
    **/
    where?: UserExperienceWhereInput
  }


  /**
   * UserExperience upsert
   */
  export type UserExperienceUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * The filter to search for the UserExperience to update in case it exists.
     * 
    **/
    where: UserExperienceWhereUniqueInput
    /**
     * In case the UserExperience found by the `where` argument doesn't exist, create a new UserExperience with this data.
     * 
    **/
    create: XOR<UserExperienceCreateInput, UserExperienceUncheckedCreateInput>
    /**
     * In case the UserExperience was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserExperienceUpdateInput, UserExperienceUncheckedUpdateInput>
  }


  /**
   * UserExperience delete
   */
  export type UserExperienceDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
    /**
     * Filter which UserExperience to delete.
     * 
    **/
    where: UserExperienceWhereUniqueInput
  }


  /**
   * UserExperience deleteMany
   */
  export type UserExperienceDeleteManyArgs = {
    /**
     * Filter which UserExperiences to delete
     * 
    **/
    where?: UserExperienceWhereInput
  }


  /**
   * UserExperience without action
   */
  export type UserExperienceArgs = {
    /**
     * Select specific fields to fetch from the UserExperience
     * 
    **/
    select?: UserExperienceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserExperienceInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    passwordSalt: 'passwordSalt',
    name: 'name',
    dateOfBirth: 'dateOfBirth',
    companyId: 'companyId',
    created: 'created',
    suspended: 'suspended',
    validated: 'validated'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserScoutedScalarFieldEnum: {
    userIdScout: 'userIdScout',
    userId: 'userId',
    date: 'date'
  };

  export type UserScoutedScalarFieldEnum = (typeof UserScoutedScalarFieldEnum)[keyof typeof UserScoutedScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    role: 'role'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const UserPermissionsScalarFieldEnum: {
    userId: 'userId',
    permissionType: 'permissionType',
    permissionCategory: 'permissionCategory',
    permissionTenant: 'permissionTenant'
  };

  export type UserPermissionsScalarFieldEnum = (typeof UserPermissionsScalarFieldEnum)[keyof typeof UserPermissionsScalarFieldEnum]


  export const RolePermissionsScalarFieldEnum: {
    role: 'role',
    permissionType: 'permissionType',
    permissionCategory: 'permissionCategory',
    permissionTenant: 'permissionTenant'
  };

  export type RolePermissionsScalarFieldEnum = (typeof RolePermissionsScalarFieldEnum)[keyof typeof RolePermissionsScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    userId: 'userId',
    profilePicture: 'profilePicture',
    bio: 'bio',
    employmentStatus: 'employmentStatus',
    openToOffers: 'openToOffers'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserTagScalarFieldEnum: {
    userId: 'userId',
    tag: 'tag'
  };

  export type UserTagScalarFieldEnum = (typeof UserTagScalarFieldEnum)[keyof typeof UserTagScalarFieldEnum]


  export const UserSocialMediaScalarFieldEnum: {
    userId: 'userId',
    type: 'type',
    link: 'link'
  };

  export type UserSocialMediaScalarFieldEnum = (typeof UserSocialMediaScalarFieldEnum)[keyof typeof UserSocialMediaScalarFieldEnum]


  export const UserLocationScalarFieldEnum: {
    userId: 'userId',
    location: 'location'
  };

  export type UserLocationScalarFieldEnum = (typeof UserLocationScalarFieldEnum)[keyof typeof UserLocationScalarFieldEnum]


  export const UserEmailScalarFieldEnum: {
    userId: 'userId',
    email: 'email'
  };

  export type UserEmailScalarFieldEnum = (typeof UserEmailScalarFieldEnum)[keyof typeof UserEmailScalarFieldEnum]


  export const UserProfileFileScalarFieldEnum: {
    fileId: 'fileId',
    userId: 'userId',
    filePath: 'filePath',
    fileCategory: 'fileCategory',
    fileExtension: 'fileExtension'
  };

  export type UserProfileFileScalarFieldEnum = (typeof UserProfileFileScalarFieldEnum)[keyof typeof UserProfileFileScalarFieldEnum]


  export const UserDegreeScalarFieldEnum: {
    userID: 'userID',
    degreeType: 'degreeType',
    degreeName: 'degreeName'
  };

  export type UserDegreeScalarFieldEnum = (typeof UserDegreeScalarFieldEnum)[keyof typeof UserDegreeScalarFieldEnum]


  export const ShortScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    description: 'description',
    link: 'link',
    thumbnail: 'thumbnail',
    datePosted: 'datePosted',
    archived: 'archived'
  };

  export type ShortScalarFieldEnum = (typeof ShortScalarFieldEnum)[keyof typeof ShortScalarFieldEnum]


  export const ShortTagScalarFieldEnum: {
    shortId: 'shortId',
    tag: 'tag'
  };

  export type ShortTagScalarFieldEnum = (typeof ShortTagScalarFieldEnum)[keyof typeof ShortTagScalarFieldEnum]


  export const ShortReportScalarFieldEnum: {
    shortId: 'shortId',
    userId: 'userId',
    reason: 'reason'
  };

  export type ShortReportScalarFieldEnum = (typeof ShortReportScalarFieldEnum)[keyof typeof ShortReportScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userIdFrom: 'userIdFrom',
    userIdTo: 'userIdTo',
    data: 'data',
    date: 'date',
    seen: 'seen'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    date: 'date',
    archived: 'archived'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const BlogCommentScalarFieldEnum: {
    id: 'id',
    blogId: 'blogId',
    userId: 'userId',
    content: 'content',
    date: 'date'
  };

  export type BlogCommentScalarFieldEnum = (typeof BlogCommentScalarFieldEnum)[keyof typeof BlogCommentScalarFieldEnum]


  export const BlogMediaScalarFieldEnum: {
    blogId: 'blogId',
    media: 'media'
  };

  export type BlogMediaScalarFieldEnum = (typeof BlogMediaScalarFieldEnum)[keyof typeof BlogMediaScalarFieldEnum]


  export const UserTokenScalarFieldEnum: {
    userId: 'userId',
    userToken: 'userToken',
    userTokenType: 'userTokenType',
    userTokenExpiration: 'userTokenExpiration'
  };

  export type UserTokenScalarFieldEnum = (typeof UserTokenScalarFieldEnum)[keyof typeof UserTokenScalarFieldEnum]


  export const TestScalarFieldEnum: {
    id: 'id',
    test1: 'test1',
    test2: 'test2'
  };

  export type TestScalarFieldEnum = (typeof TestScalarFieldEnum)[keyof typeof TestScalarFieldEnum]


  export const UserContactNumberScalarFieldEnum: {
    userId: 'userId',
    number: 'number'
  };

  export type UserContactNumberScalarFieldEnum = (typeof UserContactNumberScalarFieldEnum)[keyof typeof UserContactNumberScalarFieldEnum]


  export const UserExperienceScalarFieldEnum: {
    userId: 'userId',
    experience: 'experience'
  };

  export type UserExperienceScalarFieldEnum = (typeof UserExperienceScalarFieldEnum)[keyof typeof UserExperienceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: 'JsonNull'
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: 'DbNull',
    JsonNull: 'JsonNull',
    AnyNull: 'AnyNull'
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    password?: StringNullableFilter | string | null
    passwordSalt?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    dateOfBirth?: DateTimeNullableFilter | Date | string | null
    companyId?: StringNullableFilter | string | null
    created?: DateTimeFilter | Date | string
    suspended?: BoolFilter | boolean
    validated?: BoolFilter | boolean
    company?: XOR<UserRelationFilter, UserWhereInput> | null
    User?: UserListRelationFilter
    userScout?: UserScoutedListRelationFilter
    userScouted?: UserScoutedListRelationFilter
    UserRole?: UserRoleListRelationFilter
    UserPermissions?: UserPermissionsListRelationFilter
    UserProfile?: UserProfileListRelationFilter
    UserTag?: UserTagListRelationFilter
    UserContactNumber?: UserContactNumberListRelationFilter
    UserDegree?: UserDegreeListRelationFilter
    UserExperience?: UserExperienceListRelationFilter
    UserSocialMedia?: UserSocialMediaListRelationFilter
    UserLocation?: UserLocationListRelationFilter
    UserEmail?: UserEmailListRelationFilter
    UserProfileFile?: UserProfileFileListRelationFilter
    Short?: ShortListRelationFilter
    ShortReport?: ShortReportListRelationFilter
    notificationFrom?: NotificationListRelationFilter
    notificationTo?: NotificationListRelationFilter
    Blog?: BlogListRelationFilter
    BlogComment?: BlogCommentListRelationFilter
    UserToken?: UserTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordSalt?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    companyId?: SortOrder
    created?: SortOrder
    suspended?: SortOrder
    validated?: SortOrder
    company?: UserOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
    userScout?: UserScoutedOrderByRelationAggregateInput
    userScouted?: UserScoutedOrderByRelationAggregateInput
    UserRole?: UserRoleOrderByRelationAggregateInput
    UserPermissions?: UserPermissionsOrderByRelationAggregateInput
    UserProfile?: UserProfileOrderByRelationAggregateInput
    UserTag?: UserTagOrderByRelationAggregateInput
    UserContactNumber?: UserContactNumberOrderByRelationAggregateInput
    UserDegree?: UserDegreeOrderByRelationAggregateInput
    UserExperience?: UserExperienceOrderByRelationAggregateInput
    UserSocialMedia?: UserSocialMediaOrderByRelationAggregateInput
    UserLocation?: UserLocationOrderByRelationAggregateInput
    UserEmail?: UserEmailOrderByRelationAggregateInput
    UserProfileFile?: UserProfileFileOrderByRelationAggregateInput
    Short?: ShortOrderByRelationAggregateInput
    ShortReport?: ShortReportOrderByRelationAggregateInput
    notificationFrom?: NotificationOrderByRelationAggregateInput
    notificationTo?: NotificationOrderByRelationAggregateInput
    Blog?: BlogOrderByRelationAggregateInput
    BlogComment?: BlogCommentOrderByRelationAggregateInput
    UserToken?: UserTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordSalt?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    companyId?: SortOrder
    created?: SortOrder
    suspended?: SortOrder
    validated?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringNullableWithAggregatesFilter | string | null
    passwordSalt?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter | Date | string | null
    companyId?: StringNullableWithAggregatesFilter | string | null
    created?: DateTimeWithAggregatesFilter | Date | string
    suspended?: BoolWithAggregatesFilter | boolean
    validated?: BoolWithAggregatesFilter | boolean
  }

  export type UserScoutedWhereInput = {
    AND?: Enumerable<UserScoutedWhereInput>
    OR?: Enumerable<UserScoutedWhereInput>
    NOT?: Enumerable<UserScoutedWhereInput>
    userIdScout?: StringFilter | string
    userId?: StringFilter | string
    date?: DateTimeNullableFilter | Date | string | null
    userScout?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserScoutedOrderByWithRelationInput = {
    userIdScout?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    userScout?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserScoutedWhereUniqueInput = {
    userIdScout?: string
  }

  export type UserScoutedOrderByWithAggregationInput = {
    userIdScout?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    _count?: UserScoutedCountOrderByAggregateInput
    _max?: UserScoutedMaxOrderByAggregateInput
    _min?: UserScoutedMinOrderByAggregateInput
  }

  export type UserScoutedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScoutedScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScoutedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScoutedScalarWhereWithAggregatesInput>
    userIdScout?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserRoleWhereInput = {
    AND?: Enumerable<UserRoleWhereInput>
    OR?: Enumerable<UserRoleWhereInput>
    NOT?: Enumerable<UserRoleWhereInput>
    userId?: StringFilter | string
    role?: EnumRoleFilter | Role
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    role?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = {
    userId_role?: UserRoleUserIdRoleCompoundUniqueInput
  }

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    role?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserRoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserRoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserRoleScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
  }

  export type UserPermissionsWhereInput = {
    AND?: Enumerable<UserPermissionsWhereInput>
    OR?: Enumerable<UserPermissionsWhereInput>
    NOT?: Enumerable<UserPermissionsWhereInput>
    userId?: StringFilter | string
    permissionType?: EnumPermissionTypeFilter | PermissionType
    permissionCategory?: EnumPermissionCategoryFilter | PermissionCategory
    permissionTenant?: EnumPermissionTenantFilter | PermissionTenant
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPermissionsOrderByWithRelationInput = {
    userId?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPermissionsWhereUniqueInput = {
    userId_permissionType_permissionCategory_permissionTenant?: UserPermissionsUserIdPermissionTypePermissionCategoryPermissionTenantCompoundUniqueInput
  }

  export type UserPermissionsOrderByWithAggregationInput = {
    userId?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
    _count?: UserPermissionsCountOrderByAggregateInput
    _max?: UserPermissionsMaxOrderByAggregateInput
    _min?: UserPermissionsMinOrderByAggregateInput
  }

  export type UserPermissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserPermissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserPermissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserPermissionsScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    permissionType?: EnumPermissionTypeWithAggregatesFilter | PermissionType
    permissionCategory?: EnumPermissionCategoryWithAggregatesFilter | PermissionCategory
    permissionTenant?: EnumPermissionTenantWithAggregatesFilter | PermissionTenant
  }

  export type RolePermissionsWhereInput = {
    AND?: Enumerable<RolePermissionsWhereInput>
    OR?: Enumerable<RolePermissionsWhereInput>
    NOT?: Enumerable<RolePermissionsWhereInput>
    role?: EnumRoleFilter | Role
    permissionType?: EnumPermissionTypeFilter | PermissionType
    permissionCategory?: EnumPermissionCategoryFilter | PermissionCategory
    permissionTenant?: EnumPermissionTenantFilter | PermissionTenant
  }

  export type RolePermissionsOrderByWithRelationInput = {
    role?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type RolePermissionsWhereUniqueInput = {
    role_permissionType_permissionCategory_permissionTenant?: RolePermissionsRolePermissionTypePermissionCategoryPermissionTenantCompoundUniqueInput
  }

  export type RolePermissionsOrderByWithAggregationInput = {
    role?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
    _count?: RolePermissionsCountOrderByAggregateInput
    _max?: RolePermissionsMaxOrderByAggregateInput
    _min?: RolePermissionsMinOrderByAggregateInput
  }

  export type RolePermissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolePermissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolePermissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolePermissionsScalarWhereWithAggregatesInput>
    role?: EnumRoleWithAggregatesFilter | Role
    permissionType?: EnumPermissionTypeWithAggregatesFilter | PermissionType
    permissionCategory?: EnumPermissionCategoryWithAggregatesFilter | PermissionCategory
    permissionTenant?: EnumPermissionTenantWithAggregatesFilter | PermissionTenant
  }

  export type UserProfileWhereInput = {
    AND?: Enumerable<UserProfileWhereInput>
    OR?: Enumerable<UserProfileWhereInput>
    NOT?: Enumerable<UserProfileWhereInput>
    userId?: StringFilter | string
    profilePicture?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    employmentStatus?: BoolFilter | boolean
    openToOffers?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    userId?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    employmentStatus?: SortOrder
    openToOffers?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = {
    userId?: string
  }

  export type UserProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    employmentStatus?: SortOrder
    openToOffers?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserProfileScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    profilePicture?: StringNullableWithAggregatesFilter | string | null
    bio?: StringNullableWithAggregatesFilter | string | null
    employmentStatus?: BoolWithAggregatesFilter | boolean
    openToOffers?: BoolWithAggregatesFilter | boolean
  }

  export type UserTagWhereInput = {
    AND?: Enumerable<UserTagWhereInput>
    OR?: Enumerable<UserTagWhereInput>
    NOT?: Enumerable<UserTagWhereInput>
    userId?: StringFilter | string
    tag?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserTagOrderByWithRelationInput = {
    userId?: SortOrder
    tag?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTagWhereUniqueInput = {
    userId_tag?: UserTagUserIdTagCompoundUniqueInput
  }

  export type UserTagOrderByWithAggregationInput = {
    userId?: SortOrder
    tag?: SortOrder
    _count?: UserTagCountOrderByAggregateInput
    _max?: UserTagMaxOrderByAggregateInput
    _min?: UserTagMinOrderByAggregateInput
  }

  export type UserTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserTagScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    tag?: StringWithAggregatesFilter | string
  }

  export type UserSocialMediaWhereInput = {
    AND?: Enumerable<UserSocialMediaWhereInput>
    OR?: Enumerable<UserSocialMediaWhereInput>
    NOT?: Enumerable<UserSocialMediaWhereInput>
    userId?: StringFilter | string
    type?: EnumSocialMediaFilter | SocialMedia
    link?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSocialMediaOrderByWithRelationInput = {
    userId?: SortOrder
    type?: SortOrder
    link?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSocialMediaWhereUniqueInput = {
    userId?: string
  }

  export type UserSocialMediaOrderByWithAggregationInput = {
    userId?: SortOrder
    type?: SortOrder
    link?: SortOrder
    _count?: UserSocialMediaCountOrderByAggregateInput
    _max?: UserSocialMediaMaxOrderByAggregateInput
    _min?: UserSocialMediaMinOrderByAggregateInput
  }

  export type UserSocialMediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserSocialMediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserSocialMediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserSocialMediaScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    type?: EnumSocialMediaWithAggregatesFilter | SocialMedia
    link?: StringWithAggregatesFilter | string
  }

  export type UserLocationWhereInput = {
    AND?: Enumerable<UserLocationWhereInput>
    OR?: Enumerable<UserLocationWhereInput>
    NOT?: Enumerable<UserLocationWhereInput>
    userId?: StringFilter | string
    location?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserLocationOrderByWithRelationInput = {
    userId?: SortOrder
    location?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLocationWhereUniqueInput = {
    userId?: string
  }

  export type UserLocationOrderByWithAggregationInput = {
    userId?: SortOrder
    location?: SortOrder
    _count?: UserLocationCountOrderByAggregateInput
    _max?: UserLocationMaxOrderByAggregateInput
    _min?: UserLocationMinOrderByAggregateInput
  }

  export type UserLocationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserLocationScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserLocationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserLocationScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
  }

  export type UserEmailWhereInput = {
    AND?: Enumerable<UserEmailWhereInput>
    OR?: Enumerable<UserEmailWhereInput>
    NOT?: Enumerable<UserEmailWhereInput>
    userId?: StringFilter | string
    email?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserEmailOrderByWithRelationInput = {
    userId?: SortOrder
    email?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserEmailWhereUniqueInput = {
    userId?: string
  }

  export type UserEmailOrderByWithAggregationInput = {
    userId?: SortOrder
    email?: SortOrder
    _count?: UserEmailCountOrderByAggregateInput
    _max?: UserEmailMaxOrderByAggregateInput
    _min?: UserEmailMinOrderByAggregateInput
  }

  export type UserEmailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserEmailScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserEmailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserEmailScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
  }

  export type UserProfileFileWhereInput = {
    AND?: Enumerable<UserProfileFileWhereInput>
    OR?: Enumerable<UserProfileFileWhereInput>
    NOT?: Enumerable<UserProfileFileWhereInput>
    fileId?: StringFilter | string
    userId?: StringFilter | string
    filePath?: StringFilter | string
    fileCategory?: EnumFileCategoryNullableFilter | FileCategory | null
    fileExtension?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileFileOrderByWithRelationInput = {
    fileId?: SortOrder
    userId?: SortOrder
    filePath?: SortOrder
    fileCategory?: SortOrder
    fileExtension?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileFileWhereUniqueInput = {
    fileId?: string
  }

  export type UserProfileFileOrderByWithAggregationInput = {
    fileId?: SortOrder
    userId?: SortOrder
    filePath?: SortOrder
    fileCategory?: SortOrder
    fileExtension?: SortOrder
    _count?: UserProfileFileCountOrderByAggregateInput
    _max?: UserProfileFileMaxOrderByAggregateInput
    _min?: UserProfileFileMinOrderByAggregateInput
  }

  export type UserProfileFileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserProfileFileScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserProfileFileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserProfileFileScalarWhereWithAggregatesInput>
    fileId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    filePath?: StringWithAggregatesFilter | string
    fileCategory?: EnumFileCategoryNullableWithAggregatesFilter | FileCategory | null
    fileExtension?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserDegreeWhereInput = {
    AND?: Enumerable<UserDegreeWhereInput>
    OR?: Enumerable<UserDegreeWhereInput>
    NOT?: Enumerable<UserDegreeWhereInput>
    userID?: StringFilter | string
    degreeType?: StringFilter | string
    degreeName?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserDegreeOrderByWithRelationInput = {
    userID?: SortOrder
    degreeType?: SortOrder
    degreeName?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserDegreeWhereUniqueInput = {
    userID?: string
  }

  export type UserDegreeOrderByWithAggregationInput = {
    userID?: SortOrder
    degreeType?: SortOrder
    degreeName?: SortOrder
    _count?: UserDegreeCountOrderByAggregateInput
    _max?: UserDegreeMaxOrderByAggregateInput
    _min?: UserDegreeMinOrderByAggregateInput
  }

  export type UserDegreeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserDegreeScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserDegreeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserDegreeScalarWhereWithAggregatesInput>
    userID?: StringWithAggregatesFilter | string
    degreeType?: StringWithAggregatesFilter | string
    degreeName?: StringWithAggregatesFilter | string
  }

  export type ShortWhereInput = {
    AND?: Enumerable<ShortWhereInput>
    OR?: Enumerable<ShortWhereInput>
    NOT?: Enumerable<ShortWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    description?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    thumbnail?: StringNullableFilter | string | null
    datePosted?: DateTimeFilter | Date | string
    archived?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    shortTag?: ShortTagListRelationFilter
    shortReport?: ShortReportListRelationFilter
  }

  export type ShortOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    link?: SortOrder
    thumbnail?: SortOrder
    datePosted?: SortOrder
    archived?: SortOrder
    user?: UserOrderByWithRelationInput
    shortTag?: ShortTagOrderByRelationAggregateInput
    shortReport?: ShortReportOrderByRelationAggregateInput
  }

  export type ShortWhereUniqueInput = {
    id?: string
  }

  export type ShortOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    link?: SortOrder
    thumbnail?: SortOrder
    datePosted?: SortOrder
    archived?: SortOrder
    _count?: ShortCountOrderByAggregateInput
    _max?: ShortMaxOrderByAggregateInput
    _min?: ShortMinOrderByAggregateInput
  }

  export type ShortScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShortScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShortScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShortScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    link?: StringNullableWithAggregatesFilter | string | null
    thumbnail?: StringNullableWithAggregatesFilter | string | null
    datePosted?: DateTimeWithAggregatesFilter | Date | string
    archived?: BoolWithAggregatesFilter | boolean
  }

  export type ShortTagWhereInput = {
    AND?: Enumerable<ShortTagWhereInput>
    OR?: Enumerable<ShortTagWhereInput>
    NOT?: Enumerable<ShortTagWhereInput>
    shortId?: StringFilter | string
    tag?: StringFilter | string
    short?: XOR<ShortRelationFilter, ShortWhereInput>
  }

  export type ShortTagOrderByWithRelationInput = {
    shortId?: SortOrder
    tag?: SortOrder
    short?: ShortOrderByWithRelationInput
  }

  export type ShortTagWhereUniqueInput = {
    shortId_tag?: ShortTagShortIdTagCompoundUniqueInput
  }

  export type ShortTagOrderByWithAggregationInput = {
    shortId?: SortOrder
    tag?: SortOrder
    _count?: ShortTagCountOrderByAggregateInput
    _max?: ShortTagMaxOrderByAggregateInput
    _min?: ShortTagMinOrderByAggregateInput
  }

  export type ShortTagScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShortTagScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShortTagScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShortTagScalarWhereWithAggregatesInput>
    shortId?: StringWithAggregatesFilter | string
    tag?: StringWithAggregatesFilter | string
  }

  export type ShortReportWhereInput = {
    AND?: Enumerable<ShortReportWhereInput>
    OR?: Enumerable<ShortReportWhereInput>
    NOT?: Enumerable<ShortReportWhereInput>
    shortId?: StringFilter | string
    userId?: StringFilter | string
    reason?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    short?: XOR<ShortRelationFilter, ShortWhereInput>
  }

  export type ShortReportOrderByWithRelationInput = {
    shortId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    user?: UserOrderByWithRelationInput
    short?: ShortOrderByWithRelationInput
  }

  export type ShortReportWhereUniqueInput = {
    shortId_userId?: ShortReportShortIdUserIdCompoundUniqueInput
  }

  export type ShortReportOrderByWithAggregationInput = {
    shortId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    _count?: ShortReportCountOrderByAggregateInput
    _max?: ShortReportMaxOrderByAggregateInput
    _min?: ShortReportMinOrderByAggregateInput
  }

  export type ShortReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShortReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShortReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShortReportScalarWhereWithAggregatesInput>
    shortId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    reason?: StringWithAggregatesFilter | string
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: StringFilter | string
    userIdFrom?: StringNullableFilter | string | null
    userIdTo?: StringFilter | string
    data?: JsonFilter
    date?: DateTimeFilter | Date | string
    seen?: BoolFilter | boolean
    notificationFrom?: XOR<UserRelationFilter, UserWhereInput> | null
    notificationTo?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userIdFrom?: SortOrder
    userIdTo?: SortOrder
    data?: SortOrder
    date?: SortOrder
    seen?: SortOrder
    notificationFrom?: UserOrderByWithRelationInput
    notificationTo?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = {
    id?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userIdFrom?: SortOrder
    userIdTo?: SortOrder
    data?: SortOrder
    date?: SortOrder
    seen?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userIdFrom?: StringNullableWithAggregatesFilter | string | null
    userIdTo?: StringWithAggregatesFilter | string
    data?: JsonWithAggregatesFilter
    date?: DateTimeWithAggregatesFilter | Date | string
    seen?: BoolWithAggregatesFilter | boolean
  }

  export type BlogWhereInput = {
    AND?: Enumerable<BlogWhereInput>
    OR?: Enumerable<BlogWhereInput>
    NOT?: Enumerable<BlogWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    archived?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    blogComment?: BlogCommentListRelationFilter
    blogMedia?: BlogMediaListRelationFilter
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    archived?: SortOrder
    user?: UserOrderByWithRelationInput
    blogComment?: BlogCommentOrderByRelationAggregateInput
    blogMedia?: BlogMediaOrderByRelationAggregateInput
  }

  export type BlogWhereUniqueInput = {
    id?: string
  }

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    archived?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlogScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlogScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    date?: DateTimeWithAggregatesFilter | Date | string
    archived?: BoolWithAggregatesFilter | boolean
  }

  export type BlogCommentWhereInput = {
    AND?: Enumerable<BlogCommentWhereInput>
    OR?: Enumerable<BlogCommentWhereInput>
    NOT?: Enumerable<BlogCommentWhereInput>
    id?: StringFilter | string
    blogId?: StringFilter | string
    userId?: StringFilter | string
    content?: StringFilter | string
    date?: DateTimeFilter | Date | string
    blog?: XOR<BlogRelationFilter, BlogWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BlogCommentOrderByWithRelationInput = {
    id?: SortOrder
    blogId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    blog?: BlogOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BlogCommentWhereUniqueInput = {
    id?: string
  }

  export type BlogCommentOrderByWithAggregationInput = {
    id?: SortOrder
    blogId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    _count?: BlogCommentCountOrderByAggregateInput
    _max?: BlogCommentMaxOrderByAggregateInput
    _min?: BlogCommentMinOrderByAggregateInput
  }

  export type BlogCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlogCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlogCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlogCommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    blogId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type BlogMediaWhereInput = {
    AND?: Enumerable<BlogMediaWhereInput>
    OR?: Enumerable<BlogMediaWhereInput>
    NOT?: Enumerable<BlogMediaWhereInput>
    blogId?: StringFilter | string
    media?: StringFilter | string
    blog?: XOR<BlogRelationFilter, BlogWhereInput>
  }

  export type BlogMediaOrderByWithRelationInput = {
    blogId?: SortOrder
    media?: SortOrder
    blog?: BlogOrderByWithRelationInput
  }

  export type BlogMediaWhereUniqueInput = {
    blogId_media?: BlogMediaBlogIdMediaCompoundUniqueInput
  }

  export type BlogMediaOrderByWithAggregationInput = {
    blogId?: SortOrder
    media?: SortOrder
    _count?: BlogMediaCountOrderByAggregateInput
    _max?: BlogMediaMaxOrderByAggregateInput
    _min?: BlogMediaMinOrderByAggregateInput
  }

  export type BlogMediaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BlogMediaScalarWhereWithAggregatesInput>
    OR?: Enumerable<BlogMediaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BlogMediaScalarWhereWithAggregatesInput>
    blogId?: StringWithAggregatesFilter | string
    media?: StringWithAggregatesFilter | string
  }

  export type UserTokenWhereInput = {
    AND?: Enumerable<UserTokenWhereInput>
    OR?: Enumerable<UserTokenWhereInput>
    NOT?: Enumerable<UserTokenWhereInput>
    userId?: StringFilter | string
    userToken?: StringFilter | string
    userTokenType?: IntFilter | number
    userTokenExpiration?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserTokenOrderByWithRelationInput = {
    userId?: SortOrder
    userToken?: SortOrder
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTokenWhereUniqueInput = {
    userId?: string
  }

  export type UserTokenOrderByWithAggregationInput = {
    userId?: SortOrder
    userToken?: SortOrder
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
    _count?: UserTokenCountOrderByAggregateInput
    _avg?: UserTokenAvgOrderByAggregateInput
    _max?: UserTokenMaxOrderByAggregateInput
    _min?: UserTokenMinOrderByAggregateInput
    _sum?: UserTokenSumOrderByAggregateInput
  }

  export type UserTokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserTokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserTokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserTokenScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    userToken?: StringWithAggregatesFilter | string
    userTokenType?: IntWithAggregatesFilter | number
    userTokenExpiration?: IntWithAggregatesFilter | number
  }

  export type TestWhereInput = {
    AND?: Enumerable<TestWhereInput>
    OR?: Enumerable<TestWhereInput>
    NOT?: Enumerable<TestWhereInput>
    id?: IntFilter | number
    test1?: StringFilter | string
    test2?: StringNullableFilter | string | null
  }

  export type TestOrderByWithRelationInput = {
    id?: SortOrder
    test1?: SortOrder
    test2?: SortOrder
  }

  export type TestWhereUniqueInput = {
    id?: number
    test1?: string
  }

  export type TestOrderByWithAggregationInput = {
    id?: SortOrder
    test1?: SortOrder
    test2?: SortOrder
    _count?: TestCountOrderByAggregateInput
    _avg?: TestAvgOrderByAggregateInput
    _max?: TestMaxOrderByAggregateInput
    _min?: TestMinOrderByAggregateInput
    _sum?: TestSumOrderByAggregateInput
  }

  export type TestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TestScalarWhereWithAggregatesInput>
    OR?: Enumerable<TestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    test1?: StringWithAggregatesFilter | string
    test2?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserContactNumberWhereInput = {
    AND?: Enumerable<UserContactNumberWhereInput>
    OR?: Enumerable<UserContactNumberWhereInput>
    NOT?: Enumerable<UserContactNumberWhereInput>
    userId?: StringFilter | string
    number?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserContactNumberOrderByWithRelationInput = {
    userId?: SortOrder
    number?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserContactNumberWhereUniqueInput = {
    userId?: string
  }

  export type UserContactNumberOrderByWithAggregationInput = {
    userId?: SortOrder
    number?: SortOrder
    _count?: UserContactNumberCountOrderByAggregateInput
    _max?: UserContactNumberMaxOrderByAggregateInput
    _min?: UserContactNumberMinOrderByAggregateInput
  }

  export type UserContactNumberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserContactNumberScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserContactNumberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserContactNumberScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
  }

  export type UserExperienceWhereInput = {
    AND?: Enumerable<UserExperienceWhereInput>
    OR?: Enumerable<UserExperienceWhereInput>
    NOT?: Enumerable<UserExperienceWhereInput>
    userId?: StringFilter | string
    experience?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserExperienceOrderByWithRelationInput = {
    userId?: SortOrder
    experience?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserExperienceWhereUniqueInput = {
    userId?: string
  }

  export type UserExperienceOrderByWithAggregationInput = {
    userId?: SortOrder
    experience?: SortOrder
    _count?: UserExperienceCountOrderByAggregateInput
    _max?: UserExperienceMaxOrderByAggregateInput
    _min?: UserExperienceMinOrderByAggregateInput
  }

  export type UserExperienceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserExperienceScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserExperienceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserExperienceScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    experience?: StringWithAggregatesFilter | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserScoutedCreateInput = {
    date?: Date | string | null
    userScout: UserCreateNestedOneWithoutUserScoutInput
    user: UserCreateNestedOneWithoutUserScoutedInput
  }

  export type UserScoutedUncheckedCreateInput = {
    userIdScout: string
    userId: string
    date?: Date | string | null
  }

  export type UserScoutedUpdateInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userScout?: UserUpdateOneRequiredWithoutUserScoutInput
    user?: UserUpdateOneRequiredWithoutUserScoutedInput
  }

  export type UserScoutedUncheckedUpdateInput = {
    userIdScout?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserScoutedCreateManyInput = {
    userIdScout: string
    userId: string
    date?: Date | string | null
  }

  export type UserScoutedUpdateManyMutationInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserScoutedUncheckedUpdateManyInput = {
    userIdScout?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleCreateInput = {
    role: Role
    user: UserCreateNestedOneWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    role: Role
  }

  export type UserRoleUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    user?: UserUpdateOneRequiredWithoutUserRoleInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserRoleCreateManyInput = {
    userId: string
    role: Role
  }

  export type UserRoleUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserPermissionsCreateInput = {
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
    user: UserCreateNestedOneWithoutUserPermissionsInput
  }

  export type UserPermissionsUncheckedCreateInput = {
    userId: string
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type UserPermissionsUpdateInput = {
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
    user?: UserUpdateOneRequiredWithoutUserPermissionsInput
  }

  export type UserPermissionsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type UserPermissionsCreateManyInput = {
    userId: string
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type UserPermissionsUpdateManyMutationInput = {
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type UserPermissionsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type RolePermissionsCreateInput = {
    role: Role
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type RolePermissionsUncheckedCreateInput = {
    role: Role
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type RolePermissionsUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type RolePermissionsUncheckedUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type RolePermissionsCreateManyInput = {
    role: Role
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type RolePermissionsUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type RolePermissionsUncheckedUpdateManyInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type UserProfileCreateInput = {
    profilePicture?: string | null
    bio?: string | null
    employmentStatus?: boolean
    openToOffers?: boolean
    user: UserCreateNestedOneWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    userId: string
    profilePicture?: string | null
    bio?: string | null
    employmentStatus?: boolean
    openToOffers?: boolean
  }

  export type UserProfileUpdateInput = {
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUserProfileInput
  }

  export type UserProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProfileCreateManyInput = {
    userId: string
    profilePicture?: string | null
    bio?: string | null
    employmentStatus?: boolean
    openToOffers?: boolean
  }

  export type UserProfileUpdateManyMutationInput = {
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTagCreateInput = {
    tag: string
    user: UserCreateNestedOneWithoutUserTagInput
  }

  export type UserTagUncheckedCreateInput = {
    userId: string
    tag: string
  }

  export type UserTagUpdateInput = {
    tag?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserTagInput
  }

  export type UserTagUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagCreateManyInput = {
    userId: string
    tag: string
  }

  export type UserTagUpdateManyMutationInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialMediaCreateInput = {
    type: SocialMedia
    link: string
    user: UserCreateNestedOneWithoutUserSocialMediaInput
  }

  export type UserSocialMediaUncheckedCreateInput = {
    userId: string
    type: SocialMedia
    link: string
  }

  export type UserSocialMediaUpdateInput = {
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserSocialMediaInput
  }

  export type UserSocialMediaUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialMediaCreateManyInput = {
    userId: string
    type: SocialMedia
    link: string
  }

  export type UserSocialMediaUpdateManyMutationInput = {
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialMediaUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
  }

  export type UserLocationCreateInput = {
    location: string
    user: UserCreateNestedOneWithoutUserLocationInput
  }

  export type UserLocationUncheckedCreateInput = {
    userId: string
    location: string
  }

  export type UserLocationUpdateInput = {
    location?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserLocationInput
  }

  export type UserLocationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type UserLocationCreateManyInput = {
    userId: string
    location: string
  }

  export type UserLocationUpdateManyMutationInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type UserLocationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmailCreateInput = {
    email: string
    user: UserCreateNestedOneWithoutUserEmailInput
  }

  export type UserEmailUncheckedCreateInput = {
    userId: string
    email: string
  }

  export type UserEmailUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserEmailInput
  }

  export type UserEmailUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmailCreateManyInput = {
    userId: string
    email: string
  }

  export type UserEmailUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmailUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileFileCreateInput = {
    fileId?: string
    filePath: string
    fileCategory?: FileCategory | null
    fileExtension?: string | null
    user: UserCreateNestedOneWithoutUserProfileFileInput
  }

  export type UserProfileFileUncheckedCreateInput = {
    fileId?: string
    userId: string
    filePath: string
    fileCategory?: FileCategory | null
    fileExtension?: string | null
  }

  export type UserProfileFileUpdateInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserProfileFileInput
  }

  export type UserProfileFileUncheckedUpdateInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileFileCreateManyInput = {
    fileId?: string
    userId: string
    filePath: string
    fileCategory?: FileCategory | null
    fileExtension?: string | null
  }

  export type UserProfileFileUpdateManyMutationInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileFileUncheckedUpdateManyInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDegreeCreateInput = {
    degreeType: string
    degreeName: string
    user: UserCreateNestedOneWithoutUserDegreeInput
  }

  export type UserDegreeUncheckedCreateInput = {
    userID: string
    degreeType: string
    degreeName: string
  }

  export type UserDegreeUpdateInput = {
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserDegreeInput
  }

  export type UserDegreeUncheckedUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
  }

  export type UserDegreeCreateManyInput = {
    userID: string
    degreeType: string
    degreeName: string
  }

  export type UserDegreeUpdateManyMutationInput = {
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
  }

  export type UserDegreeUncheckedUpdateManyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
  }

  export type ShortCreateInput = {
    id?: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    user: UserCreateNestedOneWithoutShortInput
    shortTag?: ShortTagCreateNestedManyWithoutShortInput
    shortReport?: ShortReportCreateNestedManyWithoutShortInput
  }

  export type ShortUncheckedCreateInput = {
    id?: string
    userId: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    shortTag?: ShortTagUncheckedCreateNestedManyWithoutShortInput
    shortReport?: ShortReportUncheckedCreateNestedManyWithoutShortInput
  }

  export type ShortUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShortInput
    shortTag?: ShortTagUpdateManyWithoutShortInput
    shortReport?: ShortReportUpdateManyWithoutShortInput
  }

  export type ShortUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    shortTag?: ShortTagUncheckedUpdateManyWithoutShortInput
    shortReport?: ShortReportUncheckedUpdateManyWithoutShortInput
  }

  export type ShortCreateManyInput = {
    id?: string
    userId: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
  }

  export type ShortUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShortUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShortTagCreateInput = {
    tag: string
    short: ShortCreateNestedOneWithoutShortTagInput
  }

  export type ShortTagUncheckedCreateInput = {
    shortId: string
    tag: string
  }

  export type ShortTagUpdateInput = {
    tag?: StringFieldUpdateOperationsInput | string
    short?: ShortUpdateOneRequiredWithoutShortTagInput
  }

  export type ShortTagUncheckedUpdateInput = {
    shortId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ShortTagCreateManyInput = {
    shortId: string
    tag: string
  }

  export type ShortTagUpdateManyMutationInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ShortTagUncheckedUpdateManyInput = {
    shortId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ShortReportCreateInput = {
    reason: string
    user: UserCreateNestedOneWithoutShortReportInput
    short: ShortCreateNestedOneWithoutShortReportInput
  }

  export type ShortReportUncheckedCreateInput = {
    shortId: string
    userId: string
    reason: string
  }

  export type ShortReportUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutShortReportInput
    short?: ShortUpdateOneRequiredWithoutShortReportInput
  }

  export type ShortReportUncheckedUpdateInput = {
    shortId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type ShortReportCreateManyInput = {
    shortId: string
    userId: string
    reason: string
  }

  export type ShortReportUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type ShortReportUncheckedUpdateManyInput = {
    shortId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
    notificationFrom?: UserCreateNestedOneWithoutNotificationFromInput
    notificationTo: UserCreateNestedOneWithoutNotificationToInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userIdFrom?: string | null
    userIdTo: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    notificationFrom?: UserUpdateOneWithoutNotificationFromInput
    notificationTo?: UserUpdateOneRequiredWithoutNotificationToInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    userIdTo?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateManyInput = {
    id?: string
    userIdFrom?: string | null
    userIdTo: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    userIdTo?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogCreateInput = {
    id?: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    user: UserCreateNestedOneWithoutBlogInput
    blogComment?: BlogCommentCreateNestedManyWithoutBlogInput
    blogMedia?: BlogMediaCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    blogComment?: BlogCommentUncheckedCreateNestedManyWithoutBlogInput
    blogMedia?: BlogMediaUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBlogInput
    blogComment?: BlogCommentUpdateManyWithoutBlogInput
    blogMedia?: BlogMediaUpdateManyWithoutBlogInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    blogComment?: BlogCommentUncheckedUpdateManyWithoutBlogInput
    blogMedia?: BlogMediaUncheckedUpdateManyWithoutBlogInput
  }

  export type BlogCreateManyInput = {
    id?: string
    userId: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
  }

  export type BlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogCommentCreateInput = {
    id?: string
    content: string
    date: Date | string
    blog: BlogCreateNestedOneWithoutBlogCommentInput
    user: UserCreateNestedOneWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedCreateInput = {
    id?: string
    blogId: string
    userId: string
    content: string
    date: Date | string
  }

  export type BlogCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutBlogCommentInput
    user?: UserUpdateOneRequiredWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentCreateManyInput = {
    id?: string
    blogId: string
    userId: string
    content: string
    date: Date | string
  }

  export type BlogCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogMediaCreateInput = {
    media: string
    blog: BlogCreateNestedOneWithoutBlogMediaInput
  }

  export type BlogMediaUncheckedCreateInput = {
    blogId: string
    media: string
  }

  export type BlogMediaUpdateInput = {
    media?: StringFieldUpdateOperationsInput | string
    blog?: BlogUpdateOneRequiredWithoutBlogMediaInput
  }

  export type BlogMediaUncheckedUpdateInput = {
    blogId?: StringFieldUpdateOperationsInput | string
    media?: StringFieldUpdateOperationsInput | string
  }

  export type BlogMediaCreateManyInput = {
    blogId: string
    media: string
  }

  export type BlogMediaUpdateManyMutationInput = {
    media?: StringFieldUpdateOperationsInput | string
  }

  export type BlogMediaUncheckedUpdateManyInput = {
    blogId?: StringFieldUpdateOperationsInput | string
    media?: StringFieldUpdateOperationsInput | string
  }

  export type UserTokenCreateInput = {
    userToken: string
    userTokenType: number
    userTokenExpiration: number
    user: UserCreateNestedOneWithoutUserTokenInput
  }

  export type UserTokenUncheckedCreateInput = {
    userId: string
    userToken: string
    userTokenType: number
    userTokenExpiration: number
  }

  export type UserTokenUpdateInput = {
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutUserTokenInput
  }

  export type UserTokenUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
  }

  export type UserTokenCreateManyInput = {
    userId: string
    userToken: string
    userTokenType: number
    userTokenExpiration: number
  }

  export type UserTokenUpdateManyMutationInput = {
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
  }

  export type UserTokenUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
  }

  export type TestCreateInput = {
    test1: string
    test2?: string | null
  }

  export type TestUncheckedCreateInput = {
    id?: number
    test1: string
    test2?: string | null
  }

  export type TestUpdateInput = {
    test1?: StringFieldUpdateOperationsInput | string
    test2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    test1?: StringFieldUpdateOperationsInput | string
    test2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestCreateManyInput = {
    id?: number
    test1: string
    test2?: string | null
  }

  export type TestUpdateManyMutationInput = {
    test1?: StringFieldUpdateOperationsInput | string
    test2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    test1?: StringFieldUpdateOperationsInput | string
    test2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserContactNumberCreateInput = {
    number: string
    user: UserCreateNestedOneWithoutUserContactNumberInput
  }

  export type UserContactNumberUncheckedCreateInput = {
    userId: string
    number: string
  }

  export type UserContactNumberUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserContactNumberInput
  }

  export type UserContactNumberUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
  }

  export type UserContactNumberCreateManyInput = {
    userId: string
    number: string
  }

  export type UserContactNumberUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
  }

  export type UserContactNumberUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
  }

  export type UserExperienceCreateInput = {
    experience: string
    user: UserCreateNestedOneWithoutUserExperienceInput
  }

  export type UserExperienceUncheckedCreateInput = {
    userId: string
    experience: string
  }

  export type UserExperienceUpdateInput = {
    experience?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserExperienceInput
  }

  export type UserExperienceUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
  }

  export type UserExperienceCreateManyInput = {
    userId: string
    experience: string
  }

  export type UserExperienceUpdateManyMutationInput = {
    experience?: StringFieldUpdateOperationsInput | string
  }

  export type UserExperienceUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserScoutedListRelationFilter = {
    every?: UserScoutedWhereInput
    some?: UserScoutedWhereInput
    none?: UserScoutedWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserPermissionsListRelationFilter = {
    every?: UserPermissionsWhereInput
    some?: UserPermissionsWhereInput
    none?: UserPermissionsWhereInput
  }

  export type UserProfileListRelationFilter = {
    every?: UserProfileWhereInput
    some?: UserProfileWhereInput
    none?: UserProfileWhereInput
  }

  export type UserTagListRelationFilter = {
    every?: UserTagWhereInput
    some?: UserTagWhereInput
    none?: UserTagWhereInput
  }

  export type UserContactNumberListRelationFilter = {
    every?: UserContactNumberWhereInput
    some?: UserContactNumberWhereInput
    none?: UserContactNumberWhereInput
  }

  export type UserDegreeListRelationFilter = {
    every?: UserDegreeWhereInput
    some?: UserDegreeWhereInput
    none?: UserDegreeWhereInput
  }

  export type UserExperienceListRelationFilter = {
    every?: UserExperienceWhereInput
    some?: UserExperienceWhereInput
    none?: UserExperienceWhereInput
  }

  export type UserSocialMediaListRelationFilter = {
    every?: UserSocialMediaWhereInput
    some?: UserSocialMediaWhereInput
    none?: UserSocialMediaWhereInput
  }

  export type UserLocationListRelationFilter = {
    every?: UserLocationWhereInput
    some?: UserLocationWhereInput
    none?: UserLocationWhereInput
  }

  export type UserEmailListRelationFilter = {
    every?: UserEmailWhereInput
    some?: UserEmailWhereInput
    none?: UserEmailWhereInput
  }

  export type UserProfileFileListRelationFilter = {
    every?: UserProfileFileWhereInput
    some?: UserProfileFileWhereInput
    none?: UserProfileFileWhereInput
  }

  export type ShortListRelationFilter = {
    every?: ShortWhereInput
    some?: ShortWhereInput
    none?: ShortWhereInput
  }

  export type ShortReportListRelationFilter = {
    every?: ShortReportWhereInput
    some?: ShortReportWhereInput
    none?: ShortReportWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type BlogListRelationFilter = {
    every?: BlogWhereInput
    some?: BlogWhereInput
    none?: BlogWhereInput
  }

  export type BlogCommentListRelationFilter = {
    every?: BlogCommentWhereInput
    some?: BlogCommentWhereInput
    none?: BlogCommentWhereInput
  }

  export type UserTokenListRelationFilter = {
    every?: UserTokenWhereInput
    some?: UserTokenWhereInput
    none?: UserTokenWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserScoutedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserContactNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDegreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSocialMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShortOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShortReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordSalt?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    companyId?: SortOrder
    created?: SortOrder
    suspended?: SortOrder
    validated?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordSalt?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    companyId?: SortOrder
    created?: SortOrder
    suspended?: SortOrder
    validated?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    passwordSalt?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    companyId?: SortOrder
    created?: SortOrder
    suspended?: SortOrder
    validated?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type UserScoutedCountOrderByAggregateInput = {
    userIdScout?: SortOrder
    userId?: SortOrder
    date?: SortOrder
  }

  export type UserScoutedMaxOrderByAggregateInput = {
    userIdScout?: SortOrder
    userId?: SortOrder
    date?: SortOrder
  }

  export type UserScoutedMinOrderByAggregateInput = {
    userIdScout?: SortOrder
    userId?: SortOrder
    date?: SortOrder
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type UserRoleUserIdRoleCompoundUniqueInput = {
    userId: string
    role: Role
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    role?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    role?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    role?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type EnumPermissionTypeFilter = {
    equals?: PermissionType
    in?: Enumerable<PermissionType>
    notIn?: Enumerable<PermissionType>
    not?: NestedEnumPermissionTypeFilter | PermissionType
  }

  export type EnumPermissionCategoryFilter = {
    equals?: PermissionCategory
    in?: Enumerable<PermissionCategory>
    notIn?: Enumerable<PermissionCategory>
    not?: NestedEnumPermissionCategoryFilter | PermissionCategory
  }

  export type EnumPermissionTenantFilter = {
    equals?: PermissionTenant
    in?: Enumerable<PermissionTenant>
    notIn?: Enumerable<PermissionTenant>
    not?: NestedEnumPermissionTenantFilter | PermissionTenant
  }

  export type UserPermissionsUserIdPermissionTypePermissionCategoryPermissionTenantCompoundUniqueInput = {
    userId: string
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type UserPermissionsCountOrderByAggregateInput = {
    userId?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type UserPermissionsMaxOrderByAggregateInput = {
    userId?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type UserPermissionsMinOrderByAggregateInput = {
    userId?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type EnumPermissionTypeWithAggregatesFilter = {
    equals?: PermissionType
    in?: Enumerable<PermissionType>
    notIn?: Enumerable<PermissionType>
    not?: NestedEnumPermissionTypeWithAggregatesFilter | PermissionType
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionTypeFilter
    _max?: NestedEnumPermissionTypeFilter
  }

  export type EnumPermissionCategoryWithAggregatesFilter = {
    equals?: PermissionCategory
    in?: Enumerable<PermissionCategory>
    notIn?: Enumerable<PermissionCategory>
    not?: NestedEnumPermissionCategoryWithAggregatesFilter | PermissionCategory
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionCategoryFilter
    _max?: NestedEnumPermissionCategoryFilter
  }

  export type EnumPermissionTenantWithAggregatesFilter = {
    equals?: PermissionTenant
    in?: Enumerable<PermissionTenant>
    notIn?: Enumerable<PermissionTenant>
    not?: NestedEnumPermissionTenantWithAggregatesFilter | PermissionTenant
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionTenantFilter
    _max?: NestedEnumPermissionTenantFilter
  }

  export type RolePermissionsRolePermissionTypePermissionCategoryPermissionTenantCompoundUniqueInput = {
    role: Role
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type RolePermissionsCountOrderByAggregateInput = {
    role?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type RolePermissionsMaxOrderByAggregateInput = {
    role?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type RolePermissionsMinOrderByAggregateInput = {
    role?: SortOrder
    permissionType?: SortOrder
    permissionCategory?: SortOrder
    permissionTenant?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    employmentStatus?: SortOrder
    openToOffers?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    employmentStatus?: SortOrder
    openToOffers?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    profilePicture?: SortOrder
    bio?: SortOrder
    employmentStatus?: SortOrder
    openToOffers?: SortOrder
  }

  export type UserTagUserIdTagCompoundUniqueInput = {
    userId: string
    tag: string
  }

  export type UserTagCountOrderByAggregateInput = {
    userId?: SortOrder
    tag?: SortOrder
  }

  export type UserTagMaxOrderByAggregateInput = {
    userId?: SortOrder
    tag?: SortOrder
  }

  export type UserTagMinOrderByAggregateInput = {
    userId?: SortOrder
    tag?: SortOrder
  }

  export type EnumSocialMediaFilter = {
    equals?: SocialMedia
    in?: Enumerable<SocialMedia>
    notIn?: Enumerable<SocialMedia>
    not?: NestedEnumSocialMediaFilter | SocialMedia
  }

  export type UserSocialMediaCountOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    link?: SortOrder
  }

  export type UserSocialMediaMaxOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    link?: SortOrder
  }

  export type UserSocialMediaMinOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    link?: SortOrder
  }

  export type EnumSocialMediaWithAggregatesFilter = {
    equals?: SocialMedia
    in?: Enumerable<SocialMedia>
    notIn?: Enumerable<SocialMedia>
    not?: NestedEnumSocialMediaWithAggregatesFilter | SocialMedia
    _count?: NestedIntFilter
    _min?: NestedEnumSocialMediaFilter
    _max?: NestedEnumSocialMediaFilter
  }

  export type UserLocationCountOrderByAggregateInput = {
    userId?: SortOrder
    location?: SortOrder
  }

  export type UserLocationMaxOrderByAggregateInput = {
    userId?: SortOrder
    location?: SortOrder
  }

  export type UserLocationMinOrderByAggregateInput = {
    userId?: SortOrder
    location?: SortOrder
  }

  export type UserEmailCountOrderByAggregateInput = {
    userId?: SortOrder
    email?: SortOrder
  }

  export type UserEmailMaxOrderByAggregateInput = {
    userId?: SortOrder
    email?: SortOrder
  }

  export type UserEmailMinOrderByAggregateInput = {
    userId?: SortOrder
    email?: SortOrder
  }

  export type EnumFileCategoryNullableFilter = {
    equals?: FileCategory | null
    in?: Enumerable<FileCategory> | null
    notIn?: Enumerable<FileCategory> | null
    not?: NestedEnumFileCategoryNullableFilter | FileCategory | null
  }

  export type UserProfileFileCountOrderByAggregateInput = {
    fileId?: SortOrder
    userId?: SortOrder
    filePath?: SortOrder
    fileCategory?: SortOrder
    fileExtension?: SortOrder
  }

  export type UserProfileFileMaxOrderByAggregateInput = {
    fileId?: SortOrder
    userId?: SortOrder
    filePath?: SortOrder
    fileCategory?: SortOrder
    fileExtension?: SortOrder
  }

  export type UserProfileFileMinOrderByAggregateInput = {
    fileId?: SortOrder
    userId?: SortOrder
    filePath?: SortOrder
    fileCategory?: SortOrder
    fileExtension?: SortOrder
  }

  export type EnumFileCategoryNullableWithAggregatesFilter = {
    equals?: FileCategory | null
    in?: Enumerable<FileCategory> | null
    notIn?: Enumerable<FileCategory> | null
    not?: NestedEnumFileCategoryNullableWithAggregatesFilter | FileCategory | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumFileCategoryNullableFilter
    _max?: NestedEnumFileCategoryNullableFilter
  }

  export type UserDegreeCountOrderByAggregateInput = {
    userID?: SortOrder
    degreeType?: SortOrder
    degreeName?: SortOrder
  }

  export type UserDegreeMaxOrderByAggregateInput = {
    userID?: SortOrder
    degreeType?: SortOrder
    degreeName?: SortOrder
  }

  export type UserDegreeMinOrderByAggregateInput = {
    userID?: SortOrder
    degreeType?: SortOrder
    degreeName?: SortOrder
  }

  export type ShortTagListRelationFilter = {
    every?: ShortTagWhereInput
    some?: ShortTagWhereInput
    none?: ShortTagWhereInput
  }

  export type ShortTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShortCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    link?: SortOrder
    thumbnail?: SortOrder
    datePosted?: SortOrder
    archived?: SortOrder
  }

  export type ShortMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    link?: SortOrder
    thumbnail?: SortOrder
    datePosted?: SortOrder
    archived?: SortOrder
  }

  export type ShortMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    link?: SortOrder
    thumbnail?: SortOrder
    datePosted?: SortOrder
    archived?: SortOrder
  }

  export type ShortRelationFilter = {
    is?: ShortWhereInput
    isNot?: ShortWhereInput
  }

  export type ShortTagShortIdTagCompoundUniqueInput = {
    shortId: string
    tag: string
  }

  export type ShortTagCountOrderByAggregateInput = {
    shortId?: SortOrder
    tag?: SortOrder
  }

  export type ShortTagMaxOrderByAggregateInput = {
    shortId?: SortOrder
    tag?: SortOrder
  }

  export type ShortTagMinOrderByAggregateInput = {
    shortId?: SortOrder
    tag?: SortOrder
  }

  export type ShortReportShortIdUserIdCompoundUniqueInput = {
    shortId: string
    userId: string
  }

  export type ShortReportCountOrderByAggregateInput = {
    shortId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
  }

  export type ShortReportMaxOrderByAggregateInput = {
    shortId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
  }

  export type ShortReportMinOrderByAggregateInput = {
    shortId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userIdFrom?: SortOrder
    userIdTo?: SortOrder
    data?: SortOrder
    date?: SortOrder
    seen?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userIdFrom?: SortOrder
    userIdTo?: SortOrder
    date?: SortOrder
    seen?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userIdFrom?: SortOrder
    userIdTo?: SortOrder
    date?: SortOrder
    seen?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type BlogMediaListRelationFilter = {
    every?: BlogMediaWhereInput
    some?: BlogMediaWhereInput
    none?: BlogMediaWhereInput
  }

  export type BlogMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    archived?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    archived?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    archived?: SortOrder
  }

  export type BlogRelationFilter = {
    is?: BlogWhereInput
    isNot?: BlogWhereInput
  }

  export type BlogCommentCountOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
  }

  export type BlogCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
  }

  export type BlogCommentMinOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    date?: SortOrder
  }

  export type BlogMediaBlogIdMediaCompoundUniqueInput = {
    blogId: string
    media: string
  }

  export type BlogMediaCountOrderByAggregateInput = {
    blogId?: SortOrder
    media?: SortOrder
  }

  export type BlogMediaMaxOrderByAggregateInput = {
    blogId?: SortOrder
    media?: SortOrder
  }

  export type BlogMediaMinOrderByAggregateInput = {
    blogId?: SortOrder
    media?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserTokenCountOrderByAggregateInput = {
    userId?: SortOrder
    userToken?: SortOrder
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
  }

  export type UserTokenAvgOrderByAggregateInput = {
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
  }

  export type UserTokenMaxOrderByAggregateInput = {
    userId?: SortOrder
    userToken?: SortOrder
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
  }

  export type UserTokenMinOrderByAggregateInput = {
    userId?: SortOrder
    userToken?: SortOrder
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
  }

  export type UserTokenSumOrderByAggregateInput = {
    userTokenType?: SortOrder
    userTokenExpiration?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type TestCountOrderByAggregateInput = {
    id?: SortOrder
    test1?: SortOrder
    test2?: SortOrder
  }

  export type TestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TestMaxOrderByAggregateInput = {
    id?: SortOrder
    test1?: SortOrder
    test2?: SortOrder
  }

  export type TestMinOrderByAggregateInput = {
    id?: SortOrder
    test1?: SortOrder
    test2?: SortOrder
  }

  export type TestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserContactNumberCountOrderByAggregateInput = {
    userId?: SortOrder
    number?: SortOrder
  }

  export type UserContactNumberMaxOrderByAggregateInput = {
    userId?: SortOrder
    number?: SortOrder
  }

  export type UserContactNumberMinOrderByAggregateInput = {
    userId?: SortOrder
    number?: SortOrder
  }

  export type UserExperienceCountOrderByAggregateInput = {
    userId?: SortOrder
    experience?: SortOrder
  }

  export type UserExperienceMaxOrderByAggregateInput = {
    userId?: SortOrder
    experience?: SortOrder
  }

  export type UserExperienceMinOrderByAggregateInput = {
    userId?: SortOrder
    experience?: SortOrder
  }

  export type UserCreateNestedOneWithoutUserInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserScoutedCreateNestedManyWithoutUserScoutInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserScoutInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserScoutInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserScoutInput>
    createMany?: UserScoutedCreateManyUserScoutInputEnvelope
    connect?: Enumerable<UserScoutedWhereUniqueInput>
  }

  export type UserScoutedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserInput>
    createMany?: UserScoutedCreateManyUserInputEnvelope
    connect?: Enumerable<UserScoutedWhereUniqueInput>
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: Enumerable<UserRoleWhereUniqueInput>
  }

  export type UserPermissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPermissionsCreateWithoutUserInput>, Enumerable<UserPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPermissionsCreateOrConnectWithoutUserInput>
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    connect?: Enumerable<UserPermissionsWhereUniqueInput>
  }

  export type UserProfileCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileCreateWithoutUserInput>, Enumerable<UserProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileCreateOrConnectWithoutUserInput>
    createMany?: UserProfileCreateManyUserInputEnvelope
    connect?: Enumerable<UserProfileWhereUniqueInput>
  }

  export type UserTagCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTagCreateWithoutUserInput>, Enumerable<UserTagUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagCreateOrConnectWithoutUserInput>
    createMany?: UserTagCreateManyUserInputEnvelope
    connect?: Enumerable<UserTagWhereUniqueInput>
  }

  export type UserContactNumberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactNumberCreateWithoutUserInput>, Enumerable<UserContactNumberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactNumberCreateOrConnectWithoutUserInput>
    createMany?: UserContactNumberCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactNumberWhereUniqueInput>
  }

  export type UserDegreeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDegreeCreateWithoutUserInput>, Enumerable<UserDegreeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDegreeCreateOrConnectWithoutUserInput>
    createMany?: UserDegreeCreateManyUserInputEnvelope
    connect?: Enumerable<UserDegreeWhereUniqueInput>
  }

  export type UserExperienceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserExperienceCreateWithoutUserInput>, Enumerable<UserExperienceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserExperienceCreateOrConnectWithoutUserInput>
    createMany?: UserExperienceCreateManyUserInputEnvelope
    connect?: Enumerable<UserExperienceWhereUniqueInput>
  }

  export type UserSocialMediaCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserSocialMediaCreateWithoutUserInput>, Enumerable<UserSocialMediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSocialMediaCreateOrConnectWithoutUserInput>
    createMany?: UserSocialMediaCreateManyUserInputEnvelope
    connect?: Enumerable<UserSocialMediaWhereUniqueInput>
  }

  export type UserLocationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLocationCreateWithoutUserInput>, Enumerable<UserLocationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLocationCreateOrConnectWithoutUserInput>
    createMany?: UserLocationCreateManyUserInputEnvelope
    connect?: Enumerable<UserLocationWhereUniqueInput>
  }

  export type UserEmailCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserEmailCreateWithoutUserInput>, Enumerable<UserEmailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEmailCreateOrConnectWithoutUserInput>
    createMany?: UserEmailCreateManyUserInputEnvelope
    connect?: Enumerable<UserEmailWhereUniqueInput>
  }

  export type UserProfileFileCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileFileCreateWithoutUserInput>, Enumerable<UserProfileFileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileFileCreateOrConnectWithoutUserInput>
    createMany?: UserProfileFileCreateManyUserInputEnvelope
    connect?: Enumerable<UserProfileFileWhereUniqueInput>
  }

  export type ShortCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortCreateWithoutUserInput>, Enumerable<ShortUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortCreateOrConnectWithoutUserInput>
    createMany?: ShortCreateManyUserInputEnvelope
    connect?: Enumerable<ShortWhereUniqueInput>
  }

  export type ShortReportCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutUserInput>, Enumerable<ShortReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutUserInput>
    createMany?: ShortReportCreateManyUserInputEnvelope
    connect?: Enumerable<ShortReportWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutNotificationFromInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationFromInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationFromInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationFromInput>
    createMany?: NotificationCreateManyNotificationFromInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutNotificationToInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationToInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationToInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationToInput>
    createMany?: NotificationCreateManyNotificationToInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type BlogCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCreateWithoutUserInput>, Enumerable<BlogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCreateOrConnectWithoutUserInput>
    createMany?: BlogCreateManyUserInputEnvelope
    connect?: Enumerable<BlogWhereUniqueInput>
  }

  export type BlogCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutUserInput>, Enumerable<BlogCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutUserInput>
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: Enumerable<BlogCommentWhereUniqueInput>
  }

  export type UserTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTokenCreateWithoutUserInput>, Enumerable<UserTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokenCreateOrConnectWithoutUserInput>
    createMany?: UserTokenCreateManyUserInputEnvelope
    connect?: Enumerable<UserTokenWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserScoutInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserScoutInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserScoutInput>
    createMany?: UserScoutedCreateManyUserScoutInputEnvelope
    connect?: Enumerable<UserScoutedWhereUniqueInput>
  }

  export type UserScoutedUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserInput>
    createMany?: UserScoutedCreateManyUserInputEnvelope
    connect?: Enumerable<UserScoutedWhereUniqueInput>
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: Enumerable<UserRoleWhereUniqueInput>
  }

  export type UserPermissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPermissionsCreateWithoutUserInput>, Enumerable<UserPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPermissionsCreateOrConnectWithoutUserInput>
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    connect?: Enumerable<UserPermissionsWhereUniqueInput>
  }

  export type UserProfileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileCreateWithoutUserInput>, Enumerable<UserProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileCreateOrConnectWithoutUserInput>
    createMany?: UserProfileCreateManyUserInputEnvelope
    connect?: Enumerable<UserProfileWhereUniqueInput>
  }

  export type UserTagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTagCreateWithoutUserInput>, Enumerable<UserTagUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagCreateOrConnectWithoutUserInput>
    createMany?: UserTagCreateManyUserInputEnvelope
    connect?: Enumerable<UserTagWhereUniqueInput>
  }

  export type UserContactNumberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactNumberCreateWithoutUserInput>, Enumerable<UserContactNumberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactNumberCreateOrConnectWithoutUserInput>
    createMany?: UserContactNumberCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactNumberWhereUniqueInput>
  }

  export type UserDegreeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDegreeCreateWithoutUserInput>, Enumerable<UserDegreeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDegreeCreateOrConnectWithoutUserInput>
    createMany?: UserDegreeCreateManyUserInputEnvelope
    connect?: Enumerable<UserDegreeWhereUniqueInput>
  }

  export type UserExperienceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserExperienceCreateWithoutUserInput>, Enumerable<UserExperienceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserExperienceCreateOrConnectWithoutUserInput>
    createMany?: UserExperienceCreateManyUserInputEnvelope
    connect?: Enumerable<UserExperienceWhereUniqueInput>
  }

  export type UserSocialMediaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserSocialMediaCreateWithoutUserInput>, Enumerable<UserSocialMediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSocialMediaCreateOrConnectWithoutUserInput>
    createMany?: UserSocialMediaCreateManyUserInputEnvelope
    connect?: Enumerable<UserSocialMediaWhereUniqueInput>
  }

  export type UserLocationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLocationCreateWithoutUserInput>, Enumerable<UserLocationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLocationCreateOrConnectWithoutUserInput>
    createMany?: UserLocationCreateManyUserInputEnvelope
    connect?: Enumerable<UserLocationWhereUniqueInput>
  }

  export type UserEmailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserEmailCreateWithoutUserInput>, Enumerable<UserEmailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEmailCreateOrConnectWithoutUserInput>
    createMany?: UserEmailCreateManyUserInputEnvelope
    connect?: Enumerable<UserEmailWhereUniqueInput>
  }

  export type UserProfileFileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileFileCreateWithoutUserInput>, Enumerable<UserProfileFileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileFileCreateOrConnectWithoutUserInput>
    createMany?: UserProfileFileCreateManyUserInputEnvelope
    connect?: Enumerable<UserProfileFileWhereUniqueInput>
  }

  export type ShortUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortCreateWithoutUserInput>, Enumerable<ShortUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortCreateOrConnectWithoutUserInput>
    createMany?: ShortCreateManyUserInputEnvelope
    connect?: Enumerable<ShortWhereUniqueInput>
  }

  export type ShortReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutUserInput>, Enumerable<ShortReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutUserInput>
    createMany?: ShortReportCreateManyUserInputEnvelope
    connect?: Enumerable<ShortReportWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutNotificationFromInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationFromInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationFromInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationFromInput>
    createMany?: NotificationCreateManyNotificationFromInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutNotificationToInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationToInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationToInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationToInput>
    createMany?: NotificationCreateManyNotificationToInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type BlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCreateWithoutUserInput>, Enumerable<BlogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCreateOrConnectWithoutUserInput>
    createMany?: BlogCreateManyUserInputEnvelope
    connect?: Enumerable<BlogWhereUniqueInput>
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutUserInput>, Enumerable<BlogCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutUserInput>
    createMany?: BlogCommentCreateManyUserInputEnvelope
    connect?: Enumerable<BlogCommentWhereUniqueInput>
  }

  export type UserTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTokenCreateWithoutUserInput>, Enumerable<UserTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokenCreateOrConnectWithoutUserInput>
    createMany?: UserTokenCreateManyUserInputEnvelope
    connect?: Enumerable<UserTokenWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutUserInput = {
    create?: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserInput
    upsert?: UserUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserInput, UserUncheckedUpdateWithoutUserInput>
  }

  export type UserUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserScoutedUpdateManyWithoutUserScoutInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserScoutInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserScoutInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserScoutInput>
    upsert?: Enumerable<UserScoutedUpsertWithWhereUniqueWithoutUserScoutInput>
    createMany?: UserScoutedCreateManyUserScoutInputEnvelope
    set?: Enumerable<UserScoutedWhereUniqueInput>
    disconnect?: Enumerable<UserScoutedWhereUniqueInput>
    delete?: Enumerable<UserScoutedWhereUniqueInput>
    connect?: Enumerable<UserScoutedWhereUniqueInput>
    update?: Enumerable<UserScoutedUpdateWithWhereUniqueWithoutUserScoutInput>
    updateMany?: Enumerable<UserScoutedUpdateManyWithWhereWithoutUserScoutInput>
    deleteMany?: Enumerable<UserScoutedScalarWhereInput>
  }

  export type UserScoutedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserScoutedUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserScoutedCreateManyUserInputEnvelope
    set?: Enumerable<UserScoutedWhereUniqueInput>
    disconnect?: Enumerable<UserScoutedWhereUniqueInput>
    delete?: Enumerable<UserScoutedWhereUniqueInput>
    connect?: Enumerable<UserScoutedWhereUniqueInput>
    update?: Enumerable<UserScoutedUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserScoutedUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserScoutedScalarWhereInput>
  }

  export type UserRoleUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: Enumerable<UserRoleWhereUniqueInput>
    disconnect?: Enumerable<UserRoleWhereUniqueInput>
    delete?: Enumerable<UserRoleWhereUniqueInput>
    connect?: Enumerable<UserRoleWhereUniqueInput>
    update?: Enumerable<UserRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserRoleScalarWhereInput>
  }

  export type UserPermissionsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPermissionsCreateWithoutUserInput>, Enumerable<UserPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPermissionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPermissionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    set?: Enumerable<UserPermissionsWhereUniqueInput>
    disconnect?: Enumerable<UserPermissionsWhereUniqueInput>
    delete?: Enumerable<UserPermissionsWhereUniqueInput>
    connect?: Enumerable<UserPermissionsWhereUniqueInput>
    update?: Enumerable<UserPermissionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPermissionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPermissionsScalarWhereInput>
  }

  export type UserProfileUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileCreateWithoutUserInput>, Enumerable<UserProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserProfileUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserProfileCreateManyUserInputEnvelope
    set?: Enumerable<UserProfileWhereUniqueInput>
    disconnect?: Enumerable<UserProfileWhereUniqueInput>
    delete?: Enumerable<UserProfileWhereUniqueInput>
    connect?: Enumerable<UserProfileWhereUniqueInput>
    update?: Enumerable<UserProfileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserProfileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserProfileScalarWhereInput>
  }

  export type UserTagUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTagCreateWithoutUserInput>, Enumerable<UserTagUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTagUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTagCreateManyUserInputEnvelope
    set?: Enumerable<UserTagWhereUniqueInput>
    disconnect?: Enumerable<UserTagWhereUniqueInput>
    delete?: Enumerable<UserTagWhereUniqueInput>
    connect?: Enumerable<UserTagWhereUniqueInput>
    update?: Enumerable<UserTagUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTagUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTagScalarWhereInput>
  }

  export type UserContactNumberUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactNumberCreateWithoutUserInput>, Enumerable<UserContactNumberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactNumberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserContactNumberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserContactNumberCreateManyUserInputEnvelope
    set?: Enumerable<UserContactNumberWhereUniqueInput>
    disconnect?: Enumerable<UserContactNumberWhereUniqueInput>
    delete?: Enumerable<UserContactNumberWhereUniqueInput>
    connect?: Enumerable<UserContactNumberWhereUniqueInput>
    update?: Enumerable<UserContactNumberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserContactNumberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserContactNumberScalarWhereInput>
  }

  export type UserDegreeUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDegreeCreateWithoutUserInput>, Enumerable<UserDegreeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDegreeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDegreeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDegreeCreateManyUserInputEnvelope
    set?: Enumerable<UserDegreeWhereUniqueInput>
    disconnect?: Enumerable<UserDegreeWhereUniqueInput>
    delete?: Enumerable<UserDegreeWhereUniqueInput>
    connect?: Enumerable<UserDegreeWhereUniqueInput>
    update?: Enumerable<UserDegreeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDegreeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDegreeScalarWhereInput>
  }

  export type UserExperienceUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserExperienceCreateWithoutUserInput>, Enumerable<UserExperienceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserExperienceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserExperienceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserExperienceCreateManyUserInputEnvelope
    set?: Enumerable<UserExperienceWhereUniqueInput>
    disconnect?: Enumerable<UserExperienceWhereUniqueInput>
    delete?: Enumerable<UserExperienceWhereUniqueInput>
    connect?: Enumerable<UserExperienceWhereUniqueInput>
    update?: Enumerable<UserExperienceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserExperienceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserExperienceScalarWhereInput>
  }

  export type UserSocialMediaUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserSocialMediaCreateWithoutUserInput>, Enumerable<UserSocialMediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSocialMediaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserSocialMediaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserSocialMediaCreateManyUserInputEnvelope
    set?: Enumerable<UserSocialMediaWhereUniqueInput>
    disconnect?: Enumerable<UserSocialMediaWhereUniqueInput>
    delete?: Enumerable<UserSocialMediaWhereUniqueInput>
    connect?: Enumerable<UserSocialMediaWhereUniqueInput>
    update?: Enumerable<UserSocialMediaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserSocialMediaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserSocialMediaScalarWhereInput>
  }

  export type UserLocationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLocationCreateWithoutUserInput>, Enumerable<UserLocationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLocationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLocationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLocationCreateManyUserInputEnvelope
    set?: Enumerable<UserLocationWhereUniqueInput>
    disconnect?: Enumerable<UserLocationWhereUniqueInput>
    delete?: Enumerable<UserLocationWhereUniqueInput>
    connect?: Enumerable<UserLocationWhereUniqueInput>
    update?: Enumerable<UserLocationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLocationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLocationScalarWhereInput>
  }

  export type UserEmailUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserEmailCreateWithoutUserInput>, Enumerable<UserEmailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEmailCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserEmailUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserEmailCreateManyUserInputEnvelope
    set?: Enumerable<UserEmailWhereUniqueInput>
    disconnect?: Enumerable<UserEmailWhereUniqueInput>
    delete?: Enumerable<UserEmailWhereUniqueInput>
    connect?: Enumerable<UserEmailWhereUniqueInput>
    update?: Enumerable<UserEmailUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserEmailUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserEmailScalarWhereInput>
  }

  export type UserProfileFileUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileFileCreateWithoutUserInput>, Enumerable<UserProfileFileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileFileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserProfileFileUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserProfileFileCreateManyUserInputEnvelope
    set?: Enumerable<UserProfileFileWhereUniqueInput>
    disconnect?: Enumerable<UserProfileFileWhereUniqueInput>
    delete?: Enumerable<UserProfileFileWhereUniqueInput>
    connect?: Enumerable<UserProfileFileWhereUniqueInput>
    update?: Enumerable<UserProfileFileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserProfileFileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserProfileFileScalarWhereInput>
  }

  export type ShortUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortCreateWithoutUserInput>, Enumerable<ShortUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShortUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ShortCreateManyUserInputEnvelope
    set?: Enumerable<ShortWhereUniqueInput>
    disconnect?: Enumerable<ShortWhereUniqueInput>
    delete?: Enumerable<ShortWhereUniqueInput>
    connect?: Enumerable<ShortWhereUniqueInput>
    update?: Enumerable<ShortUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShortUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShortScalarWhereInput>
  }

  export type ShortReportUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutUserInput>, Enumerable<ShortReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShortReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ShortReportCreateManyUserInputEnvelope
    set?: Enumerable<ShortReportWhereUniqueInput>
    disconnect?: Enumerable<ShortReportWhereUniqueInput>
    delete?: Enumerable<ShortReportWhereUniqueInput>
    connect?: Enumerable<ShortReportWhereUniqueInput>
    update?: Enumerable<ShortReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShortReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShortReportScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutNotificationFromInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationFromInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationFromInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationFromInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutNotificationFromInput>
    createMany?: NotificationCreateManyNotificationFromInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutNotificationFromInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutNotificationFromInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutNotificationToInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationToInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationToInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationToInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutNotificationToInput>
    createMany?: NotificationCreateManyNotificationToInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutNotificationToInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutNotificationToInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type BlogUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCreateWithoutUserInput>, Enumerable<BlogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BlogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BlogCreateManyUserInputEnvelope
    set?: Enumerable<BlogWhereUniqueInput>
    disconnect?: Enumerable<BlogWhereUniqueInput>
    delete?: Enumerable<BlogWhereUniqueInput>
    connect?: Enumerable<BlogWhereUniqueInput>
    update?: Enumerable<BlogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BlogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BlogScalarWhereInput>
  }

  export type BlogCommentUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutUserInput>, Enumerable<BlogCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BlogCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: Enumerable<BlogCommentWhereUniqueInput>
    disconnect?: Enumerable<BlogCommentWhereUniqueInput>
    delete?: Enumerable<BlogCommentWhereUniqueInput>
    connect?: Enumerable<BlogCommentWhereUniqueInput>
    update?: Enumerable<BlogCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BlogCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BlogCommentScalarWhereInput>
  }

  export type UserTokenUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTokenCreateWithoutUserInput>, Enumerable<UserTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTokenCreateManyUserInputEnvelope
    set?: Enumerable<UserTokenWhereUniqueInput>
    disconnect?: Enumerable<UserTokenWhereUniqueInput>
    delete?: Enumerable<UserTokenWhereUniqueInput>
    connect?: Enumerable<UserTokenWhereUniqueInput>
    update?: Enumerable<UserTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTokenScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserScoutedUncheckedUpdateManyWithoutUserScoutInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserScoutInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserScoutInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserScoutInput>
    upsert?: Enumerable<UserScoutedUpsertWithWhereUniqueWithoutUserScoutInput>
    createMany?: UserScoutedCreateManyUserScoutInputEnvelope
    set?: Enumerable<UserScoutedWhereUniqueInput>
    disconnect?: Enumerable<UserScoutedWhereUniqueInput>
    delete?: Enumerable<UserScoutedWhereUniqueInput>
    connect?: Enumerable<UserScoutedWhereUniqueInput>
    update?: Enumerable<UserScoutedUpdateWithWhereUniqueWithoutUserScoutInput>
    updateMany?: Enumerable<UserScoutedUpdateManyWithWhereWithoutUserScoutInput>
    deleteMany?: Enumerable<UserScoutedScalarWhereInput>
  }

  export type UserScoutedUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserScoutedCreateWithoutUserInput>, Enumerable<UserScoutedUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserScoutedCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserScoutedUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserScoutedCreateManyUserInputEnvelope
    set?: Enumerable<UserScoutedWhereUniqueInput>
    disconnect?: Enumerable<UserScoutedWhereUniqueInput>
    delete?: Enumerable<UserScoutedWhereUniqueInput>
    connect?: Enumerable<UserScoutedWhereUniqueInput>
    update?: Enumerable<UserScoutedUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserScoutedUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserScoutedScalarWhereInput>
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserRoleCreateWithoutUserInput>, Enumerable<UserRoleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserRoleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserRoleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: Enumerable<UserRoleWhereUniqueInput>
    disconnect?: Enumerable<UserRoleWhereUniqueInput>
    delete?: Enumerable<UserRoleWhereUniqueInput>
    connect?: Enumerable<UserRoleWhereUniqueInput>
    update?: Enumerable<UserRoleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserRoleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserRoleScalarWhereInput>
  }

  export type UserPermissionsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPermissionsCreateWithoutUserInput>, Enumerable<UserPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPermissionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPermissionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPermissionsCreateManyUserInputEnvelope
    set?: Enumerable<UserPermissionsWhereUniqueInput>
    disconnect?: Enumerable<UserPermissionsWhereUniqueInput>
    delete?: Enumerable<UserPermissionsWhereUniqueInput>
    connect?: Enumerable<UserPermissionsWhereUniqueInput>
    update?: Enumerable<UserPermissionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPermissionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPermissionsScalarWhereInput>
  }

  export type UserProfileUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileCreateWithoutUserInput>, Enumerable<UserProfileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserProfileUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserProfileCreateManyUserInputEnvelope
    set?: Enumerable<UserProfileWhereUniqueInput>
    disconnect?: Enumerable<UserProfileWhereUniqueInput>
    delete?: Enumerable<UserProfileWhereUniqueInput>
    connect?: Enumerable<UserProfileWhereUniqueInput>
    update?: Enumerable<UserProfileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserProfileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserProfileScalarWhereInput>
  }

  export type UserTagUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTagCreateWithoutUserInput>, Enumerable<UserTagUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTagCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTagUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTagCreateManyUserInputEnvelope
    set?: Enumerable<UserTagWhereUniqueInput>
    disconnect?: Enumerable<UserTagWhereUniqueInput>
    delete?: Enumerable<UserTagWhereUniqueInput>
    connect?: Enumerable<UserTagWhereUniqueInput>
    update?: Enumerable<UserTagUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTagUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTagScalarWhereInput>
  }

  export type UserContactNumberUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactNumberCreateWithoutUserInput>, Enumerable<UserContactNumberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactNumberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserContactNumberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserContactNumberCreateManyUserInputEnvelope
    set?: Enumerable<UserContactNumberWhereUniqueInput>
    disconnect?: Enumerable<UserContactNumberWhereUniqueInput>
    delete?: Enumerable<UserContactNumberWhereUniqueInput>
    connect?: Enumerable<UserContactNumberWhereUniqueInput>
    update?: Enumerable<UserContactNumberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserContactNumberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserContactNumberScalarWhereInput>
  }

  export type UserDegreeUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDegreeCreateWithoutUserInput>, Enumerable<UserDegreeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDegreeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDegreeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDegreeCreateManyUserInputEnvelope
    set?: Enumerable<UserDegreeWhereUniqueInput>
    disconnect?: Enumerable<UserDegreeWhereUniqueInput>
    delete?: Enumerable<UserDegreeWhereUniqueInput>
    connect?: Enumerable<UserDegreeWhereUniqueInput>
    update?: Enumerable<UserDegreeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDegreeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDegreeScalarWhereInput>
  }

  export type UserExperienceUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserExperienceCreateWithoutUserInput>, Enumerable<UserExperienceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserExperienceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserExperienceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserExperienceCreateManyUserInputEnvelope
    set?: Enumerable<UserExperienceWhereUniqueInput>
    disconnect?: Enumerable<UserExperienceWhereUniqueInput>
    delete?: Enumerable<UserExperienceWhereUniqueInput>
    connect?: Enumerable<UserExperienceWhereUniqueInput>
    update?: Enumerable<UserExperienceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserExperienceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserExperienceScalarWhereInput>
  }

  export type UserSocialMediaUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserSocialMediaCreateWithoutUserInput>, Enumerable<UserSocialMediaUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSocialMediaCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserSocialMediaUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserSocialMediaCreateManyUserInputEnvelope
    set?: Enumerable<UserSocialMediaWhereUniqueInput>
    disconnect?: Enumerable<UserSocialMediaWhereUniqueInput>
    delete?: Enumerable<UserSocialMediaWhereUniqueInput>
    connect?: Enumerable<UserSocialMediaWhereUniqueInput>
    update?: Enumerable<UserSocialMediaUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserSocialMediaUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserSocialMediaScalarWhereInput>
  }

  export type UserLocationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLocationCreateWithoutUserInput>, Enumerable<UserLocationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLocationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLocationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLocationCreateManyUserInputEnvelope
    set?: Enumerable<UserLocationWhereUniqueInput>
    disconnect?: Enumerable<UserLocationWhereUniqueInput>
    delete?: Enumerable<UserLocationWhereUniqueInput>
    connect?: Enumerable<UserLocationWhereUniqueInput>
    update?: Enumerable<UserLocationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLocationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLocationScalarWhereInput>
  }

  export type UserEmailUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserEmailCreateWithoutUserInput>, Enumerable<UserEmailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEmailCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserEmailUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserEmailCreateManyUserInputEnvelope
    set?: Enumerable<UserEmailWhereUniqueInput>
    disconnect?: Enumerable<UserEmailWhereUniqueInput>
    delete?: Enumerable<UserEmailWhereUniqueInput>
    connect?: Enumerable<UserEmailWhereUniqueInput>
    update?: Enumerable<UserEmailUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserEmailUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserEmailScalarWhereInput>
  }

  export type UserProfileFileUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserProfileFileCreateWithoutUserInput>, Enumerable<UserProfileFileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserProfileFileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserProfileFileUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserProfileFileCreateManyUserInputEnvelope
    set?: Enumerable<UserProfileFileWhereUniqueInput>
    disconnect?: Enumerable<UserProfileFileWhereUniqueInput>
    delete?: Enumerable<UserProfileFileWhereUniqueInput>
    connect?: Enumerable<UserProfileFileWhereUniqueInput>
    update?: Enumerable<UserProfileFileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserProfileFileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserProfileFileScalarWhereInput>
  }

  export type ShortUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortCreateWithoutUserInput>, Enumerable<ShortUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShortUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ShortCreateManyUserInputEnvelope
    set?: Enumerable<ShortWhereUniqueInput>
    disconnect?: Enumerable<ShortWhereUniqueInput>
    delete?: Enumerable<ShortWhereUniqueInput>
    connect?: Enumerable<ShortWhereUniqueInput>
    update?: Enumerable<ShortUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShortUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShortScalarWhereInput>
  }

  export type ShortReportUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutUserInput>, Enumerable<ShortReportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShortReportUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ShortReportCreateManyUserInputEnvelope
    set?: Enumerable<ShortReportWhereUniqueInput>
    disconnect?: Enumerable<ShortReportWhereUniqueInput>
    delete?: Enumerable<ShortReportWhereUniqueInput>
    connect?: Enumerable<ShortReportWhereUniqueInput>
    update?: Enumerable<ShortReportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShortReportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShortReportScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationFromInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationFromInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationFromInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationFromInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutNotificationFromInput>
    createMany?: NotificationCreateManyNotificationFromInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutNotificationFromInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutNotificationFromInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationToInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutNotificationToInput>, Enumerable<NotificationUncheckedCreateWithoutNotificationToInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutNotificationToInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutNotificationToInput>
    createMany?: NotificationCreateManyNotificationToInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutNotificationToInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutNotificationToInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type BlogUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCreateWithoutUserInput>, Enumerable<BlogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BlogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BlogCreateManyUserInputEnvelope
    set?: Enumerable<BlogWhereUniqueInput>
    disconnect?: Enumerable<BlogWhereUniqueInput>
    delete?: Enumerable<BlogWhereUniqueInput>
    connect?: Enumerable<BlogWhereUniqueInput>
    update?: Enumerable<BlogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BlogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BlogScalarWhereInput>
  }

  export type BlogCommentUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutUserInput>, Enumerable<BlogCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BlogCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BlogCommentCreateManyUserInputEnvelope
    set?: Enumerable<BlogCommentWhereUniqueInput>
    disconnect?: Enumerable<BlogCommentWhereUniqueInput>
    delete?: Enumerable<BlogCommentWhereUniqueInput>
    connect?: Enumerable<BlogCommentWhereUniqueInput>
    update?: Enumerable<BlogCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BlogCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BlogCommentScalarWhereInput>
  }

  export type UserTokenUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserTokenCreateWithoutUserInput>, Enumerable<UserTokenUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserTokenCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserTokenUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserTokenCreateManyUserInputEnvelope
    set?: Enumerable<UserTokenWhereUniqueInput>
    disconnect?: Enumerable<UserTokenWhereUniqueInput>
    delete?: Enumerable<UserTokenWhereUniqueInput>
    connect?: Enumerable<UserTokenWhereUniqueInput>
    update?: Enumerable<UserTokenUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserTokenUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserTokenScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserScoutInput = {
    create?: XOR<UserCreateWithoutUserScoutInput, UserUncheckedCreateWithoutUserScoutInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserScoutInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserScoutedInput = {
    create?: XOR<UserCreateWithoutUserScoutedInput, UserUncheckedCreateWithoutUserScoutedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserScoutedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserScoutInput = {
    create?: XOR<UserCreateWithoutUserScoutInput, UserUncheckedCreateWithoutUserScoutInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserScoutInput
    upsert?: UserUpsertWithoutUserScoutInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserScoutInput, UserUncheckedUpdateWithoutUserScoutInput>
  }

  export type UserUpdateOneRequiredWithoutUserScoutedInput = {
    create?: XOR<UserCreateWithoutUserScoutedInput, UserUncheckedCreateWithoutUserScoutedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserScoutedInput
    upsert?: UserUpsertWithoutUserScoutedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserScoutedInput, UserUncheckedUpdateWithoutUserScoutedInput>
  }

  export type UserCreateNestedOneWithoutUserRoleInput = {
    create?: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type UserUpdateOneRequiredWithoutUserRoleInput = {
    create?: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleInput
    upsert?: UserUpsertWithoutUserRoleInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserRoleInput, UserUncheckedUpdateWithoutUserRoleInput>
  }

  export type UserCreateNestedOneWithoutUserPermissionsInput = {
    create?: XOR<UserCreateWithoutUserPermissionsInput, UserUncheckedCreateWithoutUserPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPermissionTypeFieldUpdateOperationsInput = {
    set?: PermissionType
  }

  export type EnumPermissionCategoryFieldUpdateOperationsInput = {
    set?: PermissionCategory
  }

  export type EnumPermissionTenantFieldUpdateOperationsInput = {
    set?: PermissionTenant
  }

  export type UserUpdateOneRequiredWithoutUserPermissionsInput = {
    create?: XOR<UserCreateWithoutUserPermissionsInput, UserUncheckedCreateWithoutUserPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPermissionsInput
    upsert?: UserUpsertWithoutUserPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserPermissionsInput, UserUncheckedUpdateWithoutUserPermissionsInput>
  }

  export type UserCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserProfileInput = {
    create?: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileInput
    upsert?: UserUpsertWithoutUserProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
  }

  export type UserCreateNestedOneWithoutUserTagInput = {
    create?: XOR<UserCreateWithoutUserTagInput, UserUncheckedCreateWithoutUserTagInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTagInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserTagInput = {
    create?: XOR<UserCreateWithoutUserTagInput, UserUncheckedCreateWithoutUserTagInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTagInput
    upsert?: UserUpsertWithoutUserTagInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserTagInput, UserUncheckedUpdateWithoutUserTagInput>
  }

  export type UserCreateNestedOneWithoutUserSocialMediaInput = {
    create?: XOR<UserCreateWithoutUserSocialMediaInput, UserUncheckedCreateWithoutUserSocialMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSocialMediaInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSocialMediaFieldUpdateOperationsInput = {
    set?: SocialMedia
  }

  export type UserUpdateOneRequiredWithoutUserSocialMediaInput = {
    create?: XOR<UserCreateWithoutUserSocialMediaInput, UserUncheckedCreateWithoutUserSocialMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSocialMediaInput
    upsert?: UserUpsertWithoutUserSocialMediaInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserSocialMediaInput, UserUncheckedUpdateWithoutUserSocialMediaInput>
  }

  export type UserCreateNestedOneWithoutUserLocationInput = {
    create?: XOR<UserCreateWithoutUserLocationInput, UserUncheckedCreateWithoutUserLocationInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLocationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserLocationInput = {
    create?: XOR<UserCreateWithoutUserLocationInput, UserUncheckedCreateWithoutUserLocationInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserLocationInput
    upsert?: UserUpsertWithoutUserLocationInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserLocationInput, UserUncheckedUpdateWithoutUserLocationInput>
  }

  export type UserCreateNestedOneWithoutUserEmailInput = {
    create?: XOR<UserCreateWithoutUserEmailInput, UserUncheckedCreateWithoutUserEmailInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEmailInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserEmailInput = {
    create?: XOR<UserCreateWithoutUserEmailInput, UserUncheckedCreateWithoutUserEmailInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEmailInput
    upsert?: UserUpsertWithoutUserEmailInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserEmailInput, UserUncheckedUpdateWithoutUserEmailInput>
  }

  export type UserCreateNestedOneWithoutUserProfileFileInput = {
    create?: XOR<UserCreateWithoutUserProfileFileInput, UserUncheckedCreateWithoutUserProfileFileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileFileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumFileCategoryFieldUpdateOperationsInput = {
    set?: FileCategory | null
  }

  export type UserUpdateOneRequiredWithoutUserProfileFileInput = {
    create?: XOR<UserCreateWithoutUserProfileFileInput, UserUncheckedCreateWithoutUserProfileFileInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProfileFileInput
    upsert?: UserUpsertWithoutUserProfileFileInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserProfileFileInput, UserUncheckedUpdateWithoutUserProfileFileInput>
  }

  export type UserCreateNestedOneWithoutUserDegreeInput = {
    create?: XOR<UserCreateWithoutUserDegreeInput, UserUncheckedCreateWithoutUserDegreeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDegreeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserDegreeInput = {
    create?: XOR<UserCreateWithoutUserDegreeInput, UserUncheckedCreateWithoutUserDegreeInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDegreeInput
    upsert?: UserUpsertWithoutUserDegreeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserDegreeInput, UserUncheckedUpdateWithoutUserDegreeInput>
  }

  export type UserCreateNestedOneWithoutShortInput = {
    create?: XOR<UserCreateWithoutShortInput, UserUncheckedCreateWithoutShortInput>
    connectOrCreate?: UserCreateOrConnectWithoutShortInput
    connect?: UserWhereUniqueInput
  }

  export type ShortTagCreateNestedManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortTagCreateWithoutShortInput>, Enumerable<ShortTagUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortTagCreateOrConnectWithoutShortInput>
    createMany?: ShortTagCreateManyShortInputEnvelope
    connect?: Enumerable<ShortTagWhereUniqueInput>
  }

  export type ShortReportCreateNestedManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutShortInput>, Enumerable<ShortReportUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutShortInput>
    createMany?: ShortReportCreateManyShortInputEnvelope
    connect?: Enumerable<ShortReportWhereUniqueInput>
  }

  export type ShortTagUncheckedCreateNestedManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortTagCreateWithoutShortInput>, Enumerable<ShortTagUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortTagCreateOrConnectWithoutShortInput>
    createMany?: ShortTagCreateManyShortInputEnvelope
    connect?: Enumerable<ShortTagWhereUniqueInput>
  }

  export type ShortReportUncheckedCreateNestedManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutShortInput>, Enumerable<ShortReportUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutShortInput>
    createMany?: ShortReportCreateManyShortInputEnvelope
    connect?: Enumerable<ShortReportWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutShortInput = {
    create?: XOR<UserCreateWithoutShortInput, UserUncheckedCreateWithoutShortInput>
    connectOrCreate?: UserCreateOrConnectWithoutShortInput
    upsert?: UserUpsertWithoutShortInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutShortInput, UserUncheckedUpdateWithoutShortInput>
  }

  export type ShortTagUpdateManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortTagCreateWithoutShortInput>, Enumerable<ShortTagUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortTagCreateOrConnectWithoutShortInput>
    upsert?: Enumerable<ShortTagUpsertWithWhereUniqueWithoutShortInput>
    createMany?: ShortTagCreateManyShortInputEnvelope
    set?: Enumerable<ShortTagWhereUniqueInput>
    disconnect?: Enumerable<ShortTagWhereUniqueInput>
    delete?: Enumerable<ShortTagWhereUniqueInput>
    connect?: Enumerable<ShortTagWhereUniqueInput>
    update?: Enumerable<ShortTagUpdateWithWhereUniqueWithoutShortInput>
    updateMany?: Enumerable<ShortTagUpdateManyWithWhereWithoutShortInput>
    deleteMany?: Enumerable<ShortTagScalarWhereInput>
  }

  export type ShortReportUpdateManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutShortInput>, Enumerable<ShortReportUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutShortInput>
    upsert?: Enumerable<ShortReportUpsertWithWhereUniqueWithoutShortInput>
    createMany?: ShortReportCreateManyShortInputEnvelope
    set?: Enumerable<ShortReportWhereUniqueInput>
    disconnect?: Enumerable<ShortReportWhereUniqueInput>
    delete?: Enumerable<ShortReportWhereUniqueInput>
    connect?: Enumerable<ShortReportWhereUniqueInput>
    update?: Enumerable<ShortReportUpdateWithWhereUniqueWithoutShortInput>
    updateMany?: Enumerable<ShortReportUpdateManyWithWhereWithoutShortInput>
    deleteMany?: Enumerable<ShortReportScalarWhereInput>
  }

  export type ShortTagUncheckedUpdateManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortTagCreateWithoutShortInput>, Enumerable<ShortTagUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortTagCreateOrConnectWithoutShortInput>
    upsert?: Enumerable<ShortTagUpsertWithWhereUniqueWithoutShortInput>
    createMany?: ShortTagCreateManyShortInputEnvelope
    set?: Enumerable<ShortTagWhereUniqueInput>
    disconnect?: Enumerable<ShortTagWhereUniqueInput>
    delete?: Enumerable<ShortTagWhereUniqueInput>
    connect?: Enumerable<ShortTagWhereUniqueInput>
    update?: Enumerable<ShortTagUpdateWithWhereUniqueWithoutShortInput>
    updateMany?: Enumerable<ShortTagUpdateManyWithWhereWithoutShortInput>
    deleteMany?: Enumerable<ShortTagScalarWhereInput>
  }

  export type ShortReportUncheckedUpdateManyWithoutShortInput = {
    create?: XOR<Enumerable<ShortReportCreateWithoutShortInput>, Enumerable<ShortReportUncheckedCreateWithoutShortInput>>
    connectOrCreate?: Enumerable<ShortReportCreateOrConnectWithoutShortInput>
    upsert?: Enumerable<ShortReportUpsertWithWhereUniqueWithoutShortInput>
    createMany?: ShortReportCreateManyShortInputEnvelope
    set?: Enumerable<ShortReportWhereUniqueInput>
    disconnect?: Enumerable<ShortReportWhereUniqueInput>
    delete?: Enumerable<ShortReportWhereUniqueInput>
    connect?: Enumerable<ShortReportWhereUniqueInput>
    update?: Enumerable<ShortReportUpdateWithWhereUniqueWithoutShortInput>
    updateMany?: Enumerable<ShortReportUpdateManyWithWhereWithoutShortInput>
    deleteMany?: Enumerable<ShortReportScalarWhereInput>
  }

  export type ShortCreateNestedOneWithoutShortTagInput = {
    create?: XOR<ShortCreateWithoutShortTagInput, ShortUncheckedCreateWithoutShortTagInput>
    connectOrCreate?: ShortCreateOrConnectWithoutShortTagInput
    connect?: ShortWhereUniqueInput
  }

  export type ShortUpdateOneRequiredWithoutShortTagInput = {
    create?: XOR<ShortCreateWithoutShortTagInput, ShortUncheckedCreateWithoutShortTagInput>
    connectOrCreate?: ShortCreateOrConnectWithoutShortTagInput
    upsert?: ShortUpsertWithoutShortTagInput
    connect?: ShortWhereUniqueInput
    update?: XOR<ShortUpdateWithoutShortTagInput, ShortUncheckedUpdateWithoutShortTagInput>
  }

  export type UserCreateNestedOneWithoutShortReportInput = {
    create?: XOR<UserCreateWithoutShortReportInput, UserUncheckedCreateWithoutShortReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutShortReportInput
    connect?: UserWhereUniqueInput
  }

  export type ShortCreateNestedOneWithoutShortReportInput = {
    create?: XOR<ShortCreateWithoutShortReportInput, ShortUncheckedCreateWithoutShortReportInput>
    connectOrCreate?: ShortCreateOrConnectWithoutShortReportInput
    connect?: ShortWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShortReportInput = {
    create?: XOR<UserCreateWithoutShortReportInput, UserUncheckedCreateWithoutShortReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutShortReportInput
    upsert?: UserUpsertWithoutShortReportInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutShortReportInput, UserUncheckedUpdateWithoutShortReportInput>
  }

  export type ShortUpdateOneRequiredWithoutShortReportInput = {
    create?: XOR<ShortCreateWithoutShortReportInput, ShortUncheckedCreateWithoutShortReportInput>
    connectOrCreate?: ShortCreateOrConnectWithoutShortReportInput
    upsert?: ShortUpsertWithoutShortReportInput
    connect?: ShortWhereUniqueInput
    update?: XOR<ShortUpdateWithoutShortReportInput, ShortUncheckedUpdateWithoutShortReportInput>
  }

  export type UserCreateNestedOneWithoutNotificationFromInput = {
    create?: XOR<UserCreateWithoutNotificationFromInput, UserUncheckedCreateWithoutNotificationFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationFromInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationToInput = {
    create?: XOR<UserCreateWithoutNotificationToInput, UserUncheckedCreateWithoutNotificationToInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationToInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationFromInput = {
    create?: XOR<UserCreateWithoutNotificationFromInput, UserUncheckedCreateWithoutNotificationFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationFromInput
    upsert?: UserUpsertWithoutNotificationFromInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationFromInput, UserUncheckedUpdateWithoutNotificationFromInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationToInput = {
    create?: XOR<UserCreateWithoutNotificationToInput, UserUncheckedCreateWithoutNotificationToInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationToInput
    upsert?: UserUpsertWithoutNotificationToInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationToInput, UserUncheckedUpdateWithoutNotificationToInput>
  }

  export type UserCreateNestedOneWithoutBlogInput = {
    create?: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCommentCreateNestedManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutBlogInput>, Enumerable<BlogCommentUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutBlogInput>
    createMany?: BlogCommentCreateManyBlogInputEnvelope
    connect?: Enumerable<BlogCommentWhereUniqueInput>
  }

  export type BlogMediaCreateNestedManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogMediaCreateWithoutBlogInput>, Enumerable<BlogMediaUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogMediaCreateOrConnectWithoutBlogInput>
    createMany?: BlogMediaCreateManyBlogInputEnvelope
    connect?: Enumerable<BlogMediaWhereUniqueInput>
  }

  export type BlogCommentUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutBlogInput>, Enumerable<BlogCommentUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutBlogInput>
    createMany?: BlogCommentCreateManyBlogInputEnvelope
    connect?: Enumerable<BlogCommentWhereUniqueInput>
  }

  export type BlogMediaUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogMediaCreateWithoutBlogInput>, Enumerable<BlogMediaUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogMediaCreateOrConnectWithoutBlogInput>
    createMany?: BlogMediaCreateManyBlogInputEnvelope
    connect?: Enumerable<BlogMediaWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutBlogInput = {
    create?: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogInput
    upsert?: UserUpsertWithoutBlogInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBlogInput, UserUncheckedUpdateWithoutBlogInput>
  }

  export type BlogCommentUpdateManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutBlogInput>, Enumerable<BlogCommentUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutBlogInput>
    upsert?: Enumerable<BlogCommentUpsertWithWhereUniqueWithoutBlogInput>
    createMany?: BlogCommentCreateManyBlogInputEnvelope
    set?: Enumerable<BlogCommentWhereUniqueInput>
    disconnect?: Enumerable<BlogCommentWhereUniqueInput>
    delete?: Enumerable<BlogCommentWhereUniqueInput>
    connect?: Enumerable<BlogCommentWhereUniqueInput>
    update?: Enumerable<BlogCommentUpdateWithWhereUniqueWithoutBlogInput>
    updateMany?: Enumerable<BlogCommentUpdateManyWithWhereWithoutBlogInput>
    deleteMany?: Enumerable<BlogCommentScalarWhereInput>
  }

  export type BlogMediaUpdateManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogMediaCreateWithoutBlogInput>, Enumerable<BlogMediaUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogMediaCreateOrConnectWithoutBlogInput>
    upsert?: Enumerable<BlogMediaUpsertWithWhereUniqueWithoutBlogInput>
    createMany?: BlogMediaCreateManyBlogInputEnvelope
    set?: Enumerable<BlogMediaWhereUniqueInput>
    disconnect?: Enumerable<BlogMediaWhereUniqueInput>
    delete?: Enumerable<BlogMediaWhereUniqueInput>
    connect?: Enumerable<BlogMediaWhereUniqueInput>
    update?: Enumerable<BlogMediaUpdateWithWhereUniqueWithoutBlogInput>
    updateMany?: Enumerable<BlogMediaUpdateManyWithWhereWithoutBlogInput>
    deleteMany?: Enumerable<BlogMediaScalarWhereInput>
  }

  export type BlogCommentUncheckedUpdateManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogCommentCreateWithoutBlogInput>, Enumerable<BlogCommentUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogCommentCreateOrConnectWithoutBlogInput>
    upsert?: Enumerable<BlogCommentUpsertWithWhereUniqueWithoutBlogInput>
    createMany?: BlogCommentCreateManyBlogInputEnvelope
    set?: Enumerable<BlogCommentWhereUniqueInput>
    disconnect?: Enumerable<BlogCommentWhereUniqueInput>
    delete?: Enumerable<BlogCommentWhereUniqueInput>
    connect?: Enumerable<BlogCommentWhereUniqueInput>
    update?: Enumerable<BlogCommentUpdateWithWhereUniqueWithoutBlogInput>
    updateMany?: Enumerable<BlogCommentUpdateManyWithWhereWithoutBlogInput>
    deleteMany?: Enumerable<BlogCommentScalarWhereInput>
  }

  export type BlogMediaUncheckedUpdateManyWithoutBlogInput = {
    create?: XOR<Enumerable<BlogMediaCreateWithoutBlogInput>, Enumerable<BlogMediaUncheckedCreateWithoutBlogInput>>
    connectOrCreate?: Enumerable<BlogMediaCreateOrConnectWithoutBlogInput>
    upsert?: Enumerable<BlogMediaUpsertWithWhereUniqueWithoutBlogInput>
    createMany?: BlogMediaCreateManyBlogInputEnvelope
    set?: Enumerable<BlogMediaWhereUniqueInput>
    disconnect?: Enumerable<BlogMediaWhereUniqueInput>
    delete?: Enumerable<BlogMediaWhereUniqueInput>
    connect?: Enumerable<BlogMediaWhereUniqueInput>
    update?: Enumerable<BlogMediaUpdateWithWhereUniqueWithoutBlogInput>
    updateMany?: Enumerable<BlogMediaUpdateManyWithWhereWithoutBlogInput>
    deleteMany?: Enumerable<BlogMediaScalarWhereInput>
  }

  export type BlogCreateNestedOneWithoutBlogCommentInput = {
    create?: XOR<BlogCreateWithoutBlogCommentInput, BlogUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: BlogCreateOrConnectWithoutBlogCommentInput
    connect?: BlogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlogCommentInput = {
    create?: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentInput
    connect?: UserWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutBlogCommentInput = {
    create?: XOR<BlogCreateWithoutBlogCommentInput, BlogUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: BlogCreateOrConnectWithoutBlogCommentInput
    upsert?: BlogUpsertWithoutBlogCommentInput
    connect?: BlogWhereUniqueInput
    update?: XOR<BlogUpdateWithoutBlogCommentInput, BlogUncheckedUpdateWithoutBlogCommentInput>
  }

  export type UserUpdateOneRequiredWithoutBlogCommentInput = {
    create?: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogCommentInput
    upsert?: UserUpsertWithoutBlogCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBlogCommentInput, UserUncheckedUpdateWithoutBlogCommentInput>
  }

  export type BlogCreateNestedOneWithoutBlogMediaInput = {
    create?: XOR<BlogCreateWithoutBlogMediaInput, BlogUncheckedCreateWithoutBlogMediaInput>
    connectOrCreate?: BlogCreateOrConnectWithoutBlogMediaInput
    connect?: BlogWhereUniqueInput
  }

  export type BlogUpdateOneRequiredWithoutBlogMediaInput = {
    create?: XOR<BlogCreateWithoutBlogMediaInput, BlogUncheckedCreateWithoutBlogMediaInput>
    connectOrCreate?: BlogCreateOrConnectWithoutBlogMediaInput
    upsert?: BlogUpsertWithoutBlogMediaInput
    connect?: BlogWhereUniqueInput
    update?: XOR<BlogUpdateWithoutBlogMediaInput, BlogUncheckedUpdateWithoutBlogMediaInput>
  }

  export type UserCreateNestedOneWithoutUserTokenInput = {
    create?: XOR<UserCreateWithoutUserTokenInput, UserUncheckedCreateWithoutUserTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTokenInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserTokenInput = {
    create?: XOR<UserCreateWithoutUserTokenInput, UserUncheckedCreateWithoutUserTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserTokenInput
    upsert?: UserUpsertWithoutUserTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserTokenInput, UserUncheckedUpdateWithoutUserTokenInput>
  }

  export type UserCreateNestedOneWithoutUserContactNumberInput = {
    create?: XOR<UserCreateWithoutUserContactNumberInput, UserUncheckedCreateWithoutUserContactNumberInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserContactNumberInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserContactNumberInput = {
    create?: XOR<UserCreateWithoutUserContactNumberInput, UserUncheckedCreateWithoutUserContactNumberInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserContactNumberInput
    upsert?: UserUpsertWithoutUserContactNumberInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserContactNumberInput, UserUncheckedUpdateWithoutUserContactNumberInput>
  }

  export type UserCreateNestedOneWithoutUserExperienceInput = {
    create?: XOR<UserCreateWithoutUserExperienceInput, UserUncheckedCreateWithoutUserExperienceInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserExperienceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserExperienceInput = {
    create?: XOR<UserCreateWithoutUserExperienceInput, UserUncheckedCreateWithoutUserExperienceInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserExperienceInput
    upsert?: UserUpsertWithoutUserExperienceInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserExperienceInput, UserUncheckedUpdateWithoutUserExperienceInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedEnumPermissionTypeFilter = {
    equals?: PermissionType
    in?: Enumerable<PermissionType>
    notIn?: Enumerable<PermissionType>
    not?: NestedEnumPermissionTypeFilter | PermissionType
  }

  export type NestedEnumPermissionCategoryFilter = {
    equals?: PermissionCategory
    in?: Enumerable<PermissionCategory>
    notIn?: Enumerable<PermissionCategory>
    not?: NestedEnumPermissionCategoryFilter | PermissionCategory
  }

  export type NestedEnumPermissionTenantFilter = {
    equals?: PermissionTenant
    in?: Enumerable<PermissionTenant>
    notIn?: Enumerable<PermissionTenant>
    not?: NestedEnumPermissionTenantFilter | PermissionTenant
  }

  export type NestedEnumPermissionTypeWithAggregatesFilter = {
    equals?: PermissionType
    in?: Enumerable<PermissionType>
    notIn?: Enumerable<PermissionType>
    not?: NestedEnumPermissionTypeWithAggregatesFilter | PermissionType
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionTypeFilter
    _max?: NestedEnumPermissionTypeFilter
  }

  export type NestedEnumPermissionCategoryWithAggregatesFilter = {
    equals?: PermissionCategory
    in?: Enumerable<PermissionCategory>
    notIn?: Enumerable<PermissionCategory>
    not?: NestedEnumPermissionCategoryWithAggregatesFilter | PermissionCategory
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionCategoryFilter
    _max?: NestedEnumPermissionCategoryFilter
  }

  export type NestedEnumPermissionTenantWithAggregatesFilter = {
    equals?: PermissionTenant
    in?: Enumerable<PermissionTenant>
    notIn?: Enumerable<PermissionTenant>
    not?: NestedEnumPermissionTenantWithAggregatesFilter | PermissionTenant
    _count?: NestedIntFilter
    _min?: NestedEnumPermissionTenantFilter
    _max?: NestedEnumPermissionTenantFilter
  }

  export type NestedEnumSocialMediaFilter = {
    equals?: SocialMedia
    in?: Enumerable<SocialMedia>
    notIn?: Enumerable<SocialMedia>
    not?: NestedEnumSocialMediaFilter | SocialMedia
  }

  export type NestedEnumSocialMediaWithAggregatesFilter = {
    equals?: SocialMedia
    in?: Enumerable<SocialMedia>
    notIn?: Enumerable<SocialMedia>
    not?: NestedEnumSocialMediaWithAggregatesFilter | SocialMedia
    _count?: NestedIntFilter
    _min?: NestedEnumSocialMediaFilter
    _max?: NestedEnumSocialMediaFilter
  }

  export type NestedEnumFileCategoryNullableFilter = {
    equals?: FileCategory | null
    in?: Enumerable<FileCategory> | null
    notIn?: Enumerable<FileCategory> | null
    not?: NestedEnumFileCategoryNullableFilter | FileCategory | null
  }

  export type NestedEnumFileCategoryNullableWithAggregatesFilter = {
    equals?: FileCategory | null
    in?: Enumerable<FileCategory> | null
    notIn?: Enumerable<FileCategory> | null
    not?: NestedEnumFileCategoryNullableWithAggregatesFilter | FileCategory | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumFileCategoryNullableFilter
    _max?: NestedEnumFileCategoryNullableFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: JsonNullValueFilter | InputJsonValue
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: JsonNullValueFilter | InputJsonValue
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type UserCreateWithoutUserInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: Enumerable<UserCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type UserScoutedCreateWithoutUserScoutInput = {
    date?: Date | string | null
    user: UserCreateNestedOneWithoutUserScoutedInput
  }

  export type UserScoutedUncheckedCreateWithoutUserScoutInput = {
    userId: string
    date?: Date | string | null
  }

  export type UserScoutedCreateOrConnectWithoutUserScoutInput = {
    where: UserScoutedWhereUniqueInput
    create: XOR<UserScoutedCreateWithoutUserScoutInput, UserScoutedUncheckedCreateWithoutUserScoutInput>
  }

  export type UserScoutedCreateManyUserScoutInputEnvelope = {
    data: Enumerable<UserScoutedCreateManyUserScoutInput>
    skipDuplicates?: boolean
  }

  export type UserScoutedCreateWithoutUserInput = {
    date?: Date | string | null
    userScout: UserCreateNestedOneWithoutUserScoutInput
  }

  export type UserScoutedUncheckedCreateWithoutUserInput = {
    userIdScout: string
    date?: Date | string | null
  }

  export type UserScoutedCreateOrConnectWithoutUserInput = {
    where: UserScoutedWhereUniqueInput
    create: XOR<UserScoutedCreateWithoutUserInput, UserScoutedUncheckedCreateWithoutUserInput>
  }

  export type UserScoutedCreateManyUserInputEnvelope = {
    data: Enumerable<UserScoutedCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    role: Role
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    role: Role
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: Enumerable<UserRoleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserPermissionsCreateWithoutUserInput = {
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type UserPermissionsUncheckedCreateWithoutUserInput = {
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type UserPermissionsCreateOrConnectWithoutUserInput = {
    where: UserPermissionsWhereUniqueInput
    create: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionsCreateManyUserInputEnvelope = {
    data: Enumerable<UserPermissionsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserProfileCreateWithoutUserInput = {
    profilePicture?: string | null
    bio?: string | null
    employmentStatus?: boolean
    openToOffers?: boolean
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    profilePicture?: string | null
    bio?: string | null
    employmentStatus?: boolean
    openToOffers?: boolean
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileCreateManyUserInputEnvelope = {
    data: Enumerable<UserProfileCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserTagCreateWithoutUserInput = {
    tag: string
  }

  export type UserTagUncheckedCreateWithoutUserInput = {
    tag: string
  }

  export type UserTagCreateOrConnectWithoutUserInput = {
    where: UserTagWhereUniqueInput
    create: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput>
  }

  export type UserTagCreateManyUserInputEnvelope = {
    data: Enumerable<UserTagCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserContactNumberCreateWithoutUserInput = {
    number: string
  }

  export type UserContactNumberUncheckedCreateWithoutUserInput = {
    number: string
  }

  export type UserContactNumberCreateOrConnectWithoutUserInput = {
    where: UserContactNumberWhereUniqueInput
    create: XOR<UserContactNumberCreateWithoutUserInput, UserContactNumberUncheckedCreateWithoutUserInput>
  }

  export type UserContactNumberCreateManyUserInputEnvelope = {
    data: Enumerable<UserContactNumberCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserDegreeCreateWithoutUserInput = {
    degreeType: string
    degreeName: string
  }

  export type UserDegreeUncheckedCreateWithoutUserInput = {
    degreeType: string
    degreeName: string
  }

  export type UserDegreeCreateOrConnectWithoutUserInput = {
    where: UserDegreeWhereUniqueInput
    create: XOR<UserDegreeCreateWithoutUserInput, UserDegreeUncheckedCreateWithoutUserInput>
  }

  export type UserDegreeCreateManyUserInputEnvelope = {
    data: Enumerable<UserDegreeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserExperienceCreateWithoutUserInput = {
    experience: string
  }

  export type UserExperienceUncheckedCreateWithoutUserInput = {
    experience: string
  }

  export type UserExperienceCreateOrConnectWithoutUserInput = {
    where: UserExperienceWhereUniqueInput
    create: XOR<UserExperienceCreateWithoutUserInput, UserExperienceUncheckedCreateWithoutUserInput>
  }

  export type UserExperienceCreateManyUserInputEnvelope = {
    data: Enumerable<UserExperienceCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserSocialMediaCreateWithoutUserInput = {
    type: SocialMedia
    link: string
  }

  export type UserSocialMediaUncheckedCreateWithoutUserInput = {
    type: SocialMedia
    link: string
  }

  export type UserSocialMediaCreateOrConnectWithoutUserInput = {
    where: UserSocialMediaWhereUniqueInput
    create: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
  }

  export type UserSocialMediaCreateManyUserInputEnvelope = {
    data: Enumerable<UserSocialMediaCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserLocationCreateWithoutUserInput = {
    location: string
  }

  export type UserLocationUncheckedCreateWithoutUserInput = {
    location: string
  }

  export type UserLocationCreateOrConnectWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    create: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput>
  }

  export type UserLocationCreateManyUserInputEnvelope = {
    data: Enumerable<UserLocationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserEmailCreateWithoutUserInput = {
    email: string
  }

  export type UserEmailUncheckedCreateWithoutUserInput = {
    email: string
  }

  export type UserEmailCreateOrConnectWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    create: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput>
  }

  export type UserEmailCreateManyUserInputEnvelope = {
    data: Enumerable<UserEmailCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserProfileFileCreateWithoutUserInput = {
    fileId?: string
    filePath: string
    fileCategory?: FileCategory | null
    fileExtension?: string | null
  }

  export type UserProfileFileUncheckedCreateWithoutUserInput = {
    fileId?: string
    filePath: string
    fileCategory?: FileCategory | null
    fileExtension?: string | null
  }

  export type UserProfileFileCreateOrConnectWithoutUserInput = {
    where: UserProfileFileWhereUniqueInput
    create: XOR<UserProfileFileCreateWithoutUserInput, UserProfileFileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileFileCreateManyUserInputEnvelope = {
    data: Enumerable<UserProfileFileCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ShortCreateWithoutUserInput = {
    id?: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    shortTag?: ShortTagCreateNestedManyWithoutShortInput
    shortReport?: ShortReportCreateNestedManyWithoutShortInput
  }

  export type ShortUncheckedCreateWithoutUserInput = {
    id?: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    shortTag?: ShortTagUncheckedCreateNestedManyWithoutShortInput
    shortReport?: ShortReportUncheckedCreateNestedManyWithoutShortInput
  }

  export type ShortCreateOrConnectWithoutUserInput = {
    where: ShortWhereUniqueInput
    create: XOR<ShortCreateWithoutUserInput, ShortUncheckedCreateWithoutUserInput>
  }

  export type ShortCreateManyUserInputEnvelope = {
    data: Enumerable<ShortCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ShortReportCreateWithoutUserInput = {
    reason: string
    short: ShortCreateNestedOneWithoutShortReportInput
  }

  export type ShortReportUncheckedCreateWithoutUserInput = {
    shortId: string
    reason: string
  }

  export type ShortReportCreateOrConnectWithoutUserInput = {
    where: ShortReportWhereUniqueInput
    create: XOR<ShortReportCreateWithoutUserInput, ShortReportUncheckedCreateWithoutUserInput>
  }

  export type ShortReportCreateManyUserInputEnvelope = {
    data: Enumerable<ShortReportCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutNotificationFromInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
    notificationTo: UserCreateNestedOneWithoutNotificationToInput
  }

  export type NotificationUncheckedCreateWithoutNotificationFromInput = {
    id?: string
    userIdTo: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
  }

  export type NotificationCreateOrConnectWithoutNotificationFromInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutNotificationFromInput, NotificationUncheckedCreateWithoutNotificationFromInput>
  }

  export type NotificationCreateManyNotificationFromInputEnvelope = {
    data: Enumerable<NotificationCreateManyNotificationFromInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutNotificationToInput = {
    id?: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
    notificationFrom?: UserCreateNestedOneWithoutNotificationFromInput
  }

  export type NotificationUncheckedCreateWithoutNotificationToInput = {
    id?: string
    userIdFrom?: string | null
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
  }

  export type NotificationCreateOrConnectWithoutNotificationToInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutNotificationToInput, NotificationUncheckedCreateWithoutNotificationToInput>
  }

  export type NotificationCreateManyNotificationToInputEnvelope = {
    data: Enumerable<NotificationCreateManyNotificationToInput>
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutUserInput = {
    id?: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    blogComment?: BlogCommentCreateNestedManyWithoutBlogInput
    blogMedia?: BlogMediaCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    blogComment?: BlogCommentUncheckedCreateNestedManyWithoutBlogInput
    blogMedia?: BlogMediaUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutUserInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput>
  }

  export type BlogCreateManyUserInputEnvelope = {
    data: Enumerable<BlogCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type BlogCommentCreateWithoutUserInput = {
    id?: string
    content: string
    date: Date | string
    blog: BlogCreateNestedOneWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutUserInput = {
    id?: string
    blogId: string
    content: string
    date: Date | string
  }

  export type BlogCommentCreateOrConnectWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentCreateManyUserInputEnvelope = {
    data: Enumerable<BlogCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserTokenCreateWithoutUserInput = {
    userToken: string
    userTokenType: number
    userTokenExpiration: number
  }

  export type UserTokenUncheckedCreateWithoutUserInput = {
    userToken: string
    userTokenType: number
    userTokenExpiration: number
  }

  export type UserTokenCreateOrConnectWithoutUserInput = {
    where: UserTokenWhereUniqueInput
    create: XOR<UserTokenCreateWithoutUserInput, UserTokenUncheckedCreateWithoutUserInput>
  }

  export type UserTokenCreateManyUserInputEnvelope = {
    data: Enumerable<UserTokenCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserInput = {
    update: XOR<UserUpdateWithoutUserInput, UserUncheckedUpdateWithoutUserInput>
    create: XOR<UserCreateWithoutUserInput, UserUncheckedCreateWithoutUserInput>
  }

  export type UserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    password?: StringNullableFilter | string | null
    passwordSalt?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    dateOfBirth?: DateTimeNullableFilter | Date | string | null
    companyId?: StringNullableFilter | string | null
    created?: DateTimeFilter | Date | string
    suspended?: BoolFilter | boolean
    validated?: BoolFilter | boolean
  }

  export type UserScoutedUpsertWithWhereUniqueWithoutUserScoutInput = {
    where: UserScoutedWhereUniqueInput
    update: XOR<UserScoutedUpdateWithoutUserScoutInput, UserScoutedUncheckedUpdateWithoutUserScoutInput>
    create: XOR<UserScoutedCreateWithoutUserScoutInput, UserScoutedUncheckedCreateWithoutUserScoutInput>
  }

  export type UserScoutedUpdateWithWhereUniqueWithoutUserScoutInput = {
    where: UserScoutedWhereUniqueInput
    data: XOR<UserScoutedUpdateWithoutUserScoutInput, UserScoutedUncheckedUpdateWithoutUserScoutInput>
  }

  export type UserScoutedUpdateManyWithWhereWithoutUserScoutInput = {
    where: UserScoutedScalarWhereInput
    data: XOR<UserScoutedUpdateManyMutationInput, UserScoutedUncheckedUpdateManyWithoutUserScoutInput>
  }

  export type UserScoutedScalarWhereInput = {
    AND?: Enumerable<UserScoutedScalarWhereInput>
    OR?: Enumerable<UserScoutedScalarWhereInput>
    NOT?: Enumerable<UserScoutedScalarWhereInput>
    userIdScout?: StringFilter | string
    userId?: StringFilter | string
    date?: DateTimeNullableFilter | Date | string | null
  }

  export type UserScoutedUpsertWithWhereUniqueWithoutUserInput = {
    where: UserScoutedWhereUniqueInput
    update: XOR<UserScoutedUpdateWithoutUserInput, UserScoutedUncheckedUpdateWithoutUserInput>
    create: XOR<UserScoutedCreateWithoutUserInput, UserScoutedUncheckedCreateWithoutUserInput>
  }

  export type UserScoutedUpdateWithWhereUniqueWithoutUserInput = {
    where: UserScoutedWhereUniqueInput
    data: XOR<UserScoutedUpdateWithoutUserInput, UserScoutedUncheckedUpdateWithoutUserInput>
  }

  export type UserScoutedUpdateManyWithWhereWithoutUserInput = {
    where: UserScoutedScalarWhereInput
    data: XOR<UserScoutedUpdateManyMutationInput, UserScoutedUncheckedUpdateManyWithoutUserScoutedInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: Enumerable<UserRoleScalarWhereInput>
    OR?: Enumerable<UserRoleScalarWhereInput>
    NOT?: Enumerable<UserRoleScalarWhereInput>
    userId?: StringFilter | string
    role?: EnumRoleFilter | Role
  }

  export type UserPermissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPermissionsWhereUniqueInput
    update: XOR<UserPermissionsUpdateWithoutUserInput, UserPermissionsUncheckedUpdateWithoutUserInput>
    create: XOR<UserPermissionsCreateWithoutUserInput, UserPermissionsUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPermissionsWhereUniqueInput
    data: XOR<UserPermissionsUpdateWithoutUserInput, UserPermissionsUncheckedUpdateWithoutUserInput>
  }

  export type UserPermissionsUpdateManyWithWhereWithoutUserInput = {
    where: UserPermissionsScalarWhereInput
    data: XOR<UserPermissionsUpdateManyMutationInput, UserPermissionsUncheckedUpdateManyWithoutUserPermissionsInput>
  }

  export type UserPermissionsScalarWhereInput = {
    AND?: Enumerable<UserPermissionsScalarWhereInput>
    OR?: Enumerable<UserPermissionsScalarWhereInput>
    NOT?: Enumerable<UserPermissionsScalarWhereInput>
    userId?: StringFilter | string
    permissionType?: EnumPermissionTypeFilter | PermissionType
    permissionCategory?: EnumPermissionCategoryFilter | PermissionCategory
    permissionTenant?: EnumPermissionTenantFilter | PermissionTenant
  }

  export type UserProfileUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutUserInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type UserProfileScalarWhereInput = {
    AND?: Enumerable<UserProfileScalarWhereInput>
    OR?: Enumerable<UserProfileScalarWhereInput>
    NOT?: Enumerable<UserProfileScalarWhereInput>
    userId?: StringFilter | string
    profilePicture?: StringNullableFilter | string | null
    bio?: StringNullableFilter | string | null
    employmentStatus?: BoolFilter | boolean
    openToOffers?: BoolFilter | boolean
  }

  export type UserTagUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTagWhereUniqueInput
    update: XOR<UserTagUpdateWithoutUserInput, UserTagUncheckedUpdateWithoutUserInput>
    create: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput>
  }

  export type UserTagUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTagWhereUniqueInput
    data: XOR<UserTagUpdateWithoutUserInput, UserTagUncheckedUpdateWithoutUserInput>
  }

  export type UserTagUpdateManyWithWhereWithoutUserInput = {
    where: UserTagScalarWhereInput
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyWithoutUserTagInput>
  }

  export type UserTagScalarWhereInput = {
    AND?: Enumerable<UserTagScalarWhereInput>
    OR?: Enumerable<UserTagScalarWhereInput>
    NOT?: Enumerable<UserTagScalarWhereInput>
    userId?: StringFilter | string
    tag?: StringFilter | string
  }

  export type UserContactNumberUpsertWithWhereUniqueWithoutUserInput = {
    where: UserContactNumberWhereUniqueInput
    update: XOR<UserContactNumberUpdateWithoutUserInput, UserContactNumberUncheckedUpdateWithoutUserInput>
    create: XOR<UserContactNumberCreateWithoutUserInput, UserContactNumberUncheckedCreateWithoutUserInput>
  }

  export type UserContactNumberUpdateWithWhereUniqueWithoutUserInput = {
    where: UserContactNumberWhereUniqueInput
    data: XOR<UserContactNumberUpdateWithoutUserInput, UserContactNumberUncheckedUpdateWithoutUserInput>
  }

  export type UserContactNumberUpdateManyWithWhereWithoutUserInput = {
    where: UserContactNumberScalarWhereInput
    data: XOR<UserContactNumberUpdateManyMutationInput, UserContactNumberUncheckedUpdateManyWithoutUserContactNumberInput>
  }

  export type UserContactNumberScalarWhereInput = {
    AND?: Enumerable<UserContactNumberScalarWhereInput>
    OR?: Enumerable<UserContactNumberScalarWhereInput>
    NOT?: Enumerable<UserContactNumberScalarWhereInput>
    userId?: StringFilter | string
    number?: StringFilter | string
  }

  export type UserDegreeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDegreeWhereUniqueInput
    update: XOR<UserDegreeUpdateWithoutUserInput, UserDegreeUncheckedUpdateWithoutUserInput>
    create: XOR<UserDegreeCreateWithoutUserInput, UserDegreeUncheckedCreateWithoutUserInput>
  }

  export type UserDegreeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDegreeWhereUniqueInput
    data: XOR<UserDegreeUpdateWithoutUserInput, UserDegreeUncheckedUpdateWithoutUserInput>
  }

  export type UserDegreeUpdateManyWithWhereWithoutUserInput = {
    where: UserDegreeScalarWhereInput
    data: XOR<UserDegreeUpdateManyMutationInput, UserDegreeUncheckedUpdateManyWithoutUserDegreeInput>
  }

  export type UserDegreeScalarWhereInput = {
    AND?: Enumerable<UserDegreeScalarWhereInput>
    OR?: Enumerable<UserDegreeScalarWhereInput>
    NOT?: Enumerable<UserDegreeScalarWhereInput>
    userID?: StringFilter | string
    degreeType?: StringFilter | string
    degreeName?: StringFilter | string
  }

  export type UserExperienceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserExperienceWhereUniqueInput
    update: XOR<UserExperienceUpdateWithoutUserInput, UserExperienceUncheckedUpdateWithoutUserInput>
    create: XOR<UserExperienceCreateWithoutUserInput, UserExperienceUncheckedCreateWithoutUserInput>
  }

  export type UserExperienceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserExperienceWhereUniqueInput
    data: XOR<UserExperienceUpdateWithoutUserInput, UserExperienceUncheckedUpdateWithoutUserInput>
  }

  export type UserExperienceUpdateManyWithWhereWithoutUserInput = {
    where: UserExperienceScalarWhereInput
    data: XOR<UserExperienceUpdateManyMutationInput, UserExperienceUncheckedUpdateManyWithoutUserExperienceInput>
  }

  export type UserExperienceScalarWhereInput = {
    AND?: Enumerable<UserExperienceScalarWhereInput>
    OR?: Enumerable<UserExperienceScalarWhereInput>
    NOT?: Enumerable<UserExperienceScalarWhereInput>
    userId?: StringFilter | string
    experience?: StringFilter | string
  }

  export type UserSocialMediaUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSocialMediaWhereUniqueInput
    update: XOR<UserSocialMediaUpdateWithoutUserInput, UserSocialMediaUncheckedUpdateWithoutUserInput>
    create: XOR<UserSocialMediaCreateWithoutUserInput, UserSocialMediaUncheckedCreateWithoutUserInput>
  }

  export type UserSocialMediaUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSocialMediaWhereUniqueInput
    data: XOR<UserSocialMediaUpdateWithoutUserInput, UserSocialMediaUncheckedUpdateWithoutUserInput>
  }

  export type UserSocialMediaUpdateManyWithWhereWithoutUserInput = {
    where: UserSocialMediaScalarWhereInput
    data: XOR<UserSocialMediaUpdateManyMutationInput, UserSocialMediaUncheckedUpdateManyWithoutUserSocialMediaInput>
  }

  export type UserSocialMediaScalarWhereInput = {
    AND?: Enumerable<UserSocialMediaScalarWhereInput>
    OR?: Enumerable<UserSocialMediaScalarWhereInput>
    NOT?: Enumerable<UserSocialMediaScalarWhereInput>
    userId?: StringFilter | string
    type?: EnumSocialMediaFilter | SocialMedia
    link?: StringFilter | string
  }

  export type UserLocationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    update: XOR<UserLocationUpdateWithoutUserInput, UserLocationUncheckedUpdateWithoutUserInput>
    create: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput>
  }

  export type UserLocationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    data: XOR<UserLocationUpdateWithoutUserInput, UserLocationUncheckedUpdateWithoutUserInput>
  }

  export type UserLocationUpdateManyWithWhereWithoutUserInput = {
    where: UserLocationScalarWhereInput
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyWithoutUserLocationInput>
  }

  export type UserLocationScalarWhereInput = {
    AND?: Enumerable<UserLocationScalarWhereInput>
    OR?: Enumerable<UserLocationScalarWhereInput>
    NOT?: Enumerable<UserLocationScalarWhereInput>
    userId?: StringFilter | string
    location?: StringFilter | string
  }

  export type UserEmailUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    update: XOR<UserEmailUpdateWithoutUserInput, UserEmailUncheckedUpdateWithoutUserInput>
    create: XOR<UserEmailCreateWithoutUserInput, UserEmailUncheckedCreateWithoutUserInput>
  }

  export type UserEmailUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEmailWhereUniqueInput
    data: XOR<UserEmailUpdateWithoutUserInput, UserEmailUncheckedUpdateWithoutUserInput>
  }

  export type UserEmailUpdateManyWithWhereWithoutUserInput = {
    where: UserEmailScalarWhereInput
    data: XOR<UserEmailUpdateManyMutationInput, UserEmailUncheckedUpdateManyWithoutUserEmailInput>
  }

  export type UserEmailScalarWhereInput = {
    AND?: Enumerable<UserEmailScalarWhereInput>
    OR?: Enumerable<UserEmailScalarWhereInput>
    NOT?: Enumerable<UserEmailScalarWhereInput>
    userId?: StringFilter | string
    email?: StringFilter | string
  }

  export type UserProfileFileUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProfileFileWhereUniqueInput
    update: XOR<UserProfileFileUpdateWithoutUserInput, UserProfileFileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileFileCreateWithoutUserInput, UserProfileFileUncheckedCreateWithoutUserInput>
  }

  export type UserProfileFileUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProfileFileWhereUniqueInput
    data: XOR<UserProfileFileUpdateWithoutUserInput, UserProfileFileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileFileUpdateManyWithWhereWithoutUserInput = {
    where: UserProfileFileScalarWhereInput
    data: XOR<UserProfileFileUpdateManyMutationInput, UserProfileFileUncheckedUpdateManyWithoutUserProfileFileInput>
  }

  export type UserProfileFileScalarWhereInput = {
    AND?: Enumerable<UserProfileFileScalarWhereInput>
    OR?: Enumerable<UserProfileFileScalarWhereInput>
    NOT?: Enumerable<UserProfileFileScalarWhereInput>
    fileId?: StringFilter | string
    userId?: StringFilter | string
    filePath?: StringFilter | string
    fileCategory?: EnumFileCategoryNullableFilter | FileCategory | null
    fileExtension?: StringNullableFilter | string | null
  }

  export type ShortUpsertWithWhereUniqueWithoutUserInput = {
    where: ShortWhereUniqueInput
    update: XOR<ShortUpdateWithoutUserInput, ShortUncheckedUpdateWithoutUserInput>
    create: XOR<ShortCreateWithoutUserInput, ShortUncheckedCreateWithoutUserInput>
  }

  export type ShortUpdateWithWhereUniqueWithoutUserInput = {
    where: ShortWhereUniqueInput
    data: XOR<ShortUpdateWithoutUserInput, ShortUncheckedUpdateWithoutUserInput>
  }

  export type ShortUpdateManyWithWhereWithoutUserInput = {
    where: ShortScalarWhereInput
    data: XOR<ShortUpdateManyMutationInput, ShortUncheckedUpdateManyWithoutShortInput>
  }

  export type ShortScalarWhereInput = {
    AND?: Enumerable<ShortScalarWhereInput>
    OR?: Enumerable<ShortScalarWhereInput>
    NOT?: Enumerable<ShortScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    description?: StringNullableFilter | string | null
    link?: StringNullableFilter | string | null
    thumbnail?: StringNullableFilter | string | null
    datePosted?: DateTimeFilter | Date | string
    archived?: BoolFilter | boolean
  }

  export type ShortReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ShortReportWhereUniqueInput
    update: XOR<ShortReportUpdateWithoutUserInput, ShortReportUncheckedUpdateWithoutUserInput>
    create: XOR<ShortReportCreateWithoutUserInput, ShortReportUncheckedCreateWithoutUserInput>
  }

  export type ShortReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ShortReportWhereUniqueInput
    data: XOR<ShortReportUpdateWithoutUserInput, ShortReportUncheckedUpdateWithoutUserInput>
  }

  export type ShortReportUpdateManyWithWhereWithoutUserInput = {
    where: ShortReportScalarWhereInput
    data: XOR<ShortReportUpdateManyMutationInput, ShortReportUncheckedUpdateManyWithoutShortReportInput>
  }

  export type ShortReportScalarWhereInput = {
    AND?: Enumerable<ShortReportScalarWhereInput>
    OR?: Enumerable<ShortReportScalarWhereInput>
    NOT?: Enumerable<ShortReportScalarWhereInput>
    shortId?: StringFilter | string
    userId?: StringFilter | string
    reason?: StringFilter | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutNotificationFromInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutNotificationFromInput, NotificationUncheckedUpdateWithoutNotificationFromInput>
    create: XOR<NotificationCreateWithoutNotificationFromInput, NotificationUncheckedCreateWithoutNotificationFromInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutNotificationFromInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutNotificationFromInput, NotificationUncheckedUpdateWithoutNotificationFromInput>
  }

  export type NotificationUpdateManyWithWhereWithoutNotificationFromInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationFromInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    id?: StringFilter | string
    userIdFrom?: StringNullableFilter | string | null
    userIdTo?: StringFilter | string
    data?: JsonFilter
    date?: DateTimeFilter | Date | string
    seen?: BoolFilter | boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutNotificationToInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutNotificationToInput, NotificationUncheckedUpdateWithoutNotificationToInput>
    create: XOR<NotificationCreateWithoutNotificationToInput, NotificationUncheckedCreateWithoutNotificationToInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutNotificationToInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutNotificationToInput, NotificationUncheckedUpdateWithoutNotificationToInput>
  }

  export type NotificationUpdateManyWithWhereWithoutNotificationToInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationToInput>
  }

  export type BlogUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutUserInput, BlogUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutUserInput, BlogUncheckedUpdateWithoutUserInput>
  }

  export type BlogUpdateManyWithWhereWithoutUserInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutBlogInput>
  }

  export type BlogScalarWhereInput = {
    AND?: Enumerable<BlogScalarWhereInput>
    OR?: Enumerable<BlogScalarWhereInput>
    NOT?: Enumerable<BlogScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    title?: StringFilter | string
    content?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    archived?: BoolFilter | boolean
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCommentCreateWithoutUserInput, BlogCommentUncheckedCreateWithoutUserInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutUserInput, BlogCommentUncheckedUpdateWithoutUserInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutUserInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutBlogCommentInput>
  }

  export type BlogCommentScalarWhereInput = {
    AND?: Enumerable<BlogCommentScalarWhereInput>
    OR?: Enumerable<BlogCommentScalarWhereInput>
    NOT?: Enumerable<BlogCommentScalarWhereInput>
    id?: StringFilter | string
    blogId?: StringFilter | string
    userId?: StringFilter | string
    content?: StringFilter | string
    date?: DateTimeFilter | Date | string
  }

  export type UserTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTokenWhereUniqueInput
    update: XOR<UserTokenUpdateWithoutUserInput, UserTokenUncheckedUpdateWithoutUserInput>
    create: XOR<UserTokenCreateWithoutUserInput, UserTokenUncheckedCreateWithoutUserInput>
  }

  export type UserTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTokenWhereUniqueInput
    data: XOR<UserTokenUpdateWithoutUserInput, UserTokenUncheckedUpdateWithoutUserInput>
  }

  export type UserTokenUpdateManyWithWhereWithoutUserInput = {
    where: UserTokenScalarWhereInput
    data: XOR<UserTokenUpdateManyMutationInput, UserTokenUncheckedUpdateManyWithoutUserTokenInput>
  }

  export type UserTokenScalarWhereInput = {
    AND?: Enumerable<UserTokenScalarWhereInput>
    OR?: Enumerable<UserTokenScalarWhereInput>
    NOT?: Enumerable<UserTokenScalarWhereInput>
    userId?: StringFilter | string
    userToken?: StringFilter | string
    userTokenType?: IntFilter | number
    userTokenExpiration?: IntFilter | number
  }

  export type UserCreateWithoutUserScoutInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserScoutInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserScoutInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserScoutInput, UserUncheckedCreateWithoutUserScoutInput>
  }

  export type UserCreateWithoutUserScoutedInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserScoutedInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserScoutedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserScoutedInput, UserUncheckedCreateWithoutUserScoutedInput>
  }

  export type UserUpsertWithoutUserScoutInput = {
    update: XOR<UserUpdateWithoutUserScoutInput, UserUncheckedUpdateWithoutUserScoutInput>
    create: XOR<UserCreateWithoutUserScoutInput, UserUncheckedCreateWithoutUserScoutInput>
  }

  export type UserUpdateWithoutUserScoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserScoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutUserScoutedInput = {
    update: XOR<UserUpdateWithoutUserScoutedInput, UserUncheckedUpdateWithoutUserScoutedInput>
    create: XOR<UserCreateWithoutUserScoutedInput, UserUncheckedCreateWithoutUserScoutedInput>
  }

  export type UserUpdateWithoutUserScoutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserScoutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserRoleInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRoleInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
  }

  export type UserUpsertWithoutUserRoleInput = {
    update: XOR<UserUpdateWithoutUserRoleInput, UserUncheckedUpdateWithoutUserRoleInput>
    create: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
  }

  export type UserUpdateWithoutUserRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserPermissionsInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPermissionsInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPermissionsInput, UserUncheckedCreateWithoutUserPermissionsInput>
  }

  export type UserUpsertWithoutUserPermissionsInput = {
    update: XOR<UserUpdateWithoutUserPermissionsInput, UserUncheckedUpdateWithoutUserPermissionsInput>
    create: XOR<UserCreateWithoutUserPermissionsInput, UserUncheckedCreateWithoutUserPermissionsInput>
  }

  export type UserUpdateWithoutUserPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserProfileInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProfileInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpsertWithoutUserProfileInput = {
    update: XOR<UserUpdateWithoutUserProfileInput, UserUncheckedUpdateWithoutUserProfileInput>
    create: XOR<UserCreateWithoutUserProfileInput, UserUncheckedCreateWithoutUserProfileInput>
  }

  export type UserUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserTagInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTagInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTagInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTagInput, UserUncheckedCreateWithoutUserTagInput>
  }

  export type UserUpsertWithoutUserTagInput = {
    update: XOR<UserUpdateWithoutUserTagInput, UserUncheckedUpdateWithoutUserTagInput>
    create: XOR<UserCreateWithoutUserTagInput, UserUncheckedCreateWithoutUserTagInput>
  }

  export type UserUpdateWithoutUserTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserSocialMediaInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSocialMediaInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSocialMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSocialMediaInput, UserUncheckedCreateWithoutUserSocialMediaInput>
  }

  export type UserUpsertWithoutUserSocialMediaInput = {
    update: XOR<UserUpdateWithoutUserSocialMediaInput, UserUncheckedUpdateWithoutUserSocialMediaInput>
    create: XOR<UserCreateWithoutUserSocialMediaInput, UserUncheckedCreateWithoutUserSocialMediaInput>
  }

  export type UserUpdateWithoutUserSocialMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserSocialMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserLocationInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserLocationInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserLocationInput, UserUncheckedCreateWithoutUserLocationInput>
  }

  export type UserUpsertWithoutUserLocationInput = {
    update: XOR<UserUpdateWithoutUserLocationInput, UserUncheckedUpdateWithoutUserLocationInput>
    create: XOR<UserCreateWithoutUserLocationInput, UserUncheckedCreateWithoutUserLocationInput>
  }

  export type UserUpdateWithoutUserLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserEmailInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserEmailInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserEmailInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserEmailInput, UserUncheckedCreateWithoutUserEmailInput>
  }

  export type UserUpsertWithoutUserEmailInput = {
    update: XOR<UserUpdateWithoutUserEmailInput, UserUncheckedUpdateWithoutUserEmailInput>
    create: XOR<UserCreateWithoutUserEmailInput, UserUncheckedCreateWithoutUserEmailInput>
  }

  export type UserUpdateWithoutUserEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserProfileFileInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProfileFileInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProfileFileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProfileFileInput, UserUncheckedCreateWithoutUserProfileFileInput>
  }

  export type UserUpsertWithoutUserProfileFileInput = {
    update: XOR<UserUpdateWithoutUserProfileFileInput, UserUncheckedUpdateWithoutUserProfileFileInput>
    create: XOR<UserCreateWithoutUserProfileFileInput, UserUncheckedCreateWithoutUserProfileFileInput>
  }

  export type UserUpdateWithoutUserProfileFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserProfileFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserDegreeInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserDegreeInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserDegreeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDegreeInput, UserUncheckedCreateWithoutUserDegreeInput>
  }

  export type UserUpsertWithoutUserDegreeInput = {
    update: XOR<UserUpdateWithoutUserDegreeInput, UserUncheckedUpdateWithoutUserDegreeInput>
    create: XOR<UserCreateWithoutUserDegreeInput, UserUncheckedCreateWithoutUserDegreeInput>
  }

  export type UserUpdateWithoutUserDegreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserDegreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutShortInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShortInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShortInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShortInput, UserUncheckedCreateWithoutShortInput>
  }

  export type ShortTagCreateWithoutShortInput = {
    tag: string
  }

  export type ShortTagUncheckedCreateWithoutShortInput = {
    tag: string
  }

  export type ShortTagCreateOrConnectWithoutShortInput = {
    where: ShortTagWhereUniqueInput
    create: XOR<ShortTagCreateWithoutShortInput, ShortTagUncheckedCreateWithoutShortInput>
  }

  export type ShortTagCreateManyShortInputEnvelope = {
    data: Enumerable<ShortTagCreateManyShortInput>
    skipDuplicates?: boolean
  }

  export type ShortReportCreateWithoutShortInput = {
    reason: string
    user: UserCreateNestedOneWithoutShortReportInput
  }

  export type ShortReportUncheckedCreateWithoutShortInput = {
    userId: string
    reason: string
  }

  export type ShortReportCreateOrConnectWithoutShortInput = {
    where: ShortReportWhereUniqueInput
    create: XOR<ShortReportCreateWithoutShortInput, ShortReportUncheckedCreateWithoutShortInput>
  }

  export type ShortReportCreateManyShortInputEnvelope = {
    data: Enumerable<ShortReportCreateManyShortInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutShortInput = {
    update: XOR<UserUpdateWithoutShortInput, UserUncheckedUpdateWithoutShortInput>
    create: XOR<UserCreateWithoutShortInput, UserUncheckedCreateWithoutShortInput>
  }

  export type UserUpdateWithoutShortInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutShortInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type ShortTagUpsertWithWhereUniqueWithoutShortInput = {
    where: ShortTagWhereUniqueInput
    update: XOR<ShortTagUpdateWithoutShortInput, ShortTagUncheckedUpdateWithoutShortInput>
    create: XOR<ShortTagCreateWithoutShortInput, ShortTagUncheckedCreateWithoutShortInput>
  }

  export type ShortTagUpdateWithWhereUniqueWithoutShortInput = {
    where: ShortTagWhereUniqueInput
    data: XOR<ShortTagUpdateWithoutShortInput, ShortTagUncheckedUpdateWithoutShortInput>
  }

  export type ShortTagUpdateManyWithWhereWithoutShortInput = {
    where: ShortTagScalarWhereInput
    data: XOR<ShortTagUpdateManyMutationInput, ShortTagUncheckedUpdateManyWithoutShortTagInput>
  }

  export type ShortTagScalarWhereInput = {
    AND?: Enumerable<ShortTagScalarWhereInput>
    OR?: Enumerable<ShortTagScalarWhereInput>
    NOT?: Enumerable<ShortTagScalarWhereInput>
    shortId?: StringFilter | string
    tag?: StringFilter | string
  }

  export type ShortReportUpsertWithWhereUniqueWithoutShortInput = {
    where: ShortReportWhereUniqueInput
    update: XOR<ShortReportUpdateWithoutShortInput, ShortReportUncheckedUpdateWithoutShortInput>
    create: XOR<ShortReportCreateWithoutShortInput, ShortReportUncheckedCreateWithoutShortInput>
  }

  export type ShortReportUpdateWithWhereUniqueWithoutShortInput = {
    where: ShortReportWhereUniqueInput
    data: XOR<ShortReportUpdateWithoutShortInput, ShortReportUncheckedUpdateWithoutShortInput>
  }

  export type ShortReportUpdateManyWithWhereWithoutShortInput = {
    where: ShortReportScalarWhereInput
    data: XOR<ShortReportUpdateManyMutationInput, ShortReportUncheckedUpdateManyWithoutShortReportInput>
  }

  export type ShortCreateWithoutShortTagInput = {
    id?: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    user: UserCreateNestedOneWithoutShortInput
    shortReport?: ShortReportCreateNestedManyWithoutShortInput
  }

  export type ShortUncheckedCreateWithoutShortTagInput = {
    id?: string
    userId: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    shortReport?: ShortReportUncheckedCreateNestedManyWithoutShortInput
  }

  export type ShortCreateOrConnectWithoutShortTagInput = {
    where: ShortWhereUniqueInput
    create: XOR<ShortCreateWithoutShortTagInput, ShortUncheckedCreateWithoutShortTagInput>
  }

  export type ShortUpsertWithoutShortTagInput = {
    update: XOR<ShortUpdateWithoutShortTagInput, ShortUncheckedUpdateWithoutShortTagInput>
    create: XOR<ShortCreateWithoutShortTagInput, ShortUncheckedCreateWithoutShortTagInput>
  }

  export type ShortUpdateWithoutShortTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShortInput
    shortReport?: ShortReportUpdateManyWithoutShortInput
  }

  export type ShortUncheckedUpdateWithoutShortTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    shortReport?: ShortReportUncheckedUpdateManyWithoutShortInput
  }

  export type UserCreateWithoutShortReportInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShortReportInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShortReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShortReportInput, UserUncheckedCreateWithoutShortReportInput>
  }

  export type ShortCreateWithoutShortReportInput = {
    id?: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    user: UserCreateNestedOneWithoutShortInput
    shortTag?: ShortTagCreateNestedManyWithoutShortInput
  }

  export type ShortUncheckedCreateWithoutShortReportInput = {
    id?: string
    userId: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
    shortTag?: ShortTagUncheckedCreateNestedManyWithoutShortInput
  }

  export type ShortCreateOrConnectWithoutShortReportInput = {
    where: ShortWhereUniqueInput
    create: XOR<ShortCreateWithoutShortReportInput, ShortUncheckedCreateWithoutShortReportInput>
  }

  export type UserUpsertWithoutShortReportInput = {
    update: XOR<UserUpdateWithoutShortReportInput, UserUncheckedUpdateWithoutShortReportInput>
    create: XOR<UserCreateWithoutShortReportInput, UserUncheckedCreateWithoutShortReportInput>
  }

  export type UserUpdateWithoutShortReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutShortReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type ShortUpsertWithoutShortReportInput = {
    update: XOR<ShortUpdateWithoutShortReportInput, ShortUncheckedUpdateWithoutShortReportInput>
    create: XOR<ShortCreateWithoutShortReportInput, ShortUncheckedCreateWithoutShortReportInput>
  }

  export type ShortUpdateWithoutShortReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutShortInput
    shortTag?: ShortTagUpdateManyWithoutShortInput
  }

  export type ShortUncheckedUpdateWithoutShortReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    shortTag?: ShortTagUncheckedUpdateManyWithoutShortInput
  }

  export type UserCreateWithoutNotificationFromInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationFromInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationFromInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationFromInput, UserUncheckedCreateWithoutNotificationFromInput>
  }

  export type UserCreateWithoutNotificationToInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationToInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationToInput, UserUncheckedCreateWithoutNotificationToInput>
  }

  export type UserUpsertWithoutNotificationFromInput = {
    update: XOR<UserUpdateWithoutNotificationFromInput, UserUncheckedUpdateWithoutNotificationFromInput>
    create: XOR<UserCreateWithoutNotificationFromInput, UserUncheckedCreateWithoutNotificationFromInput>
  }

  export type UserUpdateWithoutNotificationFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNotificationFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpsertWithoutNotificationToInput = {
    update: XOR<UserUpdateWithoutNotificationToInput, UserUncheckedUpdateWithoutNotificationToInput>
    create: XOR<UserCreateWithoutNotificationToInput, UserUncheckedCreateWithoutNotificationToInput>
  }

  export type UserUpdateWithoutNotificationToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutNotificationToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutBlogInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
  }

  export type BlogCommentCreateWithoutBlogInput = {
    id?: string
    content: string
    date: Date | string
    user: UserCreateNestedOneWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedCreateWithoutBlogInput = {
    id?: string
    userId: string
    content: string
    date: Date | string
  }

  export type BlogCommentCreateOrConnectWithoutBlogInput = {
    where: BlogCommentWhereUniqueInput
    create: XOR<BlogCommentCreateWithoutBlogInput, BlogCommentUncheckedCreateWithoutBlogInput>
  }

  export type BlogCommentCreateManyBlogInputEnvelope = {
    data: Enumerable<BlogCommentCreateManyBlogInput>
    skipDuplicates?: boolean
  }

  export type BlogMediaCreateWithoutBlogInput = {
    media: string
  }

  export type BlogMediaUncheckedCreateWithoutBlogInput = {
    media: string
  }

  export type BlogMediaCreateOrConnectWithoutBlogInput = {
    where: BlogMediaWhereUniqueInput
    create: XOR<BlogMediaCreateWithoutBlogInput, BlogMediaUncheckedCreateWithoutBlogInput>
  }

  export type BlogMediaCreateManyBlogInputEnvelope = {
    data: Enumerable<BlogMediaCreateManyBlogInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogInput = {
    update: XOR<UserUpdateWithoutBlogInput, UserUncheckedUpdateWithoutBlogInput>
    create: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
  }

  export type UserUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type BlogCommentUpsertWithWhereUniqueWithoutBlogInput = {
    where: BlogCommentWhereUniqueInput
    update: XOR<BlogCommentUpdateWithoutBlogInput, BlogCommentUncheckedUpdateWithoutBlogInput>
    create: XOR<BlogCommentCreateWithoutBlogInput, BlogCommentUncheckedCreateWithoutBlogInput>
  }

  export type BlogCommentUpdateWithWhereUniqueWithoutBlogInput = {
    where: BlogCommentWhereUniqueInput
    data: XOR<BlogCommentUpdateWithoutBlogInput, BlogCommentUncheckedUpdateWithoutBlogInput>
  }

  export type BlogCommentUpdateManyWithWhereWithoutBlogInput = {
    where: BlogCommentScalarWhereInput
    data: XOR<BlogCommentUpdateManyMutationInput, BlogCommentUncheckedUpdateManyWithoutBlogCommentInput>
  }

  export type BlogMediaUpsertWithWhereUniqueWithoutBlogInput = {
    where: BlogMediaWhereUniqueInput
    update: XOR<BlogMediaUpdateWithoutBlogInput, BlogMediaUncheckedUpdateWithoutBlogInput>
    create: XOR<BlogMediaCreateWithoutBlogInput, BlogMediaUncheckedCreateWithoutBlogInput>
  }

  export type BlogMediaUpdateWithWhereUniqueWithoutBlogInput = {
    where: BlogMediaWhereUniqueInput
    data: XOR<BlogMediaUpdateWithoutBlogInput, BlogMediaUncheckedUpdateWithoutBlogInput>
  }

  export type BlogMediaUpdateManyWithWhereWithoutBlogInput = {
    where: BlogMediaScalarWhereInput
    data: XOR<BlogMediaUpdateManyMutationInput, BlogMediaUncheckedUpdateManyWithoutBlogMediaInput>
  }

  export type BlogMediaScalarWhereInput = {
    AND?: Enumerable<BlogMediaScalarWhereInput>
    OR?: Enumerable<BlogMediaScalarWhereInput>
    NOT?: Enumerable<BlogMediaScalarWhereInput>
    blogId?: StringFilter | string
    media?: StringFilter | string
  }

  export type BlogCreateWithoutBlogCommentInput = {
    id?: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    user: UserCreateNestedOneWithoutBlogInput
    blogMedia?: BlogMediaCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutBlogCommentInput = {
    id?: string
    userId: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    blogMedia?: BlogMediaUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutBlogCommentInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutBlogCommentInput, BlogUncheckedCreateWithoutBlogCommentInput>
  }

  export type UserCreateWithoutBlogCommentInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogCommentInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
  }

  export type BlogUpsertWithoutBlogCommentInput = {
    update: XOR<BlogUpdateWithoutBlogCommentInput, BlogUncheckedUpdateWithoutBlogCommentInput>
    create: XOR<BlogCreateWithoutBlogCommentInput, BlogUncheckedCreateWithoutBlogCommentInput>
  }

  export type BlogUpdateWithoutBlogCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBlogInput
    blogMedia?: BlogMediaUpdateManyWithoutBlogInput
  }

  export type BlogUncheckedUpdateWithoutBlogCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    blogMedia?: BlogMediaUncheckedUpdateManyWithoutBlogInput
  }

  export type UserUpsertWithoutBlogCommentInput = {
    update: XOR<UserUpdateWithoutBlogCommentInput, UserUncheckedUpdateWithoutBlogCommentInput>
    create: XOR<UserCreateWithoutBlogCommentInput, UserUncheckedCreateWithoutBlogCommentInput>
  }

  export type UserUpdateWithoutBlogCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutBlogCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type BlogCreateWithoutBlogMediaInput = {
    id?: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    user: UserCreateNestedOneWithoutBlogInput
    blogComment?: BlogCommentCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutBlogMediaInput = {
    id?: string
    userId: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
    blogComment?: BlogCommentUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutBlogMediaInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutBlogMediaInput, BlogUncheckedCreateWithoutBlogMediaInput>
  }

  export type BlogUpsertWithoutBlogMediaInput = {
    update: XOR<BlogUpdateWithoutBlogMediaInput, BlogUncheckedUpdateWithoutBlogMediaInput>
    create: XOR<BlogCreateWithoutBlogMediaInput, BlogUncheckedCreateWithoutBlogMediaInput>
  }

  export type BlogUpdateWithoutBlogMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutBlogInput
    blogComment?: BlogCommentUpdateManyWithoutBlogInput
  }

  export type BlogUncheckedUpdateWithoutBlogMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    blogComment?: BlogCommentUncheckedUpdateManyWithoutBlogInput
  }

  export type UserCreateWithoutUserTokenInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserTokenInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserTokenInput, UserUncheckedCreateWithoutUserTokenInput>
  }

  export type UserUpsertWithoutUserTokenInput = {
    update: XOR<UserUpdateWithoutUserTokenInput, UserUncheckedUpdateWithoutUserTokenInput>
    create: XOR<UserCreateWithoutUserTokenInput, UserUncheckedCreateWithoutUserTokenInput>
  }

  export type UserUpdateWithoutUserTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserContactNumberInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserContactNumberInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserContactNumberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserContactNumberInput, UserUncheckedCreateWithoutUserContactNumberInput>
  }

  export type UserUpsertWithoutUserContactNumberInput = {
    update: XOR<UserUpdateWithoutUserContactNumberInput, UserUncheckedUpdateWithoutUserContactNumberInput>
    create: XOR<UserCreateWithoutUserContactNumberInput, UserUncheckedCreateWithoutUserContactNumberInput>
  }

  export type UserUpdateWithoutUserContactNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserContactNumberInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUserExperienceInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    company?: UserCreateNestedOneWithoutUserInput
    User?: UserCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileCreateNestedManyWithoutUserInput
    UserTag?: UserTagCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileCreateNestedManyWithoutUserInput
    Short?: ShortCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationCreateNestedManyWithoutNotificationToInput
    Blog?: BlogCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentCreateNestedManyWithoutUserInput
    UserToken?: UserTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserExperienceInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    companyId?: string | null
    created: Date | string
    suspended: boolean
    validated: boolean
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedCreateNestedManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedCreateNestedManyWithoutUserInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedCreateNestedManyWithoutUserInput
    UserProfile?: UserProfileUncheckedCreateNestedManyWithoutUserInput
    UserTag?: UserTagUncheckedCreateNestedManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedCreateNestedManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedCreateNestedManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedCreateNestedManyWithoutUserInput
    UserLocation?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    UserEmail?: UserEmailUncheckedCreateNestedManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedCreateNestedManyWithoutUserInput
    Short?: ShortUncheckedCreateNestedManyWithoutUserInput
    ShortReport?: ShortReportUncheckedCreateNestedManyWithoutUserInput
    notificationFrom?: NotificationUncheckedCreateNestedManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedCreateNestedManyWithoutNotificationToInput
    Blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedCreateNestedManyWithoutUserInput
    UserToken?: UserTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserExperienceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserExperienceInput, UserUncheckedCreateWithoutUserExperienceInput>
  }

  export type UserUpsertWithoutUserExperienceInput = {
    update: XOR<UserUpdateWithoutUserExperienceInput, UserUncheckedUpdateWithoutUserExperienceInput>
    create: XOR<UserCreateWithoutUserExperienceInput, UserUncheckedCreateWithoutUserExperienceInput>
  }

  export type UserUpdateWithoutUserExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    company?: UserUpdateOneWithoutUserInput
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUserExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email: string
    password?: string | null
    passwordSalt?: string | null
    name?: string | null
    dateOfBirth?: Date | string | null
    created: Date | string
    suspended: boolean
    validated: boolean
  }

  export type UserScoutedCreateManyUserScoutInput = {
    userId: string
    date?: Date | string | null
  }

  export type UserScoutedCreateManyUserInput = {
    userIdScout: string
    date?: Date | string | null
  }

  export type UserRoleCreateManyUserInput = {
    role: Role
  }

  export type UserPermissionsCreateManyUserInput = {
    permissionType: PermissionType
    permissionCategory: PermissionCategory
    permissionTenant: PermissionTenant
  }

  export type UserProfileCreateManyUserInput = {
    profilePicture?: string | null
    bio?: string | null
    employmentStatus?: boolean
    openToOffers?: boolean
  }

  export type UserTagCreateManyUserInput = {
    tag: string
  }

  export type UserContactNumberCreateManyUserInput = {
    number: string
  }

  export type UserDegreeCreateManyUserInput = {
    degreeType: string
    degreeName: string
  }

  export type UserExperienceCreateManyUserInput = {
    experience: string
  }

  export type UserSocialMediaCreateManyUserInput = {
    type: SocialMedia
    link: string
  }

  export type UserLocationCreateManyUserInput = {
    location: string
  }

  export type UserEmailCreateManyUserInput = {
    email: string
  }

  export type UserProfileFileCreateManyUserInput = {
    fileId?: string
    filePath: string
    fileCategory?: FileCategory | null
    fileExtension?: string | null
  }

  export type ShortCreateManyUserInput = {
    id?: string
    description?: string | null
    link?: string | null
    thumbnail?: string | null
    datePosted: Date | string
    archived: boolean
  }

  export type ShortReportCreateManyUserInput = {
    shortId: string
    reason: string
  }

  export type NotificationCreateManyNotificationFromInput = {
    id?: string
    userIdTo: string
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
  }

  export type NotificationCreateManyNotificationToInput = {
    id?: string
    userIdFrom?: string | null
    data: JsonNullValueInput | InputJsonValue
    date: Date | string
    seen: boolean
  }

  export type BlogCreateManyUserInput = {
    id?: string
    title: string
    content?: string | null
    date: Date | string
    archived: boolean
  }

  export type BlogCommentCreateManyUserInput = {
    id?: string
    blogId: string
    content: string
    date: Date | string
  }

  export type UserTokenCreateManyUserInput = {
    userToken: string
    userTokenType: number
    userTokenExpiration: number
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUpdateManyWithoutUserInput
    UserRole?: UserRoleUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUpdateManyWithoutUserInput
    UserProfile?: UserProfileUpdateManyWithoutUserInput
    UserTag?: UserTagUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUpdateManyWithoutUserInput
    UserLocation?: UserLocationUpdateManyWithoutUserInput
    UserEmail?: UserEmailUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUpdateManyWithoutUserInput
    Short?: ShortUpdateManyWithoutUserInput
    ShortReport?: ShortReportUpdateManyWithoutUserInput
    notificationFrom?: NotificationUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUpdateManyWithoutNotificationToInput
    Blog?: BlogUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUpdateManyWithoutUserInput
    UserToken?: UserTokenUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUncheckedUpdateManyWithoutCompanyInput
    userScout?: UserScoutedUncheckedUpdateManyWithoutUserScoutInput
    userScouted?: UserScoutedUncheckedUpdateManyWithoutUserInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserInput
    UserPermissions?: UserPermissionsUncheckedUpdateManyWithoutUserInput
    UserProfile?: UserProfileUncheckedUpdateManyWithoutUserInput
    UserTag?: UserTagUncheckedUpdateManyWithoutUserInput
    UserContactNumber?: UserContactNumberUncheckedUpdateManyWithoutUserInput
    UserDegree?: UserDegreeUncheckedUpdateManyWithoutUserInput
    UserExperience?: UserExperienceUncheckedUpdateManyWithoutUserInput
    UserSocialMedia?: UserSocialMediaUncheckedUpdateManyWithoutUserInput
    UserLocation?: UserLocationUncheckedUpdateManyWithoutUserInput
    UserEmail?: UserEmailUncheckedUpdateManyWithoutUserInput
    UserProfileFile?: UserProfileFileUncheckedUpdateManyWithoutUserInput
    Short?: ShortUncheckedUpdateManyWithoutUserInput
    ShortReport?: ShortReportUncheckedUpdateManyWithoutUserInput
    notificationFrom?: NotificationUncheckedUpdateManyWithoutNotificationFromInput
    notificationTo?: NotificationUncheckedUpdateManyWithoutNotificationToInput
    Blog?: BlogUncheckedUpdateManyWithoutUserInput
    BlogComment?: BlogCommentUncheckedUpdateManyWithoutUserInput
    UserToken?: UserTokenUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    passwordSalt?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    suspended?: BoolFieldUpdateOperationsInput | boolean
    validated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserScoutedUpdateWithoutUserScoutInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserScoutedInput
  }

  export type UserScoutedUncheckedUpdateWithoutUserScoutInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserScoutedUpdateWithoutUserInput = {
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userScout?: UserUpdateOneRequiredWithoutUserScoutInput
  }

  export type UserScoutedUncheckedUpdateWithoutUserInput = {
    userIdScout?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserScoutedUncheckedUpdateManyWithoutUserScoutedInput = {
    userIdScout?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserRoleUncheckedUpdateManyWithoutUserRoleInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserPermissionsUpdateWithoutUserInput = {
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type UserPermissionsUncheckedUpdateWithoutUserInput = {
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type UserPermissionsUncheckedUpdateManyWithoutUserPermissionsInput = {
    permissionType?: EnumPermissionTypeFieldUpdateOperationsInput | PermissionType
    permissionCategory?: EnumPermissionCategoryFieldUpdateOperationsInput | PermissionCategory
    permissionTenant?: EnumPermissionTenantFieldUpdateOperationsInput | PermissionTenant
  }

  export type UserProfileUpdateWithoutUserInput = {
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProfileUncheckedUpdateManyWithoutUserProfileInput = {
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employmentStatus?: BoolFieldUpdateOperationsInput | boolean
    openToOffers?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTagUpdateWithoutUserInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagUncheckedUpdateWithoutUserInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type UserTagUncheckedUpdateManyWithoutUserTagInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type UserContactNumberUpdateWithoutUserInput = {
    number?: StringFieldUpdateOperationsInput | string
  }

  export type UserContactNumberUncheckedUpdateWithoutUserInput = {
    number?: StringFieldUpdateOperationsInput | string
  }

  export type UserContactNumberUncheckedUpdateManyWithoutUserContactNumberInput = {
    number?: StringFieldUpdateOperationsInput | string
  }

  export type UserDegreeUpdateWithoutUserInput = {
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
  }

  export type UserDegreeUncheckedUpdateWithoutUserInput = {
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
  }

  export type UserDegreeUncheckedUpdateManyWithoutUserDegreeInput = {
    degreeType?: StringFieldUpdateOperationsInput | string
    degreeName?: StringFieldUpdateOperationsInput | string
  }

  export type UserExperienceUpdateWithoutUserInput = {
    experience?: StringFieldUpdateOperationsInput | string
  }

  export type UserExperienceUncheckedUpdateWithoutUserInput = {
    experience?: StringFieldUpdateOperationsInput | string
  }

  export type UserExperienceUncheckedUpdateManyWithoutUserExperienceInput = {
    experience?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialMediaUpdateWithoutUserInput = {
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialMediaUncheckedUpdateWithoutUserInput = {
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
  }

  export type UserSocialMediaUncheckedUpdateManyWithoutUserSocialMediaInput = {
    type?: EnumSocialMediaFieldUpdateOperationsInput | SocialMedia
    link?: StringFieldUpdateOperationsInput | string
  }

  export type UserLocationUpdateWithoutUserInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type UserLocationUncheckedUpdateWithoutUserInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type UserLocationUncheckedUpdateManyWithoutUserLocationInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmailUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmailUncheckedUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserEmailUncheckedUpdateManyWithoutUserEmailInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileFileUpdateWithoutUserInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileFileUncheckedUpdateWithoutUserInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileFileUncheckedUpdateManyWithoutUserProfileFileInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileCategory?: NullableEnumFileCategoryFieldUpdateOperationsInput | FileCategory | null
    fileExtension?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShortUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    shortTag?: ShortTagUpdateManyWithoutShortInput
    shortReport?: ShortReportUpdateManyWithoutShortInput
  }

  export type ShortUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    shortTag?: ShortTagUncheckedUpdateManyWithoutShortInput
    shortReport?: ShortReportUncheckedUpdateManyWithoutShortInput
  }

  export type ShortUncheckedUpdateManyWithoutShortInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    datePosted?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShortReportUpdateWithoutUserInput = {
    reason?: StringFieldUpdateOperationsInput | string
    short?: ShortUpdateOneRequiredWithoutShortReportInput
  }

  export type ShortReportUncheckedUpdateWithoutUserInput = {
    shortId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type ShortReportUncheckedUpdateManyWithoutShortReportInput = {
    shortId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutNotificationFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    notificationTo?: UserUpdateOneRequiredWithoutNotificationToInput
  }

  export type NotificationUncheckedUpdateWithoutNotificationFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIdTo?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUpdateWithoutNotificationToInput = {
    id?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    notificationFrom?: UserUpdateOneWithoutNotificationFromInput
  }

  export type NotificationUncheckedUpdateWithoutNotificationToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userIdFrom?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    seen?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    blogComment?: BlogCommentUpdateManyWithoutBlogInput
    blogMedia?: BlogMediaUpdateManyWithoutBlogInput
  }

  export type BlogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    blogComment?: BlogCommentUncheckedUpdateManyWithoutBlogInput
    blogMedia?: BlogMediaUncheckedUpdateManyWithoutBlogInput
  }

  export type BlogUncheckedUpdateManyWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlogCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    blog?: BlogUpdateOneRequiredWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCommentUncheckedUpdateManyWithoutBlogCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTokenUpdateWithoutUserInput = {
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
  }

  export type UserTokenUncheckedUpdateWithoutUserInput = {
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
  }

  export type UserTokenUncheckedUpdateManyWithoutUserTokenInput = {
    userToken?: StringFieldUpdateOperationsInput | string
    userTokenType?: IntFieldUpdateOperationsInput | number
    userTokenExpiration?: IntFieldUpdateOperationsInput | number
  }

  export type ShortTagCreateManyShortInput = {
    tag: string
  }

  export type ShortReportCreateManyShortInput = {
    userId: string
    reason: string
  }

  export type ShortTagUpdateWithoutShortInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ShortTagUncheckedUpdateWithoutShortInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ShortTagUncheckedUpdateManyWithoutShortTagInput = {
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type ShortReportUpdateWithoutShortInput = {
    reason?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutShortReportInput
  }

  export type ShortReportUncheckedUpdateWithoutShortInput = {
    userId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
  }

  export type BlogCommentCreateManyBlogInput = {
    id?: string
    userId: string
    content: string
    date: Date | string
  }

  export type BlogMediaCreateManyBlogInput = {
    media: string
  }

  export type BlogCommentUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlogCommentInput
  }

  export type BlogCommentUncheckedUpdateWithoutBlogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogMediaUpdateWithoutBlogInput = {
    media?: StringFieldUpdateOperationsInput | string
  }

  export type BlogMediaUncheckedUpdateWithoutBlogInput = {
    media?: StringFieldUpdateOperationsInput | string
  }

  export type BlogMediaUncheckedUpdateManyWithoutBlogMediaInput = {
    media?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}